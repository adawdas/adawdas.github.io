<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>lca的几种算法实现</title>
    <url>/2020/05/01/lca/</url>
    <content><![CDATA[<p>求最近公共祖先的几种算法</p>
<a id="more"></a>

<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><code>LCA</code>（Least Common Ancestors），即最近公共祖先，指对于有根树 <code>TT</code> 的两个结点 <code>uu</code> 、<code>vv</code> ，最近公共祖先 <code>LCA(T,u,v)</code> <code>LCA(T,u,v)</code> 表示一个结点 <code>xx</code>, 满足 <code>xx</code> 是 <code>uu</code>、<code>vv</code> 的祖先且 <code>xx</code> 的深度尽可能大。</p>
<h2 id="倍增法"><a href="#倍增法" class="headerlink" title="倍增法"></a>倍增法</h2><h3 id="暴力求解lca"><a href="#暴力求解lca" class="headerlink" title="暴力求解lca"></a>暴力求解lca</h3><p>首先遍历一遍树，并求出所有节点的深度及其父节点</p>
<p>对于查询<code>lca(u,v)</code>,我们假定<code>depth[u]&gt;depth[v]</code>,那么我可以首先将节点<code>u</code>沿着其父节点路径向上走，直到它的深度和节点<code>v</code>相同</p>
<p>当两个节点深度相同时，再让两个节点同时向上走，相遇的位置就是<code>lca(u,v)</code></p>
<h3 id="倍增优化lca"><a href="#倍增优化lca" class="headerlink" title="倍增优化lca"></a>倍增优化lca</h3><p>暴力解法每次只能向上移动一个节点，效率较低。<br>故可以采用倍增的方法来优化<br>令<code>fa[x][y]</code>表示节点<code>x</code>的第<code>2^y</code>个祖先节点<br>则有以下的递推关系<br><code>fa[x][y]=fa[fa[x][y-1]][y-1]</code><br>(<code>x</code>的第<code>2^y</code>个祖先节点是它的第<code>2^(y-1)</code>个祖先节点的第<code>2^(y-1)</code>个祖先节点)<br>之后对<code>u</code>进行二进制拆分<br>如<code>u</code>的深度为<code>13</code>,<code>v</code>的深度为<code>2</code>,那么<code>u</code>深度的变化过程为<code>13-&gt;5-&gt;3-&gt;2</code>,最终<code>u</code>,<code>v</code>深度相同<br>当<code>u</code>,<code>v</code>深度相同时，分两种情况<br>1.<code>u==v</code>那么<code>v</code>是<code>u</code>的祖先，<code>lca(u,v)=v</code></p>
<p>2.<code>u!=v</code>,此时量者同时向上跳</p>
<p>跳变的条件是<code>fa(u,i)!=fa(v,i)</code><br>因为如果<code>fa(u,i)==fa(v,i)</code>代表此时<code>u</code>，<code>v</code>同时向上跳变了<code>2^i</code>层之后的节点是同一个点，但这不一定是它们的<code>lca</code></p>
<p>原因在于我们的初始化方式，我们将根节点设为<code>1</code>，非法跳到根以上的节点全都是<code>0</code>（如<code>fa[3][2]</code>(以层次遍历顺序为<code>123……n</code>建树的节点<code>3</code>的第<code>4</code>个祖先节点),显然是非法的，我们在初始化的时候也并不会初始化到这个值，它的值就为默认值<code>0</code>）</p>
<p>以这样的方式跳变之后，它们一定会到达的<code>lca</code>的下一层(模拟一下即可)<br>此时它们的<code>lca</code>就是<code>fa[u][0]</code>,也是<code>fa[v][0]</code></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(depth, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(depth));</span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">    q[<span class="number">0</span>] = root;</span><br><span class="line">    depth[root] = <span class="number">1</span>;</span><br><span class="line">    depth[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(hh&lt;=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = q[hh++];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[t]; ~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(depth[j]&gt;depth[t]+<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                depth[j] = depth[t] + <span class="number">1</span>;</span><br><span class="line">                fa[j][<span class="number">0</span>] = t;</span><br><span class="line">                q[++tt] = j;</span><br><span class="line">				<span class="comment">//递推fa数组</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= maxdepth;k++)</span><br><span class="line">                    fa[j][k] = fa[fa[j][k - <span class="number">1</span>]][k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(depth[a]&lt;depth[b])<span class="comment">//默认a比b深</span></span><br><span class="line">        swap(a, b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = maxdepth; k &gt;= <span class="number">0</span>;k--)</span><br><span class="line">        <span class="keyword">if</span>(depth[fa[a][k]]&gt;=depth[b])</span><br><span class="line">            a = fa[a][k];</span><br><span class="line">    <span class="keyword">if</span>(a==b)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = maxdepth; k &gt;= <span class="number">0</span>;k--)</span><br><span class="line">        <span class="keyword">if</span>(fa[a][k]!=fa[b][k])</span><br><span class="line">        &#123;</span><br><span class="line">            a = fa[a][k];</span><br><span class="line">            b = fa[b][k];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[a][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Tarjan算法"><a href="#Tarjan算法" class="headerlink" title="Tarjan算法"></a>Tarjan算法</h2><h3 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h3><p>进行一遍<code>dfs</code>（中序遍历），假设有询问<code>lca(u,v)</code>,对于节点<code>u</code>，看一下<code>v</code>是否在之前被遍历到了，如果<code>v</code>在<code>u</code>之前被遍历到，那么查询<code>v</code>此时的已经遍历到的根<code>root</code>，此时这个<code>root</code>即为<code>lca(u,v)</code><br>原因：用树的方式思考，因为是中序遍历，访问顺序为左-&gt;根-&gt;右，<code>v</code>在<code>u</code>之前被遍历到，有<code>3</code>种情况<br>1.存在一棵树，<code>u</code>在其左子树，<code>v</code>在其右子树<br>2.存在一棵树，<code>u</code>在其左子树，<code>v</code>在其根<br>3.存在一棵树，<code>u</code>在其根，<code>v</code>在其右子树<br>对于以上三种情况，<code>u</code>的根一定会被压缩到<code>lca(u,v)</code></p>
<h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><p>已知有树如下所示</p>
<p><img src="/images/lca.png" alt="alt"></p>
<p>有询问<code>lca(5,6)</code>,<code>lca(5,3)</code></p>
<p>首先遍历到<code>5</code>,此时查看<code>5</code>的所有查询，发现<code>3</code>，<code>6</code>均未被访问<br>访问到<code>2</code>，<code>p[5]&lt;-2</code><br>访问到<code>6</code>，发现<code>5</code>被访问过，此时<code>p[5]=2</code>,故<code>lca(5,6)=2</code><br>回溯到<code>2</code>，<code>p[6]&lt;-2</code><br>回溯到<code>1</code>，<code>p[2]&lt;-1</code>,路径压缩<code>p[5]&lt;-1,p[6]&lt;-1</code></p>
<p>访问到<code>3</code>，发现<code>5</code>被访问过，此时<code>p[5]=1</code>,故<code>lca(5,3)=1</code></p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==p[x])</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> p[x] = find(p[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; ~i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(j==fa)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        dist[j] = dist[u] + w[i];</span><br><span class="line">        dfs(j, u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; ~i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            tarjan(j);</span><br><span class="line">            p[j] = u;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t:query[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = t.first;</span><br><span class="line">        <span class="keyword">int</span> id = t.second;</span><br><span class="line">        <span class="keyword">if</span>(st[x]==<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> lca = find(x);</span><br><span class="line">			res[id]=lca;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    st[u] = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>代码模板</category>
      </categories>
      <tags>
        <tag>lca</tag>
      </tags>
  </entry>
  <entry>
    <title>距离 acwing 1171</title>
    <url>/2020/04/30/ac1171/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/1173/" target="_blank" rel="noopener">Acwing1171</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给出 n 个点的一棵树，多次询问两点之间的最短距离。</p>
<p>注意：</p>
<p>边是无向的。<br>所有节点的编号是 1,2,…,n。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行为两个整数 n 和 m。n 表示点数，m 表示询问次数；</p>
<p>下来 n−1 行，每行三个整数 x,y,k，表示点 x 和点 y 之间存在一条边长度为 k；</p>
<p>再接下来 m 行，每行两个整数 x,y，表示询问点 x 到点 y 的最短距离。</p>
<p>树中结点编号从 1 到 n。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>共 m 行，对于每次询问，输出一行询问结果。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>2≤n≤1e4,<br>1≤m≤2×1e4,<br>0&lt; k≤100,<br>1≤x,y≤n</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 2 </span><br><span class="line">1 2 100 </span><br><span class="line">1 2 </span><br><span class="line">2 1</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">100</span><br><span class="line">100</span><br></pre></td></tr></table></figure>

<h3 id="题意分析"><a href="#题意分析" class="headerlink" title="题意分析"></a>题意分析</h3><p>画图易知,求两个节点的最短距离即求两个点到树根的距离之和减去它们的lca到树根的距离的两倍<br>用tarjan算法求lca</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10010</span>, M = N * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> h[N], e[M], w[M], ne[M], idx;</span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"><span class="keyword">int</span> st[N];</span><br><span class="line"><span class="keyword">int</span> res[M];</span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;PII&gt; query[N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    w[idx] = c;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==p[x])</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> p[x] = find(p[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; ~i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(j==fa)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        dist[j] = dist[u] + w[i];</span><br><span class="line">        dfs(j, u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; ~i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            tarjan(j);</span><br><span class="line">            p[j] = u;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t:query[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = t.first;</span><br><span class="line">        <span class="keyword">int</span> id = t.second;</span><br><span class="line">        <span class="keyword">if</span>(st[x]==<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> lca = find(x);</span><br><span class="line">            res[id] = dist[x] + dist[u] - <span class="number">2</span> * dist[lca];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    st[u] = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">        p[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        add(a, b, c);</span><br><span class="line">        add(b, a, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">if</span>(a!=b)</span><br><span class="line">        &#123;</span><br><span class="line">            query[a].push_back(&#123;b, i&#125;);</span><br><span class="line">            query[b].push_back(&#123;a, i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    tarjan(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m;i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; res[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>lca</tag>
      </tags>
  </entry>
  <entry>
    <title>排队布局 acwing 1170</title>
    <url>/2020/04/30/ac1170/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/1172/" target="_blank" rel="noopener">Acwing1170</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>当排队等候喂食时，奶牛喜欢和它们的朋友站得靠近些。</p>
<p>农夫约翰有 N 头奶牛，编号从 1 到 N，沿一条直线站着等候喂食。</p>
<p>奶牛排在队伍中的顺序和它们的编号是相同的。</p>
<p>因为奶牛相当苗条，所以可能有两头或者更多奶牛站在同一位置上。</p>
<p>如果我们想象奶牛是站在一条数轴上的话，允许有两头或更多奶牛拥有相同的横坐标。</p>
<p>一些奶牛相互间存有好感，它们希望两者之间的距离不超过一个给定的数 L。</p>
<p>另一方面，一些奶牛相互间非常反感，它们希望两者间的距离不小于一个给定的数 D。</p>
<p>给出 ML 条关于两头奶牛间有好感的描述，再给出 MD 条关于两头奶牛间存有反感的描述。</p>
<p>你的工作是：如果不存在满足要求的方案，输出-1；如果 1 号奶牛和 N 号奶牛间的距离可以任意大，输出-2；否则，计算出在满足所有要求的情况下，1 号奶牛和 N 号奶牛间可能的最大距离。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含三个整数 N,ML,MD。</p>
<p>接下来 ML 行，每行包含三个正整数 A,B,L，表示奶牛 A 和奶牛 B 至多相隔 L 的距离。</p>
<p>再接下来 MD 行，每行包含三个正整数 A,B,D，表示奶牛 A 和奶牛 B 至少相隔 D 的距离。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个整数，如果不存在满足要求的方案，输出-1；如果 1 号奶牛和 N 号奶牛间的距离可以任意大，输出-2；否则，输出在满足所有要求的情况下，1 号奶牛和 N 号奶牛间可能的最大距离。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>2≤N≤1000,<br>1≤ML,MD≤1e4,<br>1≤L,D≤1e6</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 2 1</span><br><span class="line">1 3 10</span><br><span class="line">2 4 20</span><br><span class="line">2 3 3</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">27</span><br></pre></td></tr></table></figure>

<h3 id="题意分析"><a href="#题意分析" class="headerlink" title="题意分析"></a>题意分析</h3><p>差分约束<br><code>dist[i]</code>表示第i头牛的坐标<br>建边(设<code>a&gt;b</code>):<br>1.<code>dist[a]-dist[b]&lt;=l</code><br>2.<code>dist[a]-dist[b]&gt;=d</code><br>3.<code>dist[i]&gt;=dist[i-1]</code>(奶牛排在队伍中的顺序和它们的编号是相同的。)</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10010</span>, M = <span class="number">4</span> * N;</span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], w[M], idx;</span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"><span class="keyword">int</span> cnt[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="keyword">int</span> n, m1, m2;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    w[idx] = c;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dist));</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span>(st));</span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        q[tt++] = i;</span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(hh!=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = q[hh++];</span><br><span class="line">        <span class="keyword">if</span>(hh==N)</span><br><span class="line">        hh=<span class="number">0</span>;</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[t]; ~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j]&gt;dist[t]+w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                cnt[j] = cnt[t] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(cnt[j]==n+<span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                    q[tt++] = j;</span><br><span class="line">                    <span class="keyword">if</span>(tt==N)</span><br><span class="line">                    tt=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m1 &gt;&gt; m2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n;i++)</span><br><span class="line">        add(i, i - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m1; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="keyword">if</span>(a&gt;b)</span><br><span class="line">            swap(a, b);</span><br><span class="line">        add(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m2;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="keyword">if</span>(a&gt;b)</span><br><span class="line">            swap(a, b);</span><br><span class="line">        add(b, a, -c);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!spfa())</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(dist[n]==<span class="number">0x3f3f3f3f</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-2\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dist[n]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>差分约束</tag>
      </tags>
  </entry>
  <entry>
    <title>祖孙询问 acwing 1172</title>
    <url>/2020/04/30/ac1172/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/1174/" target="_blank" rel="noopener">Acwing1172</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定一棵包含 n 个节点的有根无向树，节点编号互不相同，但不一定是 1∼n。</p>
<p>有 m 个询问，每个询问给出了一对节点的编号 x 和 y，询问 x 与 y 的祖孙关系。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入第一行包括一个整数 表示节点个数；</p>
<p>接下来 n 行每行一对整数 a 和 b，表示 a 和 b 之间有一条无向边。如果 b 是 −1，那么 a 就是树的根；</p>
<p>第 n+2 行是一个整数 m 表示询问个数；</p>
<p>接下来 m 行，每行两个不同的正整数 x 和 y，表示一个询问。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>对于每一个询问，若 x 是 y 的祖先则输出 1，若 y 是 x 的祖先则输出 2，否则输出 0。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤n,m≤4×1e4,<br>1≤每个节点的编号≤4×1e4</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">234 -1</span><br><span class="line">12 234</span><br><span class="line">13 234</span><br><span class="line">14 234</span><br><span class="line">15 234</span><br><span class="line">16 234</span><br><span class="line">17 234</span><br><span class="line">18 234</span><br><span class="line">19 234</span><br><span class="line">233 19</span><br><span class="line">5</span><br><span class="line">234 233</span><br><span class="line">233 12</span><br><span class="line">233 13</span><br><span class="line">233 15</span><br><span class="line">233 19</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<h3 id="题意分析"><a href="#题意分析" class="headerlink" title="题意分析"></a>题意分析</h3><p>求lca(最近公共祖先)</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//倍增法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">50010</span>, M = N * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="keyword">int</span> fa[N][<span class="number">16</span>];</span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"><span class="keyword">int</span> depth[N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(depth, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(depth));</span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">    q[<span class="number">0</span>] = root;</span><br><span class="line">    depth[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    depth[root] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(hh&lt;=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = q[hh++];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[t]; ~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(depth[j]&gt;depth[t]+<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                depth[j] = depth[t] + <span class="number">1</span>;</span><br><span class="line">                fa[j][<span class="number">0</span>] = t;</span><br><span class="line">                q[++tt] = j;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">15</span>;k++)</span><br><span class="line">                    fa[j][k] = fa[fa[j][k - <span class="number">1</span>]][k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(depth[a]&lt;depth[b])</span><br><span class="line">        swap(a, b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">15</span>; k &gt;= <span class="number">0</span>;k--)</span><br><span class="line">        <span class="keyword">if</span>(depth[fa[a][k]]&gt;=depth[b])</span><br><span class="line">            a = fa[a][k];</span><br><span class="line">    <span class="keyword">if</span>(a==b)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">15</span>; k &gt;= <span class="number">0</span>;k--)</span><br><span class="line">        <span class="keyword">if</span>(fa[a][k]!=fa[b][k])</span><br><span class="line">        &#123;</span><br><span class="line">            a = fa[a][k];</span><br><span class="line">            b = fa[b][k];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[a][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">int</span> root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="keyword">if</span>(b==<span class="number">-1</span>)</span><br><span class="line">            root = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            add(a, b);</span><br><span class="line">            add(b, a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    bfs(root);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="keyword">int</span> t = lca(a, b);</span><br><span class="line">        <span class="keyword">if</span>(t==a)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"1\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t==b)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"2\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>lca</tag>
      </tags>
  </entry>
  <entry>
    <title>雇佣收银员 acwing 393</title>
    <url>/2020/04/30/ac393/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/395/" target="_blank" rel="noopener">Acwing393</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>一家超市要每天24小时营业，为了满足营业需求，需要雇佣一大批收银员。</p>
<p>已知不同时间段需要的收银员数量不同，为了能够雇佣尽可能少的人员，从而减少成本，这家超市的经理请你来帮忙出谋划策。</p>
<p>经理为你提供了一个各个时间段收银员最小需求数量的清单R(0),R(1),R(2),…,R(23)。</p>
<p>R(0)表示午夜00:00到凌晨01:00的最小需求数量，R(1)表示凌晨01:00到凌晨02:00的最小需求数量，以此类推。</p>
<p>一共有N个合格的申请人申请岗位，第 i 个申请人可以从ti时刻开始连续工作8小时。</p>
<p>收银员之间不存在替换，一定会完整地工作8小时，收银台的数量一定足够。</p>
<p>现在给定你收银员的需求清单，请你计算最少需要雇佣多少名收银员。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含一个不超过20的整数，表示测试数据的组数。</p>
<p>对于每组测试数据，第一行包含24个整数，分别表示R(0),R(1),R(2),…,R(23)。</p>
<p>第二行包含整数N。</p>
<p>接下来N行，每行包含一个整数ti。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>每组数据输出一个结果，每个结果占一行。</p>
<p>如果没有满足需求的安排，输出“No Solution”。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>0≤R(0)≤1000,<br>0≤N≤1000,<br>0≤ti≤23</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">1 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1</span><br><span class="line">5</span><br><span class="line">0</span><br><span class="line">23</span><br><span class="line">22</span><br><span class="line">1</span><br><span class="line">10</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>

<h3 id="题意分析"><a href="#题意分析" class="headerlink" title="题意分析"></a>题意分析</h3><p>差分约束<br><code>dist[i</code>]表示前<code>i</code>小时选的总人数<br>建边:<br>1.<code>dist[i]-dist[i-8]&gt;=need[i]</code> (8≤i≤24)<br>2.<code>dist[i]+dist[24]-dist[i+16]&gt;=need[i]</code> (1≤i≤7)<br>3.<code>dist[i]&gt;=dist[i-1]</code><br>4.<code>dist[i-1]+num[i]&gt;=dist[i]</code><br>由于不等式<code>2</code>中有<code>3</code>个含有<code>dist</code>的量，无法建边，故这里采用枚举所有<code>dist[24]</code>的方法<br>设<code>dist[24]</code>为<code>c</code>，故增加了如下两条约束<br>5.<code>dist[24]-dist[0]&gt;=c</code><br>6.<code>dist[0]-dist[24]&lt;=-c</code><br>同时约束<code>2</code>改为<br><code>dist[i]+c-dist[i+16]&gt;=need[i]</code> (1≤i≤7)</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">30</span>, M = <span class="number">10</span> * N;</span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], w[M], idx;</span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"><span class="keyword">int</span> cnt[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="keyword">int</span> num[N];</span><br><span class="line"><span class="keyword">int</span> r[N];</span><br><span class="line"><span class="keyword">int</span> n, m1, m2;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    w[idx] = c;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span>(h));</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">    add(<span class="number">0</span>, <span class="number">24</span>, c);</span><br><span class="line">    add(<span class="number">24</span>, <span class="number">0</span>, -c);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">7</span>;i++)</span><br><span class="line">        add(i + <span class="number">16</span>, i, r[i] - c);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">8</span>; i &lt;= <span class="number">24</span>;i++)</span><br><span class="line">        add(i - <span class="number">8</span>, i, r[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">24</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        add(i, i - <span class="number">1</span>, -num[i]);</span><br><span class="line">        add(i - <span class="number">1</span>, i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    build(c);</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">-0x3f</span>, <span class="keyword">sizeof</span>(dist));</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span>(st));</span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//for (int i = 1; i &lt;= n;i++)</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//    q[tt++] = i;</span></span><br><span class="line">    <span class="comment">//    st[i] = true;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    dist[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    q[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    st[<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(hh!=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = q[--tt];</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[t]; ~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j]&lt;dist[t]+w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                cnt[j] = cnt[t] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(cnt[j]==<span class="number">25</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                    q[tt++] = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//memset(h, -1, sizeof(h));</span></span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="keyword">sizeof</span>(num));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">24</span>;i++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; r[i];</span><br><span class="line">        <span class="keyword">int</span> m;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">            num[t + <span class="number">1</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1000</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(spfa(i))</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"No Solution"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>差分约束</tag>
      </tags>
  </entry>
  <entry>
    <title>区间 acwing 362</title>
    <url>/2020/04/29/ac362/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/364/" target="_blank" rel="noopener">Acwing362</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定 n 个区间 [ai,bi]和 n 个整数 ci。</p>
<p>你需要构造一个整数集合 Z，使得∀i∈[1,n],Z 中满足ai≤x≤bi的整数 x 不少于 ci 个。</p>
<p>求这样的整数集合 Z 最少包含多少个数。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含整数 n。</p>
<p>接下来n行，每行包含三个整数ai,bi,ci。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个整数表示结果。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤n≤50000,<br>0≤ai,bi≤50000,<br>1≤ci≤bi−ai+1</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">3 7 3</span><br><span class="line">8 10 3</span><br><span class="line">6 8 1</span><br><span class="line">1 3 1</span><br><span class="line">10 11 1</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure>

<h3 id="题意分析"><a href="#题意分析" class="headerlink" title="题意分析"></a>题意分析</h3><p>差分约束<br><code>dist</code>维护前缀和，<code>dist[i]</code>表示<code>[1,i]</code>内包含的数的个数<br>建边:<br>1.<code>dist[i]&gt;=dist[i-1]</code><br>2.<code>dist[b]-dist[a-1]&gt;=c</code><br>3.<code>dist[i-1]+1&gt;=dist[i]</code></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">50010</span>, M = N * <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"><span class="keyword">int</span> h[N], e[M], w[M], ne[M], idx;</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    w[idx] = c;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">-0x3f</span>, <span class="keyword">sizeof</span>(dist));</span><br><span class="line">    dist[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">1</span>;</span><br><span class="line">    st[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    q[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(hh!=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = q[hh++];</span><br><span class="line">        <span class="keyword">if</span>(hh==N)</span><br><span class="line">            hh = <span class="number">0</span>;</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[t]; ~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j]&lt;dist[t]+w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                    q[tt++] = j;</span><br><span class="line">                    <span class="keyword">if</span>(tt==N)</span><br><span class="line">                        tt = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span>(h));</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        add(a, b + <span class="number">1</span>, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        add(i - <span class="number">1</span>, i, <span class="number">0</span>);</span><br><span class="line">        add(i, i - <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    spfa();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, dist[N - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>差分约束</tag>
      </tags>
  </entry>
  <entry>
    <title>糖果 acwing 1169</title>
    <url>/2020/04/28/ac1169/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/1171/" target="_blank" rel="noopener">Acwing1169</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>幼儿园里有 N 个小朋友，老师现在想要给这些小朋友们分配糖果，要求每个小朋友都要分到糖果。</p>
<p>但是小朋友们也有嫉妒心，总是会提出一些要求，比如小明不希望小红分到的糖果比他的多，于是在分配糖果的时候， 老师需要满足小朋友们的 K 个要求。</p>
<p>幼儿园的糖果总是有限的，老师想知道他至少需要准备多少个糖果，才能使得每个小朋友都能够分到糖果，并且满足小朋友们所有的要求。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入的第一行是两个整数 N,K。</p>
<p>接下来 K 行，表示分配糖果时需要满足的关系，每行 3 个数字 X,A,B。</p>
<p>如果 X=1．表示第 A 个小朋友分到的糖果必须和第 B 个小朋友分到的糖果一样多。<br>如果 X=2，表示第 A 个小朋友分到的糖果必须少于第 B 个小朋友分到的糖果。<br>如果 X=3，表示第 A 个小朋友分到的糖果必须不少于第 B 个小朋友分到的糖果。<br>如果 X=4，表示第 A 个小朋友分到的糖果必须多于第 B 个小朋友分到的糖果。<br>如果 X=5，表示第 A 个小朋友分到的糖果必须不多于第 B 个小朋友分到的糖果。<br>小朋友编号从 1 到 N。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一行，表示老师至少需要准备的糖果数，如果不能满足小朋友们的所有要求，就输出 −1。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤N&lt;1e5,<br>1≤K≤1e5,<br>1≤X≤5,<br>1≤A,B≤N</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 7</span><br><span class="line">1 1 2</span><br><span class="line">2 3 2</span><br><span class="line">4 4 1</span><br><span class="line">3 4 5</span><br><span class="line">5 4 5</span><br><span class="line">2 3 5</span><br><span class="line">4 5 1</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure>

<h3 id="题意分析"><a href="#题意分析" class="headerlink" title="题意分析"></a>题意分析</h3><p>差分约束<br>题目所求为最小值，所以边所代表的意义是<code>&gt;=</code><br>即<code>add(a,b,c)</code>代表<code>b&gt;=a+c</code></p>
<p>所以建边如下<br><code>X=1, add(a,b,0),add(b,a,0)</code><br><code>X=2, add(a,b,1)</code><br><code>X=3, add(b,a,0)</code><br><code>X=4, add(b,a,1)</code><br><code>X=5, add(a,b,0)</code></p>
<p>这样即可求出每个点可能的最小值，最后求和即可</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>, M = <span class="number">5</span> * N;</span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], w[M], idx;</span><br><span class="line">ll dist[N];</span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"><span class="keyword">int</span> cnt[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    w[idx] = c;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">-0x3f</span>, <span class="keyword">sizeof</span>(dist));</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span>(st));</span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dist[i] = <span class="number">1</span>;</span><br><span class="line">        q[tt++] = i;</span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(hh!=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = q[hh++];</span><br><span class="line">        <span class="keyword">if</span>(hh==N) </span><br><span class="line">        hh=<span class="number">0</span>;</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[t]; ~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j]&lt;dist[t]+w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                cnt[j] = cnt[t] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(++count&gt;<span class="number">2</span>*n)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(cnt[j]&gt;=n+<span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                    q[tt++] = j;</span><br><span class="line">                    <span class="keyword">if</span>(tt==N)</span><br><span class="line">                    tt=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="comment">//for (int i = 1; i &lt;= n;i++)</span></span><br><span class="line">    <span class="comment">//    add(0, i, 1);</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x, a, b;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            add(a, b, <span class="number">0</span>);</span><br><span class="line">            add(b, a, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">2</span>)</span><br><span class="line">            add(a, b, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">3</span>)</span><br><span class="line">            add(b, a, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">4</span>)</span><br><span class="line">            add(b, a, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            add(a, b, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!spfa())</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ll res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">            res += dist[i];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>差分约束</tag>
      </tags>
  </entry>
  <entry>
    <title>单词环 acwing 1165</title>
    <url>/2020/04/26/ac1165/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/1167/" target="_blank" rel="noopener">Acwing1165</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>我们有 n 个字符串，每个字符串都是由 a∼z 的小写英文字母组成的。</p>
<p>如果字符串 A 的结尾两个字符刚好与字符串 B 的开头两个字符相匹配，那么我们称 A 与 B 能够相连（注意：A 能与 B 相连不代表 B 能与 A 相连）。</p>
<p>我们希望从给定的字符串中找出一些，使得它们首尾相连形成一个环串（一个串首尾相连也算），我们想要使这个环串的平均长度最大。</p>
<p>如下例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ababc</span><br><span class="line">bckjaca</span><br><span class="line">caahoynaab</span><br></pre></td></tr></table></figure>
<p>第一个串能与第二个串相连，第二个串能与第三个串相连，第三个串能与第一个串相连，我们按照此顺序相连，便形成了一个环串，长度为 5+7+10=22（重复部分算两次），总共使用了 3 个串，所以平均长度是 22/3≈7.33。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>本题有多组数据。</p>
<p>每组数据的第一行，一个整数 n，表示字符串数量；</p>
<p>接下来 n 行，每行一个长度小于等于 1000 的字符串。</p>
<p>读入以 n=0 结束。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>若不存在环串，输出”No solution”，否则输出最长的环串的平均长度。</p>
<p>只要答案与标准答案的差不超过 0.01，就视为答案正确。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤n≤1e5</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">intercommunicational</span><br><span class="line">alkylbenzenesulfonate</span><br><span class="line">tetraiodophenolphthalein</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">21.66</span><br></pre></td></tr></table></figure>


<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>一、建图<br>1.若对于把一个字符串看成是一个点，能首尾相连看成是有一条边，那么此时最极端的情况是所有的点之间都有边，因为字符串一共有<code>1e5</code>个，那么最终的总变数将会达到<code>1e10</code>级别，显然不行<br>2.故这里改变了思路，将每个字符串的前两位和后两位视为点，字符串的长度为边权，此时因为英文字母一共有<code>26</code>个，所以点的总数为<code>676</code>个，边的总数为字符串的总数，为<code>1e5</code>个，最坏情况下共有<code>1e7</code>级别的边数，可以接受</p>
<p>二、问题的转化<br>我们假定当前二分枚举到的答案为<code>mid</code><br>若存在一个环使得<code>∑t/∑f&gt;mid</code>  (<code>f</code>为点权，即<code>1</code>)<br>即存在一个环使得<code>∑t-mid*∑f&gt;0</code><br>即边权为<code>∑t-mid*∑f</code>时存在正环<br>此时<code>res&gt;mid</code> ，否则<code>res&lt;=mid</code></p>
<p>无解的情况：若一张图中不存在环，此时也就是无解的情况，二分过程中若每次不存在正环，就会将<code>r</code>缩小一半，若一直是无解，那么最终<code>r</code>将会缩小至<code>0</code>，故只需判断一下<code>mid=0</code>时是否有正环即可</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">700</span>, M = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> h[N], e[M], w[M], ne[M], idx;</span><br><span class="line"><span class="keyword">double</span> dist[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"><span class="keyword">int</span> cnt[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">1010</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    w[idx] = c;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">double</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0</span>, <span class="keyword">sizeof</span>(dist));</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span>(st));</span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">676</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        q[tt++] = i;</span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(hh!=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = q[hh++];</span><br><span class="line">        <span class="keyword">if</span>(hh==N)</span><br><span class="line">            hh = <span class="number">0</span>;</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[t]; ~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j]&lt;dist[t]+w[i]-mid)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i] - mid;</span><br><span class="line">                cnt[j] = cnt[t] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(++count&gt;=<span class="number">3000</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(cnt[j]&gt;=N)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                    q[tt++] = j;</span><br><span class="line">                    <span class="keyword">if</span>(tt==N)</span><br><span class="line">                        tt = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n),n)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span>(h));</span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>, str);</span><br><span class="line">            <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">            <span class="keyword">int</span> l = (str[<span class="number">0</span>] - <span class="string">'a'</span>) * <span class="number">26</span> + (str[<span class="number">1</span>] - <span class="string">'a'</span>);</span><br><span class="line">            <span class="keyword">int</span> r = (str[len - <span class="number">2</span>] - <span class="string">'a'</span>) * <span class="number">26</span> + (str[len - <span class="number">1</span>] - <span class="string">'a'</span>);</span><br><span class="line">            add(l, r, len);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!spfa(<span class="number">0</span>))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"No solution\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">double</span> l = <span class="number">0</span>, r = <span class="number">1001</span>;</span><br><span class="line">            <span class="keyword">while</span>(r-l&gt;=<span class="number">1e-4</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(spfa(mid))</span><br><span class="line">                    l = mid;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    r = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%f\n"</span>, l);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>负环</tag>
        <tag>01分数规划</tag>
      </tags>
  </entry>
  <entry>
    <title>观光奶牛 acwing 361</title>
    <url>/2020/04/25/ac361/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/363/" target="_blank" rel="noopener">Acwing361</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定一张L个点、P条边的有向图，每个点都有一个权值f[i]，每条边都有一个权值t[i]。</p>
<p>求图中的一个环，使“环上各点的权值之和”除以“环上各边的权值之和”最大。</p>
<p>输出这个最大值。</p>
<p>注意：数据保证至少存在一个环。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含两个整数L和P。</p>
<p>接下来L行每行一个整数，表示f[i]。</p>
<p>再接下来P行，每行三个整数a，b，t[i]，表示点a和b之间存在一条边，边的权值为t[i]。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个数表示结果，保留两位小数。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>2≤L≤1000,<br>2≤P≤5000,<br>1≤f[i],t[i]≤1000</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 7</span><br><span class="line">30</span><br><span class="line">10</span><br><span class="line">10</span><br><span class="line">5</span><br><span class="line">10</span><br><span class="line">1 2 3</span><br><span class="line">2 3 2</span><br><span class="line">3 4 5</span><br><span class="line">3 5 2</span><br><span class="line">4 5 5</span><br><span class="line">5 1 3</span><br><span class="line">5 2 2</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6.00</span><br></pre></td></tr></table></figure>

<h3 id="题意分析"><a href="#题意分析" class="headerlink" title="题意分析"></a>题意分析</h3><p>给定一张图，求出图中的所有环中，环上的各点权值之和与各边权值之和的比值的最大值</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>设在某一个环中，每个点的点权分别为<code>f1,f2,f3...</code>,每条边的边权分别为<code>t1,t2,t3...</code>，<br>设当前枚举到的二分的值为<code>mid</code><br>如果存在一个环，使得<code>∑f/∑t&gt;mid</code>,<br>即存在一个环，使得<code>∑f-mid*∑t&gt;0</code><br>此时我们将图中所有的点的权值设为<code>0</code>，边的权值设为<code>f-mid*t</code>(<code>f</code>为边<code>t</code>的起点的原来的点权),则原条件转化为：存在一个正环。<br>又原条件：存在一个环，使得<code>∑f/∑t&gt;mid</code>,等价于真正的答案<code>res&gt;mid</code><br>故<code>l=mid</code>，反之，若对于该<code>mid</code>，原图中不存在正环，那么<code>res&lt;=mid</code>,故<code>r=mid</code></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>, M = <span class="number">5050</span>;</span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], wt[M], idx;</span><br><span class="line"><span class="keyword">double</span> dist[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="keyword">int</span> wf[N];</span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"><span class="keyword">int</span> cnt[N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    wt[idx] = c;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">double</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span>(st));</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0</span>, <span class="keyword">sizeof</span>(dist));</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        q[tt++] = i;</span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(hh!=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = q[hh++];</span><br><span class="line">        <span class="keyword">if</span>(hh==N)</span><br><span class="line">            hh = <span class="number">0</span>;</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[t]; ~i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j]&lt;dist[t]+wf[t]-mid*wt[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + wf[t] - mid * wt[i];</span><br><span class="line">                cnt[j] = cnt[t] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(cnt[j]&gt;=n)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                    q[tt++] = j;</span><br><span class="line">                    <span class="keyword">if</span>(tt==N)</span><br><span class="line">                        tt = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;wf[i]);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span>(h));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        add(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> l = <span class="number">0</span>, r = <span class="number">1001</span>;</span><br><span class="line">    <span class="keyword">while</span>(r-l&gt;=<span class="number">1e-4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(spfa(mid))</span><br><span class="line">            l = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.2f\n"</span>, l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>负环</tag>
        <tag>01分数规划</tag>
      </tags>
  </entry>
  <entry>
    <title>虫洞 acwing 904</title>
    <url>/2020/04/25/ac904/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/906/" target="_blank" rel="noopener">Acwing904</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>农夫约翰在巡视他的众多农场时，发现了很多令人惊叹的虫洞。</p>
<p>虫洞非常奇特，它可以看作是一条 单向 路径，通过它可以使你回到过去的某个时刻（相对于你进入虫洞之前）。</p>
<p>农夫约翰的每个农场中包含N片田地，M条路径（双向）以及W个虫洞。</p>
<p>现在农夫约翰希望能够从农场中的某片田地出发，经过一些路径和虫洞回到过去，并在他的出发时刻之前赶到他的出发地。</p>
<p>他希望能够看到出发之前的自己。</p>
<p>请你判断一下约翰能否做到这一点。</p>
<p>下面我们将给你提供约翰拥有的农场数量F，以及每个农场的完整信息。</p>
<p>已知走过任何一条路径所花费的时间都不超过10000秒，任何虫洞将他带回的时间都不会超过10000秒。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含整数F，表示约翰共有F个农场。</p>
<p>对于每个农场，第一行包含三个整数N，M，W。</p>
<p>接下来M行，每行包含三个整数S，E，T，表示田地S和E之间存在一条路径，经过这条路径所花的时间为T。</p>
<p>再接下来W行，每行包含三个整数S，E，T，表示存在一条从田地S走到田地E的虫洞，走过这条虫洞，可以回到T秒之间.</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出共F行，每行输出一个结果。</p>
<p>如果约翰能够在出发时刻之前回到出发地，则输出“YES”，否则输出“NO”。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤F≤5<br>1≤N≤500,<br>1≤M≤2500,<br>1≤W≤200,<br>1≤T≤10000,<br>1≤S,E≤N</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3 3 1</span><br><span class="line">1 2 2</span><br><span class="line">1 3 4</span><br><span class="line">2 3 1</span><br><span class="line">3 1 3</span><br><span class="line">3 2 1</span><br><span class="line">1 2 3</span><br><span class="line">2 3 4</span><br><span class="line">3 1 8</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NO</span><br><span class="line">YES</span><br></pre></td></tr></table></figure>

<h3 id="题意分析"><a href="#题意分析" class="headerlink" title="题意分析"></a>题意分析</h3><p>给定一张图，判断是否存在负环</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span>, M = <span class="number">5210</span>;</span><br><span class="line"><span class="keyword">int</span> n, m1, m2;</span><br><span class="line"><span class="keyword">int</span> h[N], e[M], w[M], ne[M], idx;</span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"><span class="keyword">int</span> q[N], cnt[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    w[idx] = c;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0</span>, <span class="keyword">sizeof</span>(dist));</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span>(st));</span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        q[tt++] = i;</span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(hh!=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = q[hh++];</span><br><span class="line">        <span class="keyword">if</span>(hh==N)</span><br><span class="line">            hh = <span class="number">0</span>;</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j]&gt;dist[t]+w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                cnt[j] = cnt[t] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(cnt[j] &gt;= n)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                    q[tt++] = j;</span><br><span class="line">                    <span class="keyword">if</span>(tt==N)</span><br><span class="line">                        tt = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span>(h));</span><br><span class="line">        idx=<span class="number">0</span>;<span class="comment">//容易忘记</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m1, &amp;m2);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m1;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a, b, c;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">            add(a, b, c);</span><br><span class="line">            add(b, a, c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m2;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a, b, c;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">            add(a, b, -c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(spfa())</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>负环</tag>
      </tags>
  </entry>
  <entry>
    <title>北极通讯网络 acwing 1145</title>
    <url>/2020/04/23/ac1145/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/1147/" target="_blank" rel="noopener">Acwing1145</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>北极的某区域共有 n 座村庄，每座村庄的坐标用一对整数 (x,y) 表示。</p>
<p>为了加强联系，决定在村庄之间建立通讯网络，使每两座村庄之间都可以直接或间接通讯。</p>
<p>通讯工具可以是无线电收发机，也可以是卫星设备。</p>
<p>无线电收发机有多种不同型号，不同型号的无线电收发机有一个不同的参数 d，两座村庄之间的距离如果不超过 d，就可以用该型号的无线电收发机直接通讯，d 值越大的型号价格越贵。现在要先选择某一种型号的无线电收发机，然后t统一给所有村庄配备，数量不限，但型号都是 相同的。</p>
<p>配备卫星设备的两座村庄无论相距多远都可以直接通讯，但卫星设备是 有限的，只能给一部分村庄配备。</p>
<p>现在有 k 台卫星设备，请你编一个程序，计算出应该如何分配这 k 台卫星设备，才能使所配备的无线电收发机的 d 值最小。</p>
<p>例如，对于下面三座村庄：</p>
<p><img src="/images/ac1145.png" alt="alt"></p>
<p>其中，|AB|=10,|BC|=20,|AC|=105√≈22.36。</p>
<p>如果没有任何卫星设备或只有 1 台卫星设备 (k=0 或 k=1)，则满足条件的最小的 d=20，因为 A 和 B，B 和 C 可以用无线电直接通讯；而 A 和 C 可以用 B 中转实现间接通讯 (即消息从 A 传到 B，再从 B 传到 C)；</p>
<p>如果有 2 台卫星设备 (k=2)，则可以把这两台设备分别分配给 B 和 C ，这样最小的 d 可取 10，因为 A 和 B 之间可以用无线电直接通讯；B 和 C 之间可以用卫星直接通讯；A 和 C 可以用 B 中转实现间接通讯。</p>
<p>如果有 3 台卫星设备，则 A,B,C 两两之间都可以直接用卫星通讯，最小的 d 可取 0。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行为由空格隔开的两个整数 n,k;</p>
<p>接下来 n 行，每行两个整数，第 i 行的 xi,yi 表示第 i 座村庄的坐标 (xi,yi)。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>一个实数，表示最小的 d 值，结果保留 2 位小数。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤n≤500,<br>0≤x,y≤1e4,<br>0≤k≤100</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 2</span><br><span class="line">10 10</span><br><span class="line">10 0</span><br><span class="line">30 0</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10.00</span><br></pre></td></tr></table></figure>

<h3 id="题意分析"><a href="#题意分析" class="headerlink" title="题意分析"></a>题意分析</h3><p>对于所有节点，若两节点之间有卫星设备，那么它们之间的距离为0，否则一点可以直接到达或经过中间点到达另一点<br>已知提供了k台卫星设备，求所有的路径中每段路径（两节点之间的距离）的最大值 的可能的最小值。（求最小生成树的最大边权的最小值）</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><code>kruskal</code>算法 ： <code>kruskal</code>算法每次取出的都是权值最小的边，我们使用<code>kruskal</code>算法从小到大枚举所有的边直到枚举了<code>n-k</code>条边。此时还有<code>k-1</code>条边没有加入，意味着此时还有<code>k</code>个孤立块(同属于一个并查集为一块)，每一块上设置一台卫星设备，刚好使用完<code>k</code>台。<br>因<code>kruskal</code>中边是按边权从小到大顺序枚举的，所以剩下的边的权值一定大于已经加入的所有边的权值，所以当前方案一定是最优解</p>
<h3 id="代码-kruskal"><a href="#代码-kruskal" class="headerlink" title="代码(kruskal)"></a>代码(kruskal)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">double</span>, <span class="keyword">double</span>&gt; pdd;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span>, M = N * N / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line">pdd s[N];</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">double</span> w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> edge &amp;t)<span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; t.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; e[M];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x]==x)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> p[x] = get(p[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getdist</span><span class="params">(pdd p1,pdd p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">        p[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s[i].x &gt;&gt; s[i].y;</span><br><span class="line">    <span class="keyword">int</span> tt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i;j++)</span><br><span class="line">            e[tt++] = &#123;j, i, getdist(s[i], s[j])&#125;;</span><br><span class="line">    sort(e, e + tt);</span><br><span class="line">    <span class="keyword">int</span> cnt = n;</span><br><span class="line">    <span class="keyword">double</span> res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tt;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt&lt;=k)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">int</span> a = get(e[i].a);</span><br><span class="line">        <span class="keyword">int</span> b = get(e[i].b);</span><br><span class="line">        <span class="keyword">double</span> w = e[i].w;</span><br><span class="line">        <span class="keyword">if</span>(a!=b)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt--;</span><br><span class="line">            p[a] = b;</span><br><span class="line">            res = w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.2f\n"</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>新的开始 acwing 1146</title>
    <url>/2020/04/23/ac1146/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/1148/" target="_blank" rel="noopener">Acwing1146</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>发展采矿业当然首先得有矿井，小 FF 花了上次探险获得的千分之一的财富请人在岛上挖了 n 口矿井，但他似乎忘记了考虑矿井供电问题。</p>
<p>为了保证电力的供应，小 FF 想到了两种办法：</p>
<p>在矿井 i 上建立一个发电站，费用为 vi（发电站的输出功率可以供给任意多个矿井）。<br>将这口矿井 i 与另外的已经有电力供应的矿井 j 之间建立电网，费用为 pi,j。<br>小 FF 希望你帮他想出一个保证所有矿井电力供应的最小花费方案。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含一个整数 n，表示矿井总数。</p>
<p>接下来 n 行，每行一个整数，第 i 个数 vi 表示在第 i 口矿井上建立发电站的费用。</p>
<p>接下来为一个 n×n 的矩阵 P，其中 pi,j 表示在第 i 口矿井和第 j 口矿井之间建立电网的费用。</p>
<p>数据保证 pi,j=pj,i，且 pi,i=0。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个整数，表示让所有矿井获得充足电能的最小花费。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤n≤300,<br>0≤vi,pi,j≤1e5</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">5</span><br><span class="line">4</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">0 2 2 2</span><br><span class="line">2 0 3 3</span><br><span class="line">2 3 0 4</span><br><span class="line">2 3 4 0</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure>

<h3 id="题意分析"><a href="#题意分析" class="headerlink" title="题意分析"></a>题意分析</h3><p>对于每个节点，可以选择在这个节点上建发电站或与其他发电站相连的方式通电，问使所有节点通电的最小花费</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>设一个<code>0</code>号节点为发电总站，将所有建站的操作视为与<code>0</code>号站相连，原题转化为<code>n+1</code>个节点的最小生成树</p>
<h3 id="代码-prim"><a href="#代码-prim" class="headerlink" title="代码(prim)"></a>代码(prim)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">310</span>;</span><br><span class="line"><span class="keyword">int</span> w[N][N];</span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"><span class="keyword">int</span> n, res;</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dist));</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span>(st));</span><br><span class="line">    dist[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n ;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n;j++)</span><br><span class="line">            <span class="keyword">if</span>(!st[j]&amp;&amp;(t==<span class="number">-1</span>||dist[t]&gt;dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">        res += dist[t];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n;j++)</span><br><span class="line">            dist[j] = min(dist[j], w[t][j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; w[<span class="number">0</span>][i];</span><br><span class="line">        w[i][<span class="number">0</span>] = w[<span class="number">0</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n;j++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; w[i][j];</span><br><span class="line">    prim();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>局域网 acwing 1141</title>
    <url>/2020/04/22/ac1141/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/1143/" target="_blank" rel="noopener">Acwing1141</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>某个局域网内有 n 台计算机和 k 条 双向 网线，计算机的编号是 1∼n。由于搭建局域网时工作人员的疏忽，现在局域网内的连接形成了回路，我们知道如果局域网形成回路那么数据将不停的在回路内传输，造成网络卡的现象。</p>
<p>注意：</p>
<p>对于某一个连接，虽然它是双向的，但我们不将其当做回路。本题中所描述的回路至少要包含两条不同的连接。<br>两台计算机之间最多只会存在一条连接。<br>不存在一条连接，它所连接的两端是同一台计算机。<br>因为连接计算机的网线本身不同，所以有一些连线不是很畅通，我们用 f(i,j) 表示 i,j 之间连接的畅通程度，f(i,j) 值越小表示 i,j 之间连接越通畅。</p>
<p>现在我们需要解决回路问题，我们将除去一些连线，使得网络中没有回路且不影响连通性（即如果之前某两个点是连通的，去完之后也必须是连通的），并且被除去网线的 Σf(i,j) 最大，请求出这个最大值。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行两个正整数 n,k。</p>
<p>接下来的 k 行每行三个正整数 i,j,m 表示 i,j 两台计算机之间有网线联通，通畅程度为 m。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>一个正整数，表示被除去网线的 Σf(i,j) 的最大值。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤n≤100<br>0≤k≤200<br>1≤f(i,j)≤1000</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 5</span><br><span class="line">1 2 8</span><br><span class="line">1 3 1</span><br><span class="line">1 5 3</span><br><span class="line">2 4 5</span><br><span class="line">3 4 2</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure>

<h3 id="题意分析"><a href="#题意分析" class="headerlink" title="题意分析"></a>题意分析</h3><p>最小生成树</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>卡鲁斯卡尔算法，每次取出边权最小的边，判断是否两端点是否在同一集合，若在同一集合，说明两点已经连通，当前边为无用边，需要删除</p>
<h3 id="代码-kruskal"><a href="#代码-kruskal" class="headerlink" title="代码(kruskal)"></a>代码(kruskal)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>, M = <span class="number">210</span>;</span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"><span class="keyword">int</span> n, m, res;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b, w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> edge &amp;t)<span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; t.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e[M];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x]==x)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> p[x] = get(p[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">        p[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, w;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; w;</span><br><span class="line">        e[i] = &#123;a, b, w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(e, e + m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a = get(e[i].a);</span><br><span class="line">        <span class="keyword">int</span> b = get(e[i].b);</span><br><span class="line">        <span class="keyword">int</span> w = e[i].w;</span><br><span class="line">        <span class="keyword">if</span>(a!=b)</span><br><span class="line">            p[a] = b;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            res += w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>繁忙的都市 acwing 1142</title>
    <url>/2020/04/22/ac1142/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/1144/" target="_blank" rel="noopener">Acwing1142</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>城市C是一个非常繁忙的大都市，城市中的道路十分的拥挤，于是市长决定对其中的道路进行改造。</p>
<p>城市C的道路是这样分布的：</p>
<p>城市中有 n 个交叉路口，编号是 1∼n，有些交叉路口之间有道路相连，两个交叉路口之间最多有一条道路相连接。</p>
<p>这些道路是 双向 的，且把所有的交叉路口直接或间接的连接起来了。</p>
<p>每条道路都有一个分值，分值越小表示这个道路越繁忙，越需要进行改造。</p>
<p>但是市政府的资金有限，市长希望进行改造的道路越少越好，于是他提出下面的要求：</p>
<p>1．改造的那些道路能够把所有的交叉路口直接或间接的连通起来。</p>
<p>2．在满足要求1的情况下，改造的道路尽量少。</p>
<p>3．在满足要求1、2的情况下，改造的那些道路中分值最大值尽量小。</p>
<p>作为市规划局的你，应当作出最佳的决策，选择那些道路应当被修建。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行有两个整数 n,m 表示城市有 n 个交叉路口，m 条道路。</p>
<p>接下来 m 行是对每条道路的描述，每行包含三个整数u,v,c 表示交叉路口 u 和 v 之间有道路相连，分值为 c。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>两个整数 s,max，表示你选出了几条道路，分值最大的那条道路的分值是多少。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤n≤300,<br>1≤m≤8000,<br>1≤c≤10000</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 5</span><br><span class="line">1 2 3</span><br><span class="line">1 4 5</span><br><span class="line">2 4 7</span><br><span class="line">2 3 6</span><br><span class="line">3 4 8</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 6</span><br></pre></td></tr></table></figure>

<h3 id="题意分析"><a href="#题意分析" class="headerlink" title="题意分析"></a>题意分析</h3><p>最小生成树</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>第一问要求告诉我们求的是一颗最小生成树，第三问要求最小生成树中的最大边权。最小生成树边数一定为 <code>n-1</code></p>
<h3 id="代码-kruskal"><a href="#代码-kruskal" class="headerlink" title="代码(kruskal)"></a>代码(kruskal)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">310</span>, M = <span class="number">8100</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b, w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> edge &amp;t)<span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; t.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e[M];</span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"><span class="keyword">int</span> n, m, s, maxs;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==p[x])</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> p[x] = get(p[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">        p[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, w;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; w;</span><br><span class="line">        e[i] = &#123;a, b, w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(e, e + m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a = get(e[i].a);</span><br><span class="line">        <span class="keyword">int</span> b = get(e[i].b);</span><br><span class="line">        <span class="keyword">int</span> w = e[i].w;</span><br><span class="line">        <span class="keyword">if</span>(a!=b)</span><br><span class="line">        &#123;</span><br><span class="line">            p[a]=b;</span><br><span class="line">            maxs=max(maxs,w);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; n - <span class="number">1</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; maxs &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>牛的旅行 acwing 1125</title>
    <url>/2020/04/21/ac1125/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/1127/" target="_blank" rel="noopener">Acwing1125</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>农民John的农场里有很多牧区，有的路径连接一些特定的牧区。</p>
<p>一片所有连通的牧区称为一个牧场。</p>
<p>但是就目前而言，你能看到至少有两个牧区不连通。</p>
<p>现在，John想在农场里添加一条路径（注意，恰好一条）。</p>
<p>一个牧场的直径就是牧场中最远的两个牧区的距离（本题中所提到的所有距离指的都是最短的距离）。</p>
<p>考虑如下的两个牧场，每一个牧区都有自己的坐标：</p>
<p><img src="/images/ac1125.png" alt="alt"></p>
<p>图 1 是有 5 个牧区的牧场，牧区用“*”表示，路径用直线表示。</p>
<p>图 1 所示的牧场的直径大约是 12.07106, 最远的两个牧区是 A 和 E，它们之间的最短路径是 A-B-E。</p>
<p>图 2 是另一个牧场。</p>
<p>这两个牧场都在John的农场上。</p>
<p>John将会在两个牧场中各选一个牧区，然后用一条路径连起来，使得连通后这个新的更大的牧场有最小的直径。</p>
<p>注意，如果两条路径中途相交，我们不认为它们是连通的。</p>
<p>只有两条路径在同一个牧区相交，我们才认为它们是连通的。</p>
<p>现在请你编程找出一条连接两个不同牧场的路径，使得连上这条路径后，这个更大的新牧场有最小的直径。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第 1 行：一个整数 N, 表示牧区数；</p>
<p>第 2 到 N+1 行：每行两个整数 X,Y， 表示 N 个牧区的坐标。每个牧区的坐标都是不一样的。</p>
<p>第 N+2 行到第 2*N+1 行：每行包括 N 个数字 ( 0或1 ) 表示一个对称邻接矩阵。</p>
<p>例如，题目描述中的两个牧场的矩阵描述如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  A B C D E F G H </span><br><span class="line">A 0 1 0 0 0 0 0 0 </span><br><span class="line">B 1 0 1 1 1 0 0 0 </span><br><span class="line">C 0 1 0 0 1 0 0 0 </span><br><span class="line">D 0 1 0 0 1 0 0 0 </span><br><span class="line">E 0 1 1 1 0 0 0 0 </span><br><span class="line">F 0 0 0 0 0 0 1 0 </span><br><span class="line">G 0 0 0 0 0 1 0 1 </span><br><span class="line">H 0 0 0 0 0 0 1 0</span><br></pre></td></tr></table></figure>
<p>输入数据中至少包括两个不连通的牧区。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>只有一行，包括一个实数，表示所求答案。</p>
<p>数字保留六位小数。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤N≤150,<br>0≤X,Y≤1e5</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">10 10</span><br><span class="line">15 10</span><br><span class="line">20 10</span><br><span class="line">15 15</span><br><span class="line">20 15</span><br><span class="line">30 15</span><br><span class="line">25 10</span><br><span class="line">30 10</span><br><span class="line">01000000</span><br><span class="line">10111000</span><br><span class="line">01001000</span><br><span class="line">01001000</span><br><span class="line">01110000</span><br><span class="line">00000010</span><br><span class="line">00000101</span><br><span class="line">00000010</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">22.071068</span><br></pre></td></tr></table></figure>

<h3 id="题意分析"><a href="#题意分析" class="headerlink" title="题意分析"></a>题意分析</h3><p>给定两个连通图，并允许在两个图中各取一点，在它们之间连一条边</p>
<p>求连边后得到的新连通图任意两点的最远距离</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先求出第一张图中每一点到其他第一张图中的点的最远距离，找出最大值<code>m1</code><br>再求出第二张图中每一点到其他第二张图中的点的最远距离，找出最大值<code>m2</code></p>
<p>之后枚举所有可能添加的边，设添加的边为图一中的<code>a</code>点和图二中的<code>b</code>点相连所得到，那么连此边后得到的两图间的最大距离为<code>a</code>在图一内部的最大距离加<code>b</code>在图二内部的最大距离加<code>ab</code>间距离，找出最小值<code>m3</code></p>
<p><code>res=max(m1,m2,m3)</code></p>
<h3 id="代码-Floyd"><a href="#代码-Floyd" class="headerlink" title="代码(Floyd)"></a>代码(Floyd)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">155</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> INF = <span class="number">1e20</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">double</span>,<span class="keyword">double</span>&gt;PDD;</span><br><span class="line"><span class="keyword">char</span> g[N][N];</span><br><span class="line"><span class="keyword">double</span> d[N][N];</span><br><span class="line"><span class="keyword">double</span> maxd[N];</span><br><span class="line">PDD p[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getdist</span><span class="params">(PDD a,PDD b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dx = a.x - b.x;</span><br><span class="line">    <span class="keyword">int</span> dy = a.y - b.y;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(dx * dx + dy * dy);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; p[i].x &gt;&gt; p[i].y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; g[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n;j++)</span><br><span class="line">            <span class="keyword">if</span>(i==j)</span><br><span class="line">                d[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(g[i][j]==<span class="string">'1'</span>)</span><br><span class="line">                d[i][j] = getdist(p[i], p[j]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                d[i][j] = INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n;k++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n;j++)</span><br><span class="line">                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line">    <span class="keyword">double</span> r1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n;j++)</span><br><span class="line">            <span class="keyword">if</span>(d[i][j]&lt;INF/<span class="number">2</span>)</span><br><span class="line">                maxd[i] = max(maxd[i], d[i][j]);</span><br><span class="line">        r1 = max(r1, maxd[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> r2 = INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n;j++)</span><br><span class="line">            <span class="keyword">if</span>(d[i][j]&gt;INF/<span class="number">2</span>)</span><br><span class="line">                r2 = min(r2, maxd[i] + maxd[j] + getdist(p[i], p[j]));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.6f\n"</span>, max(r2, r1));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>单源最短路</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>最短网络 acwing 1140</title>
    <url>/2020/04/21/ac1140/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/1142/" target="_blank" rel="noopener">Acwing1140</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>农夫约翰被选为他们镇的镇长！</p>
<p>他其中一个竞选承诺就是在镇上建立起互联网，并连接到所有的农场。</p>
<p>约翰已经给他的农场安排了一条高速的网络线路，他想把这条线路共享给其他农场。</p>
<p>约翰的农场的编号是1，其他农场的编号是 2∼n。</p>
<p>为了使花费最少，他希望用于连接所有的农场的光纤总长度尽可能短。</p>
<p>你将得到一份各农场之间连接距离的列表，你必须找出能连接所有农场并使所用光纤最短的方案。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含一个整数 n，表示农场个数。</p>
<p>接下来 n 行，每行包含 n 个整数，输入一个对角线上全是0的对称矩阵。<br>其中第 x+1 行 y 列的整数表示连接农场 x 和农场 y 所需要的光纤长度。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个整数，表示所需的最小光纤长度。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>3≤n≤100<br>每两个农场间的距离均是非负整数且不超过100000。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">0  4  9  21</span><br><span class="line">4  0  8  17</span><br><span class="line">9  8  0  16</span><br><span class="line">21 17 16  0</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">28</span><br></pre></td></tr></table></figure>

<h3 id="题意分析"><a href="#题意分析" class="headerlink" title="题意分析"></a>题意分析</h3><p>裸最小生成树</p>
<h3 id="代码-prim"><a href="#代码-prim" class="headerlink" title="代码(prim)"></a>代码(prim)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> w[N][N];</span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="keyword">int</span> n, res;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dist));</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span>(st));</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n;j++)</span><br><span class="line">            <span class="keyword">if</span>(!st[j]&amp;&amp;(t==<span class="number">-1</span>||dist[t]&gt;dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">        res += dist[t];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n;j++)</span><br><span class="line">            dist[j] = min(dist[j], w[t][j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n;j++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; w[i][j];</span><br><span class="line">    prim();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>观光之旅 acwing 344</title>
    <url>/2020/04/21/ac344/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/1144/" target="_blank" rel="noopener">Acwing1142</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定一张无向图，求图中一个至少包含3个点的环，环上的节点不重复，并且环上的边的长度之和最小。</p>
<p>该问题称为无向图的最小环问题。</p>
<p>你需要输出最小环的方案，若最小环不唯一，输出任意一个均可。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含两个整数N和M，表示无向图有N个点，M条边。</p>
<p>接下来M行，每行包含三个整数u，v，l，表示点u和点v之间有一条边，边长为l。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出占一行，包含最小环的所有节点（按顺序输出），如果不存在则输出’No solution.’。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤N≤100,<br>1≤M≤10000,<br>1≤l&lt;500</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 7</span><br><span class="line">1 4 1</span><br><span class="line">1 3 300</span><br><span class="line">3 1 10</span><br><span class="line">1 2 16</span><br><span class="line">2 3 100</span><br><span class="line">2 5 15</span><br><span class="line">5 3 20</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 3 5 2</span><br></pre></td></tr></table></figure>

<h3 id="题意分析"><a href="#题意分析" class="headerlink" title="题意分析"></a>题意分析</h3><p>给定一张无向图，求图中一个至少包含3个点的环，环上的节点不重复，并且环上的边的长度之和最小。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>设环的形式为  <code>i&lt;-&gt;k&lt;-&gt;j</code> , <code>i&lt;-&gt;j</code><br><code>Floyd</code>是典型的差点算法，每次插入点<code>k</code>，在<code>k</code>被插入之前所计算的环<code>i-j-k</code><br>的中间节点为 <code>1~k-1</code> ，此时<code>k</code>为环中最大节点<br>我们只需枚举所有以<code>k</code>为环中最大节点的环即可</p>
<p><code>pos[i][j]</code> : <code>i~j</code>的路径中经过的点是点<code>k</code>（即由这个状态转移过来）且这个<code>k</code>是路径中除了i和j以外编号最大的点<br>根据<code>Floyd</code>的实质决定<br>这条路存在以下两条性质<br>1 <code>i~j</code>中一定没有环<br>2 <code>i~j</code>中经过点<code>k</code>，且<code>i~k</code>和<code>k~j</code>之间没有交集</p>
<p>反证法证明，如果<code>i~j</code>中存在交点<code>k2</code>，那么存在路径<code>i-k2-k</code> ， <code>j-k2-k</code><br>显然以<code>k2</code>为交点所得得到路径和一定更小，而<code>pos[i][j]</code>中已知<code>i~j</code>的最短路经过的点是<code>k</code>（由<code>k</code>状态转移过来），故矛盾，所以<code>i~k</code>和<code>k~j</code>之间一定没有交集</p>
<p>对于<code>pos[i][j]=0</code>,说明<code>i~j</code>的最短路中没有经过其他的点</p>
<p>最短路的道路用性质2求解</p>
<p>先加入<code>k</code>，再加入<code>i</code>，再搜索<code>i~j</code>之间经过的点，再加入<code>j</code></p>
<h3 id="代码-Floyd"><a href="#代码-Floyd" class="headerlink" title="代码(Floyd)"></a>代码(Floyd)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> d[N][N], g[N][N];</span><br><span class="line"><span class="keyword">int</span> pos[N][N];</span><br><span class="line"><span class="keyword">int</span> path[N], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_path</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pos[i][j] == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = pos[i][j];</span><br><span class="line">    <span class="comment">//先搜索i~k,再加入k,再搜索k~j</span></span><br><span class="line">    <span class="comment">//思想类似于树的中序遍历</span></span><br><span class="line">    get_path(i, k);</span><br><span class="line">    path[cnt ++ ] = k;</span><br><span class="line">    get_path(k, j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) g[i][i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        g[a][b] = g[b][a] = min(g[a][b], c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = INF;</span><br><span class="line">    <span class="built_in">memcpy</span>(d, g, <span class="keyword">sizeof</span> d);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">                <span class="keyword">if</span> (d[i][j] &gt; d[i][k] + d[k][j])</span><br><span class="line">                &#123;</span><br><span class="line">                    d[i][j] = d[i][k] + d[k][j];</span><br><span class="line">                    pos[i][j] = k;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; k; j ++ )</span><br><span class="line">                <span class="keyword">if</span> ((<span class="keyword">long</span> <span class="keyword">long</span>)d[i][j] + g[j][k] + g[k][i] &lt; res)</span><br><span class="line">                &#123;</span><br><span class="line">                    res = d[i][j] + g[j][k] + g[k][i];</span><br><span class="line">                    cnt = <span class="number">0</span>;</span><br><span class="line">                    path[cnt ++ ] = k;</span><br><span class="line">                    path[cnt ++ ] = i;</span><br><span class="line">                    get_path(i, j);</span><br><span class="line">                    path[cnt ++ ] = j;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res == INF) <span class="built_in">puts</span>(<span class="string">"No solution."</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i ++ ) <span class="built_in">cout</span> &lt;&lt; path[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>单源最短路</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>新年好 acwing 1135</title>
    <url>/2020/04/20/ac1135/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/1137/" target="_blank" rel="noopener">Acwing1135</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>重庆城里有 n 个车站，m 条 双向 公路连接其中的某些车站。</p>
<p>每两个车站最多用一条公路连接，从任何一个车站出发都可以经过一条或者多条公路到达其他车站，但不同的路径需要花费的时间可能不同。</p>
<p>在一条路径上花费的时间等于路径上所有公路需要的时间之和。</p>
<p>佳佳的家在车站 1，他有五个亲戚，分别住在车站 a,b,c,d,e。</p>
<p>过年了，他需要从自己的家出发，拜访每个亲戚（顺序任意），给他们送去节日的祝福。</p>
<p>怎样走，才需要最少的时间？</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行：包含两个整数 n,m，分别表示车站数目和公路数目。</p>
<p>第二行：包含五个整数 a,b,c,d,e，分别表示五个亲戚所在车站编号。</p>
<p>以下 m 行，每行三个整数 x,y,t，表示公路连接的两个车站编号和时间。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出仅一行，包含一个整数 T，表示最少的总时间。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤n≤50000,<br>1≤m≤105,<br>1&lt; a,b,c,d,e≤n,<br>1≤x,y≤n,<br>1≤t≤100</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6 6</span><br><span class="line">2 3 4 5 6</span><br><span class="line">1 2 8</span><br><span class="line">2 3 3</span><br><span class="line">3 4 4</span><br><span class="line">4 5 5</span><br><span class="line">5 6 2</span><br><span class="line">1 6 7</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">21</span><br></pre></td></tr></table></figure>

<h3 id="题意分析"><a href="#题意分析" class="headerlink" title="题意分析"></a>题意分析</h3><p>求使得图中五个点连通的路径和的最小值</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先求出五个起点到其他所有点的单元最短路径<br>再<code>dfs</code>枚举所有的排列，通过查表的方式求和，更新最小值</p>
<p>题中最后一个数据卡掉了<code>spfa</code>，故本题只能用<code>heap</code>优化的<code>dijkstra</code></p>
<h3 id="代码-heap优化dijkstra"><a href="#代码-heap优化dijkstra" class="headerlink" title="代码(heap优化dijkstra)"></a>代码(heap优化dijkstra)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">50010</span>, M = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">bool</span> sst[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">int</span> res;</span><br><span class="line"><span class="keyword">int</span> dist[<span class="number">10</span>][N];</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="keyword">int</span> h[N], ne[M*<span class="number">2</span>], w[M*<span class="number">2</span>], e[M*<span class="number">2</span>], idx;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    w[idx] = c;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist[i], <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dist[i]));</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span>(st));</span><br><span class="line">    dist[i][num[i]] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;PII,<span class="built_in">vector</span>&lt;PII&gt;,greater&lt;PII&gt;&gt; q;</span><br><span class="line">    q.push(&#123;<span class="number">0</span>,num[i]&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        PII t = q.top();</span><br><span class="line">        <span class="keyword">int</span> ver = t.second;</span><br><span class="line">        <span class="keyword">int</span> dis = t.first;</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span>(st[ver])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = h[ver]; ~j; j = ne[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> k = e[j];</span><br><span class="line">            <span class="keyword">if</span>(dist[i][k]&gt;dist[i][ver]+w[j])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[i][k] = dist[i][ver] + w[j];</span><br><span class="line">                q.push(&#123;dist[i][k],k&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tt = <span class="number">0</span>;</span><br><span class="line">        tt += dist[<span class="number">0</span>][num[a[<span class="number">0</span>]]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">3</span>; j++)</span><br><span class="line">            tt+=dist[a[j]][num[a[j+<span class="number">1</span>]]];        </span><br><span class="line">        res = min(res, tt);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!sst[i])</span><br><span class="line">        &#123;</span><br><span class="line">            sst[i] = <span class="literal">true</span>;</span><br><span class="line">            a[n] = i;</span><br><span class="line">            dfs(n+<span class="number">1</span>);</span><br><span class="line">            a[n] = <span class="number">0</span>;</span><br><span class="line">            sst[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    res = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; "res = " &lt;&lt; res &lt;&lt; endl;</span></span><br><span class="line">    num[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; num[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        add(a, b, c);</span><br><span class="line">        add(b, a, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">5</span>; i++)</span><br><span class="line">        dijkstra(i);</span><br><span class="line">    dfs(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>单源最短路</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>通信线路 acwing 340</title>
    <url>/2020/04/20/ac340/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/342/" target="_blank" rel="noopener">Acwing340</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>在郊区有 N 座通信基站，P 条 双向 电缆，第 i 条电缆连接基站Ai和Bi。</p>
<p>特别地，1 号基站是通信公司的总站，N 号基站位于一座农场中。</p>
<p>现在，农场主希望对通信线路进行升级，其中升级第 i 条电缆需要花费Li。</p>
<p>电话公司正在举行优惠活动。</p>
<p>农产主可以指定一条从 1 号基站到 N 号基站的路径，并指定路径上不超过 K 条电缆，由电话公司免费提供升级服务。</p>
<p>农场主只需要支付在该路径上剩余的电缆中，升级价格最贵的那条电缆的花费即可。</p>
<p>求至少用多少钱可以完成升级。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第1行：三个整数N，P，K。</p>
<p>第2..P+1行：第 i+1 行包含三个整数Ai,Bi,Li。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>包含一个整数表示最少花费。</p>
<p>若1号基站与N号基站之间不存在路径，则输出”-1”。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>0≤K&lt;N≤1000,<br>1≤P≤10000,<br>1≤Li≤1000000</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 7 1</span><br><span class="line">1 2 5</span><br><span class="line">3 1 4</span><br><span class="line">2 4 8</span><br><span class="line">3 2 3</span><br><span class="line">5 2 9</span><br><span class="line">3 4 7</span><br><span class="line">4 5 6</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>

<h3 id="题意分析"><a href="#题意分析" class="headerlink" title="题意分析"></a>题意分析</h3><p>求从1到N的所有路径中 第k+1大的边最小的那条路径的第k+1大的边的权值</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>枚举所有可能的答案，因为边的权值的范围为<code>[1,1000000]</code>，所以答案的可能值在该区间中。<br>二分：对于任意的 <code>1≤t≤1000000</code> , 我们设权值大于<code>t</code>的边的权值为<code>1</code>，权值小于<code>t</code>的边的权值为<code>0</code>，并通过双端队列，将边权为<code>0</code>的边放在队头，边权为<code>1</code>的边放在队尾(因为只用考虑第<code>k+1</code>大的边，所以比第比它小的边的权值可以忽略不计)，对于给定的<code>t</code>，求出的<code>dist[n]</code>的值如果小于或等于<code>k</code>，说明路径中比<code>t</code>大的元素个数小于等于<code>k</code>，则此时免费的边数还不足<code>k</code>或等于<code>k</code>，显然还可以减免用的不够充分，所以最终答案<code>res&lt;=t</code><br>,故将<code>r</code>的值更新为<code>mid</code>，反之，若<code>dist[n]</code>的值大于<code>k</code>，说明假设的减免的边数超过了<code>k</code>个，则小于等于当前答案的部分不符合要求，将<code>l</code>的值更新为<code>mid+1</code></p>
<p>本题二分时将枚举范围改为<code>[0,1000001]</code>，<code>0</code>表明所有的边的花费都可以减免，<code>1000001</code>用于区分<code>1000000</code>，因为若<code>1</code>与<code>n</code>之间不存在路径，最终也会二分缩小到<code>100000</code>这个值，无法确定<code>1000000</code>是否为最终答案，但<code>1000001</code>的加入保证了若<code>1</code>与<code>n</code>之间不存在路径，最终答案会落入<code>1000001</code></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>, M = <span class="number">20010</span>;</span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="keyword">int</span> h[N], ne[M], e[M], w[M], idx;</span><br><span class="line"><span class="keyword">int</span> n, p, k;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    w[idx] = c;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> bound)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dist));</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span>(st));</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push_back(<span class="number">1</span>);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = q.front();</span><br><span class="line">        q.pop_front();</span><br><span class="line">        <span class="keyword">if</span>(st[t])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">int</span> x = w[i] &gt; bound;</span><br><span class="line">            <span class="keyword">if</span>(dist[j]&gt;dist[t]+x)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + x;</span><br><span class="line">                <span class="keyword">if</span>(!x)</span><br><span class="line">                    q.push_front(j);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    q.push_back(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist[n] &lt;= k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; p &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        add(a, b, c);</span><br><span class="line">        add(b, a, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">1e6</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(check(mid))</span><br><span class="line">            r = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(r==<span class="number">1e6</span>+<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"-1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; r &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>单源最短路</tag>
        <tag>图论</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>热浪 acwing 1129</title>
    <url>/2020/04/19/ac1129/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/1131/" target="_blank" rel="noopener">Acwing1129</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>德克萨斯纯朴的民众们这个夏天正在遭受巨大的热浪！！！</p>
<p>他们的德克萨斯长角牛吃起来不错，可是它们并不是很擅长生产富含奶油的乳制品。</p>
<p>农夫John此时身先士卒地承担起向德克萨斯运送大量的营养冰凉的牛奶的重任，以减轻德克萨斯人忍受酷暑的痛苦。</p>
<p>John已经研究过可以把牛奶从威斯康星运送到德克萨斯州的路线。</p>
<p>这些路线包括起始点和终点一共有 T 个城镇，为了方便标号为 1 到 T。</p>
<p>除了起点和终点外的每个城镇都由 双向道路 连向至少两个其它的城镇。</p>
<p>每条道路有一个通过费用（包括油费，过路费等等）。</p>
<p>给定一个地图，包含 C 条直接连接 2 个城镇的道路。</p>
<p>每条道路由道路的起点 Rs，终点 Re 和花费 Ci 组成。</p>
<p>求从起始的城镇 Ts 到终点的城镇 Te 最小的总费用。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行: 4 个由空格隔开的整数: T,C,Ts,Te;</p>
<p>第 2 到第 C+1 行: 第 i+1 行描述第 i 条道路，包含 3 个由空格隔开的整数: Rs,Re,Ci。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>一个单独的整数表示从 Ts 到 Te 的最小总费用。</p>
<p>数据保证至少存在一条道路。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤T≤2500,<br>1≤C≤6200,<br>1≤Ts,Te,Rs,Re≤T,<br>1≤Ci≤1000</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7 11 5 4</span><br><span class="line">2 4 2</span><br><span class="line">1 4 3</span><br><span class="line">7 2 2</span><br><span class="line">3 4 3</span><br><span class="line">5 7 5</span><br><span class="line">7 3 3</span><br><span class="line">6 1 1</span><br><span class="line">6 3 4</span><br><span class="line">2 4 3</span><br><span class="line">5 6 3</span><br><span class="line">7 2 1</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure>

<h3 id="题意分析"><a href="#题意分析" class="headerlink" title="题意分析"></a>题意分析</h3><p>单源最短路模板题<br><code>dijkstra</code> 、 <code>spfa</code> 皆可</p>
<h3 id="代码-spfa"><a href="#代码-spfa" class="headerlink" title="代码(spfa)"></a>代码(spfa)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2510</span>, M = <span class="number">6200</span> * <span class="number">2</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> h[N], ne[M], e[M], w[M], idx;</span><br><span class="line"><span class="keyword">int</span> n, m, S, T;</span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    w[idx] = c;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dist));</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    q.push(S);</span><br><span class="line">    dist[S] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        vis[t] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j]&gt;dist[t]+w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                <span class="keyword">if</span>(!vis[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    vis[j] = <span class="literal">true</span>;</span><br><span class="line">                    q.push(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; S &gt;&gt; T;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        add(a, b, c);</span><br><span class="line">        add(b, a, c);</span><br><span class="line">    &#125;</span><br><span class="line">    spfa();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dist[T] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码-dijkstra"><a href="#代码-dijkstra" class="headerlink" title="代码(dijkstra)"></a>代码(dijkstra)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef pair&lt;int, int&gt; PII;</span><br><span class="line">const int N &#x3D; 2510, M &#x3D; 6210 * 2;</span><br><span class="line">int h[N], ne[M], w[M], e[M], idx;</span><br><span class="line">int dist[N];</span><br><span class="line">bool st[N];</span><br><span class="line">int n, m, S, T;</span><br><span class="line">void add(int a,int b,int c)</span><br><span class="line">&#123;</span><br><span class="line">    e[idx] &#x3D; b;</span><br><span class="line">    w[idx] &#x3D; c;</span><br><span class="line">    ne[idx] &#x3D; h[a];</span><br><span class="line">    h[a] &#x3D; idx++;</span><br><span class="line">&#125; </span><br><span class="line">void dijkstra()</span><br><span class="line">&#123;</span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;</span><br><span class="line">    memset(dist, 0x3f, sizeof(dist));</span><br><span class="line">    memset(st, 0, sizeof(st));</span><br><span class="line">    dist[S] &#x3D; 0;</span><br><span class="line">    heap.push(&#123;0, S&#125;);</span><br><span class="line">    while(!heap.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        PII t &#x3D; heap.top();</span><br><span class="line">        heap.pop();</span><br><span class="line">        int distance &#x3D; t.first;</span><br><span class="line">        int ver &#x3D; t.second;</span><br><span class="line">        if(st[ver])</span><br><span class="line">            continue;</span><br><span class="line">        st[ver] &#x3D; true;</span><br><span class="line">        for (int i &#x3D; h[ver]; ~i;i &#x3D; ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            int j &#x3D; e[i];</span><br><span class="line">            if(dist[j]&gt;distance+w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] &#x3D; distance + w[i];</span><br><span class="line">                heap.push(&#123;dist[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    memset(h, -1, sizeof(h));</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; S &gt;&gt; T;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        add(a, b, c);</span><br><span class="line">        add(b, a, c);</span><br><span class="line">    &#125;</span><br><span class="line">    dijkstra();</span><br><span class="line">    cout &lt;&lt; dist[T] &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>单源最短路</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>昂贵的聘礼 acwing 903</title>
    <url>/2020/04/19/ac903/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/905/" target="_blank" rel="noopener">Acwing903</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>年轻的探险家来到了一个印第安部落里。</p>
<p>在那里他和酋长的女儿相爱了，于是便向酋长去求亲。</p>
<p>酋长要他用10000个金币作为聘礼才答应把女儿嫁给他。</p>
<p>探险家拿不出这么多金币，便请求酋长降低要求。</p>
<p>酋长说：”嗯，如果你能够替我弄到大祭司的皮袄，我可以只要8000金币。如果你能够弄来他的水晶球，那么只要5000金币就行了。”</p>
<p>探险家就跑到大祭司那里，向他要求皮袄或水晶球，大祭司要他用金币来换，或者替他弄来其他的东西，他可以降低价格。</p>
<p>探险家于是又跑到其他地方，其他人也提出了类似的要求，或者直接用金币换，或者找到其他东西就可以降低价格。</p>
<p>不过探险家没必要用多样东西去换一样东西，因为不会得到更低的价格。</p>
<p>探险家现在很需要你的帮忙，让他用最少的金币娶到自己的心上人。</p>
<p>另外他要告诉你的是，在这个部落里，等级观念十分森严。</p>
<p>地位差距超过一定限制的两个人之间不会进行任何形式的直接接触，包括交易。</p>
<p>他是一个外来人，所以可以不受这些限制。</p>
<p>但是如果他和某个地位较低的人进行了交易，地位较高的的人不会再和他交易，他们认为这样等于是间接接触，反过来也一样。</p>
<p>因此你需要在考虑所有的情况以后给他提供一个最好的方案。</p>
<p>为了方便起见，我们把所有的物品从1开始进行编号，酋长的允诺也看作一个物品，并且编号总是1。</p>
<p>每个物品都有对应的价格P，主人的地位等级L，以及一系列的替代品Ti和该替代品所对应的”优惠”Vi。</p>
<p>如果两人地位等级差距超过了M，就不能”间接交易”。</p>
<p>你必须根据这些数据来计算出探险家最少需要多少金币才能娶到酋长的女儿。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入第一行是两个整数M，N，依次表示地位等级差距限制和物品的总数。</p>
<p>接下来按照编号从小到大依次给出了N个物品的描述。</p>
<p>每个物品的描述开头是三个非负整数P、L、X，依次表示该物品的价格、主人的地位等级和替代品总数。</p>
<p>接下来X行每行包括两个整数T和V，分别表示替代品的编号和”优惠价格”。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出最少需要的金币数。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤N≤100,<br>1≤P≤10000,<br>1≤L,M≤N,<br>0≤X&lt;N</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 4</span><br><span class="line">10000 3 2</span><br><span class="line">2 8000</span><br><span class="line">3 5000</span><br><span class="line">1000 2 1</span><br><span class="line">4 200</span><br><span class="line">3000 2 1</span><br><span class="line">4 200</span><br><span class="line">50 2 0</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5250</span><br></pre></td></tr></table></figure>

<h3 id="题意分析"><a href="#题意分析" class="headerlink" title="题意分析"></a>题意分析</h3><p>用<code>w[i][j]</code>表示已经拥有了<code>i</code>的情况下，<code>j</code>的价值<br>将<code>w[0][j]</code>初始化为第<code>j</code>件物品的原价值<br>可以将<code>w</code>视为路径的权值来建图<br>因第一件物品的等级是最高的，所以所有可能取到的等级的区间为<br><code>[level[1]-m,level[1]]</code> ,枚举所有可能的区间，用<code>dijkstra</code>方法求出单源最短路径</p>
<p>因起点未知，所以这里采用朴素<code>dijkstra</code></p>
<h3 id="代码-bfs"><a href="#代码-bfs" class="headerlink" title="代码(bfs)"></a>代码(bfs)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="keyword">int</span> w[N][N];</span><br><span class="line"><span class="keyword">int</span> level[N];</span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dist));</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span>(st));</span><br><span class="line">    dist[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span>(!st[j]&amp;&amp;(t==<span class="number">-1</span>||dist[t]&gt;dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span>(level[j]&gt;=l&amp;&amp;level[j]&lt;=r)</span><br><span class="line">                dist[j] = min(dist[j], dist[t] + w[t][j]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="built_in">memset</span>(w, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(w));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> price, cnt;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; price &gt;&gt; level[i] &gt;&gt; cnt;</span><br><span class="line">        w[<span class="number">0</span>][i] = min(w[<span class="number">0</span>][i], price);</span><br><span class="line">        <span class="keyword">while</span>(cnt--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a, b;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">            w[a][i] = b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = level[<span class="number">1</span>] - m; i &lt;= level[<span class="number">1</span>]; i++)</span><br><span class="line">        res = min(res, dijkstra(i, i + m));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>单源最短路</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>香甜的黄油 acwing 1127</title>
    <url>/2020/04/18/ac1127/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/1129/" target="_blank" rel="noopener">Acwing1127</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>农夫John发现了做出全威斯康辛州最甜的黄油的方法：糖。</p>
<p>把糖放在一片牧场上，他知道 N 只奶牛会过来舔它，这样就能做出能卖好价钱的超甜黄油。</p>
<p>当然，他将付出额外的费用在奶牛上。</p>
<p>农夫John很狡猾，就像以前的巴甫洛夫，他知道他可以训练这些奶牛，让它们在听到铃声时去一个特定的牧场。</p>
<p>他打算将糖放在那里然后下午发出铃声，以至他可以在晚上挤奶。</p>
<p>农夫John知道每只奶牛都在各自喜欢的牧场（一个牧场不一定只有一头牛）。</p>
<p>给出各头牛在的牧场和牧场间的路线，找出使所有牛到达的路程和最短的牧场（他将把糖放在那）。</p>
<p>数据保证至少存在一个牧场和所有牛所在的牧场连通。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行: 三个数：奶牛数 N，牧场数 P，牧场间道路数 C。</p>
<p>第二行到第 N+1 行: 1 到 N 头奶牛所在的牧场号。</p>
<p>第 N+2 行到第 N+C+1 行：每行有三个数：相连的牧场A、B，两牧场间距 D，当然，连接是双向的。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>共一行，输出奶牛必须行走的最小的距离和。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤N≤500,<br>2≤P≤800,<br>1≤C≤1450,<br>1≤D≤255</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 4 5</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">1 2 1</span><br><span class="line">1 3 5</span><br><span class="line">2 3 7</span><br><span class="line">2 4 3</span><br><span class="line">3 4 5</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure>

<h3 id="题意分析"><a href="#题意分析" class="headerlink" title="题意分析"></a>题意分析</h3><p>在图中找出一点作为起点，使得起点到其他所有点的路径和最小</p>
<p>可以枚举所有点，都用一次<code>spfa</code>,然后他们中的找出最小值</p>
<h3 id="代码-spfa"><a href="#代码-spfa" class="headerlink" title="代码(spfa)"></a>代码(spfa)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">810</span>, M = <span class="number">3000</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">int</span> h[N], ne[M], e[M], w[M], idx;</span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="keyword">int</span> inf[N];</span><br><span class="line"><span class="keyword">int</span> n, p, c;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    w[idx] = c;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dist));</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span>(st));</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(S);</span><br><span class="line">    dist[S] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j]&gt;dist[t]+w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        res += dist[inf[i]];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; p &gt;&gt; c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; inf[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        add(a, b, c);</span><br><span class="line">        add(b, a, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= p; i++)</span><br><span class="line">        res = min(res, spfa(i));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>单源最短路</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>最优乘车 acwing 920</title>
    <url>/2020/04/18/ac920/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/922/" target="_blank" rel="noopener">Acwing920</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>H城是一个旅游胜地，每年都有成千上万的人前来观光。</p>
<p>为方便游客，巴士公司在各个旅游景点及宾馆，饭店等地都设置了巴士站并开通了一些单程巴士线路。</p>
<p>每条单程巴士线路从某个巴士站出发，依次途经若干个巴士站，最终到达终点巴士站。</p>
<p>一名旅客最近到H城旅游，他很想去S公园游玩，但如果从他所在的饭店没有一路巴士可以直接到达S公园，则他可能要先乘某一路巴士坐几站，再下来换乘同一站台的另一路巴士, 这样换乘几次后到达S公园。</p>
<p>现在用整数1,2,…N 给H城的所有的巴士站编号，约定这名旅客所在饭店的巴士站编号为1，S公园巴士站的编号为N。</p>
<p>写一个程序，帮助这名旅客寻找一个最优乘车方案,使他在从饭店乘车到S公园的过程中换乘的次数最少。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行有两个数字M和N，表示开通了M条单程巴士线路，总共有N个车站。</p>
<p>从第二行到第M+1行依次给出了第1条到第M条巴士线路的信息，其中第i+1行给出的是第i条巴士线路的信息，从左至右按运行顺序依次给出了该线路上的所有站号，相邻两个站号之间用一个空格隔开。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>共一行，如果无法乘巴士从饭店到达S公园，则输出”NO”，否则输出最少换乘次数，换乘次数为0表示不需换车即可到达。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤M≤100,<br>1≤N≤500</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 7</span><br><span class="line">6 7</span><br><span class="line">4 7 3 6</span><br><span class="line">2 1 3 5</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>

<h3 id="题意分析"><a href="#题意分析" class="headerlink" title="题意分析"></a>题意分析</h3><p>每一条公交路线中，前面的站可以到达后面的所有站<br>建图：我们可以设如果<code>A</code>能一次到达<code>B</code>，那么<code>A-&gt;B</code>的权值为<code>1</code><br>易得某条路线中总权值减一即为换乘的次数<br>本题转化为在图中求出起点到终点的最小权值和</p>
<p>特判：当起点和终点重合时，答案为<code>0</code>而不是<code>-1</code></p>
<p>本题采用了<code>stringstream</code>读入数据，它可以依次取出一个字符串中的所有整数</p>
<p>因图中所有边的权值都为<code>1</code>，所以可以采用<code>bfs</code>求出终点的最小值</p>
<h3 id="代码-bfs"><a href="#代码-bfs" class="headerlink" title="代码(bfs)"></a>代码(bfs)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span>;</span><br><span class="line"><span class="keyword">int</span> m, n;</span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"><span class="keyword">bool</span> g[N][N];</span><br><span class="line"><span class="keyword">int</span> stop[N];</span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dist));</span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> tt = <span class="number">0</span>;</span><br><span class="line">    q[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(hh&lt;=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = q[hh++];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">if</span>(g[t][i]&amp;&amp;dist[i]&gt;dist[t]+<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[i] = dist[t] + <span class="number">1</span>;</span><br><span class="line">                q[++tt] = i;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        getline(<span class="built_in">cin</span>, str);</span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">temp</span><span class="params">(str)</span></span>; <span class="comment">//为temp绑定字符串str</span></span><br><span class="line">        <span class="keyword">int</span> p;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(temp&gt;&gt;p)<span class="comment">//依次取出整型元素</span></span><br><span class="line">            stop[cnt++] = p;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; cnt; j++)</span><br><span class="line">                g[stop[i]][stop[j]] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bfs();</span><br><span class="line">    <span class="keyword">if</span>(dist[n]==<span class="number">0x3f3f3f3f</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; max(dist[n] - <span class="number">1</span>, <span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>单源最短路</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>最小花费 acwing 1126</title>
    <url>/2020/04/17/ac1126/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/1128/" target="_blank" rel="noopener">Acwing1126</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>在 n 个人中，某些人的银行账号之间可以互相转账。</p>
<p>这些人之间转账的手续费各不相同。</p>
<p>给定这些人之间转账时需要从转账金额里扣除百分之几的手续费，请问 A 最少需要多少钱使得转账后 B 收到 100 元。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行输入两个正整数 n,m，分别表示总人数和可以互相转账的人的对数。</p>
<p>以下 m 行每行输入三个正整数 x,y,z，表示标号为 x 的人和标号为 y 的人之间互相转账需要扣除 z 的手续费 ( z&lt;100 )。</p>
<p>最后一行输入两个正整数 A,B。</p>
<p>数据保证 A 与 B 之间可以直接或间接地转账。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出 A 使得 B 到账 100 元最少需要的总费用。</p>
<p>精确到小数点后 8 位。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤n≤2000,<br>m≤105</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2 1</span><br><span class="line">2 3 2</span><br><span class="line">1 3 3</span><br><span class="line">1 3</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">103.07153164</span><br></pre></td></tr></table></figure>

<h3 id="题意分析"><a href="#题意分析" class="headerlink" title="题意分析"></a>题意分析</h3><p>求 <code>B = A * W1 * W2 * … Wn</code> 最小值<br>即求 <code>W1 * W2 * … Wn</code> 最大值<br>以<code>100</code>为起点，每次更新当前点到<code>100</code>所需的最小花费<br><code>dijkstra</code> 算法要求<code>st</code>数组里的元素都是已经确定了最短路的<br>本题 符合条件<br>可用<code>dijkstra</code>、<code>spfa</code></p>
<h3 id="代码-朴素dijkstra"><a href="#代码-朴素dijkstra" class="headerlink" title="代码(朴素dijkstra)"></a>代码(朴素dijkstra)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, S, T;</span><br><span class="line"><span class="keyword">double</span> g[N][N];</span><br><span class="line"><span class="keyword">double</span> dist[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dist[S] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &lt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            dist[j] = max(dist[j], dist[t] * g[t][j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="keyword">double</span> z = (<span class="number">100.0</span> - c) / <span class="number">100</span>;</span><br><span class="line">        g[a][b] = g[b][a] = max(g[a][b], z);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; S &gt;&gt; T;</span><br><span class="line"></span><br><span class="line">    dijkstra();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.8lf\n"</span>, <span class="number">100</span> / dist[T]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码-heap优化dijkstra"><a href="#代码-heap优化dijkstra" class="headerlink" title="代码(heap优化dijkstra)"></a>代码(heap优化dijkstra)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">double</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2010</span>, M = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="keyword">double</span> w[M];</span><br><span class="line"><span class="keyword">double</span> dist[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> A, B;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">double</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    w[idx] = c;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        dist[i] = <span class="number">100000000.0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span>(st));</span><br><span class="line">    priority_queue&lt;PII,<span class="built_in">vector</span>&lt;PII&gt;,greater&lt;PII&gt;&gt; q;</span><br><span class="line">    q.push(&#123;<span class="keyword">double</span>(<span class="number">100</span>),B&#125;);</span><br><span class="line">    dist[B] = <span class="keyword">double</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        PII t = q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">double</span> distance = t.first;</span><br><span class="line">        <span class="keyword">int</span> ver = t.second;</span><br><span class="line">        <span class="keyword">if</span>(st[ver])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[ver]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; distance / (<span class="number">1</span> - (<span class="keyword">double</span>)w[i] / <span class="number">100</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = distance / (<span class="number">1</span> - (<span class="keyword">double</span>)w[i] / <span class="number">100</span>);</span><br><span class="line">                q.push(&#123;dist[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist[A];</span><br><span class="line">&#125;   </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="keyword">double</span> c;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        add(a, b, c);</span><br><span class="line">        add(b, a, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; A &gt;&gt; B;</span><br><span class="line">    <span class="keyword">double</span> res = dijkstra();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%0.8lf\n"</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>单源最短路</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>信使 acwing 1128</title>
    <url>/2020/04/17/ac1128/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/1130/" target="_blank" rel="noopener">Acwing1128</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>战争时期，前线有 n 个哨所，每个哨所可能会与其他若干个哨所之间有通信联系。</p>
<p>信使负责在哨所之间传递信息，当然，这是要花费一定时间的（以天为单位）。</p>
<p>指挥部设在第一个哨所。</p>
<p>当指挥部下达一个命令后，指挥部就派出若干个信使向与指挥部相连的哨所送信。</p>
<p>当一个哨所接到信后，这个哨所内的信使们也以同样的方式向其他哨所送信。信在一个哨所内停留的时间可以忽略不计。</p>
<p>直至所有 n 个哨所全部接到命令后，送信才算成功。</p>
<p>因为准备充足，每个哨所内都安排了足够的信使（如果一个哨所与其他 k 个哨所有通信联系的话，这个哨所内至少会配备 k 个信使）。</p>
<p>现在总指挥请你编一个程序，计算出完成整个送信过程最短需要多少时间。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第 1 行有两个整数 n 和 m，中间用 1 个空格隔开，分别表示有 n 个哨所和 m 条通信线路。</p>
<p>第 2 至 m+1 行：每行三个整数 i、j、k，中间用 1 个空格隔开，表示第 i 个和第 j 个哨所之间存在 双向 通信线路，且这条线路要花费 k 天。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>一个整数，表示完成整个送信过程的最短时间。</p>
<p>如果不是所有的哨所都能收到信，就输出-1。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤n≤100,<br>1≤m≤200,<br>1≤k≤1000</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 4</span><br><span class="line">1 2 4</span><br><span class="line">2 3 7</span><br><span class="line">2 4 1</span><br><span class="line">3 4 6</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure>

<h3 id="题意分析"><a href="#题意分析" class="headerlink" title="题意分析"></a>题意分析</h3><p>先求单源最短路，再求其中的最大值<br>模板题</p>
<h3 id="代码-Folyd"><a href="#代码-Folyd" class="headerlink" title="代码(Folyd)"></a>代码(Folyd)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> d[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        d[a][b] = d[b][a] = min(d[a][b], c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span>(d[<span class="number">1</span>][i]==INF)</span><br><span class="line">        &#123;</span><br><span class="line">            res = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            res = max(res, d[<span class="number">1</span>][i]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码-heap优化dijkstra"><a href="#代码-heap优化dijkstra" class="headerlink" title="代码(heap优化dijkstra)"></a>代码(heap优化dijkstra)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;PII;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">220</span>, M = <span class="number">440</span>;</span><br><span class="line"><span class="keyword">int</span> h[N],w[M],ne[M],e[M],idx;</span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="keyword">int</span> n, m, res;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    w[idx] = c;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx++;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;PII, <span class="built_in">vector</span>&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dist));</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span>(st));</span><br><span class="line">    <span class="keyword">int</span> S = <span class="number">1</span>;</span><br><span class="line">    dist[S] = <span class="number">0</span>;</span><br><span class="line">    heap.push(&#123;<span class="number">0</span>, S&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!heap.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        PII t = heap.top();</span><br><span class="line">        heap.pop();</span><br><span class="line">        <span class="keyword">int</span> distance = t.first;</span><br><span class="line">        <span class="keyword">int</span> ver = t.second;</span><br><span class="line">        <span class="keyword">if</span>(st[ver])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[ver]; ~i;i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j]&gt;distance+w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = distance + w[i];</span><br><span class="line">                heap.push(&#123;dist[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dist[i]==<span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        res = max(res,dist[i]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span>(h));</span><br><span class="line">    <span class="comment">//vector&lt;int&gt;v ;</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="comment">//v.push_back(a);</span></span><br><span class="line">        add(a, b, c);</span><br><span class="line">        add(b, a, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;"i="&lt;&lt;i&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dijkstra()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>单源最短路</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>字串变换 acwing 190</title>
    <url>/2020/04/17/ac190/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/192/" target="_blank" rel="noopener">Acwing190</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>已知有两个字串 A, B 及一组字串变换的规则（至多6个规则）:</p>
<p>A1 -&gt; B1<br>A2 -&gt; B2<br>…</p>
<p>规则的含义为：在 A 中的子串 A1 可以变换为 B1、A2 可以变换为 B2 …。</p>
<p>例如：A＝’abcd’ B＝’xyz’</p>
<p>变换规则为：</p>
<p>‘abc’-&gt;‘xu’ ‘ud’-&gt;‘y’ ‘y’-&gt;‘yz’</p>
<p>则此时，A 可以经过一系列的变换变为 B，其变换的过程为：</p>
<p>‘abcd’-&gt;‘xud’-&gt;‘xy’-&gt;‘xyz’</p>
<p>共进行了三次变换，使得 A 变换为B。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>A B<br>A1 B1 <br>A2 B2 |-&gt; 变换规则<br>… … /<br>所有字符串长度的上限为 20。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>若在 10 步（包含 10步）以内能将 A 变换为 B ，则输出最少的变换步数；否则输出”NO ANSWER!”</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abcd xyz</span><br><span class="line">abc xu</span><br><span class="line">ud y</span><br><span class="line">y yz</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>



<h3 id="双向bfs"><a href="#双向bfs" class="headerlink" title="双向bfs"></a>双向bfs</h3><p>最坏情况下，搜到第十层，那么搜索空间是 <code>6^10</code>，这将直接<code>TLE/MLE</code><br>但如果采用双向<code>BFS</code>的方法，起点与终点将会在中点相遇，<br>这时从起点搜索和从终点搜索的空间各为 <code>6^5</code>，剪枝效果很好</p>
<p>优化双向<code>bfs</code>：<br>每次选择起点和终点的队列中元素较少的那个队列进行扩展</p>
<p>时间复杂度：<br>由于<code>bfs</code>中，空间中的每种状态只会被遍历一次<br>设字符串长度为<code>L</code>，起点决策数为<code>L</code>个时间复杂度为<code>O((LN)^5)</code></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">6</span>;</span><br><span class="line"><span class="built_in">string</span> a[N], b[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">extend</span><span class="params">(<span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt;&amp;q,<span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;&amp;da,<span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;&amp;db,<span class="built_in">string</span> a[],<span class="built_in">string</span> b[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> t = q.front();</span><br><span class="line">    q.pop();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.size();i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(t.substr(i,a[j].size())!=a[j])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//substr()第二个参数不填则默认为截取到终点</span></span><br><span class="line">            <span class="built_in">string</span> r = t.substr(<span class="number">0</span>, i) + b[j] + t.substr(i + a[j].size());</span><br><span class="line">            <span class="keyword">if</span>(db.count(r))</span><br><span class="line">                <span class="keyword">return</span> da[t] + db[r] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(da.count(r))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            da[r] = da[t] + <span class="number">1</span>;</span><br><span class="line">            q.push(r);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="built_in">string</span> A,<span class="built_in">string</span> B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; qa, qb;</span><br><span class="line">    qa.push(A);</span><br><span class="line">    qb.push(B);</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; da, db;</span><br><span class="line">    da[A] = <span class="number">0</span>;</span><br><span class="line">    db[B] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(qa.size()&amp;&amp;qb.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(da[qa.front()]+db[qb.front()]&gt;<span class="number">10</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        <span class="keyword">if</span>(qa.size()&gt;qb.size())</span><br><span class="line">            t = extend(qa, da, db, a, b);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            t = extend(qb, db, da, b, a);</span><br><span class="line">        <span class="keyword">if</span>(t!=<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> A, B;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; A &gt;&gt; B;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;a[n]&gt;&gt;b[n])</span><br><span class="line">        n++;</span><br><span class="line">    <span class="keyword">int</span> res = bfs(A, B);</span><br><span class="line">    <span class="keyword">if</span>(res&gt;<span class="number">10</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"NO ANSWER!\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title>电路维修 acwing 175</title>
    <url>/2020/04/16/ac175/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/177/" target="_blank" rel="noopener">Acwing175</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>达达是来自异世界的魔女，她在漫无目的地四处漂流的时候，遇到了善良的少女翰翰，从而被收留在地球上。</p>
<p>翰翰的家里有一辆飞行车。</p>
<p>有一天飞行车的电路板突然出现了故障，导致无法启动。</p>
<p>电路板的整体结构是一个R行C列的网格（R,C≤500），如下图所示。</p>
<p><img src="/images/ac175.png" alt="alt"></p>
<p>每个格点都是电线的接点，每个格子都包含一个电子元件。</p>
<p>电子元件的主要部分是一个可旋转的、连接一条对角线上的两个接点的短电缆。</p>
<p>在旋转之后，它就可以连接另一条对角线的两个接点。</p>
<p>电路板左上角的接点接入直流电源，右下角的接点接入飞行车的发动装置。</p>
<p>达达发现因为某些元件的方向不小心发生了改变，电路板可能处于断路的状态。</p>
<p>她准备通过计算，旋转最少数量的元件，使电源与发动装置通过若干条短缆相连。</p>
<p>不过，电路的规模实在是太大了，达达并不擅长编程，希望你能够帮她解决这个问题。</p>
<p>注意：只能走斜向的线段，水平和竖直线段不能走。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入文件包含多组测试数据。</p>
<p>第一行包含一个整数T，表示测试数据的数目。</p>
<p>对于每组测试数据，第一行包含正整数R和C，表示电路板的行数和列数。</p>
<p>之后R行，每行C个字符，字符是”/“和”&quot;中的一个，表示标准件的方向。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>对于每组测试数据，在单独的一行输出一个正整数，表示所需的缩小旋转次数。</p>
<p>如果无论怎样都不能使得电源和发动机之间连通，输出NO SOLUTION。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤R,C≤500,<br>1≤T≤5</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">3 5</span><br><span class="line">\\&#x2F;\\</span><br><span class="line">\\&#x2F;&#x2F;&#x2F;</span><br><span class="line">&#x2F;\\\\</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>

<h3 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h3><p><img src="/images/ac175-2.png" alt="alt"></p>
<h3 id="双端队列bfs"><a href="#双端队列bfs" class="headerlink" title="双端队列bfs"></a>双端队列bfs</h3><p>对于任意一个点的四个可达点中，若某可达点不需要转动原件就可以到达，那么到达这个点的花费为<code>0</code>，这个可达点就应该优先考虑，即将其插入到队头，反之，如果某可达点需要转动原件才能到达，那么它将按照正常的<code>bfs</code>搜索顺序，插入到队尾</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span>, M = N * N;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="comment">//g数组存储每个格点中的元件摆放情况(格子的左上角坐标代表该格子)</span></span><br><span class="line"><span class="comment">//dist数组用于存储到该格点的最短路径长度</span></span><br><span class="line"><span class="comment">//st数组用于判断该店在之前是否被搜索过</span></span><br><span class="line"><span class="keyword">char</span> g[N][N];</span><br><span class="line"><span class="keyword">int</span> dist[N][N];</span><br><span class="line"><span class="keyword">bool</span> st[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//要求最小值故初始化为INF</span></span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dist));</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span>(st));</span><br><span class="line">    dist[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">deque</span>&lt;PII&gt; q;</span><br><span class="line">    q.push_back(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">	<span class="comment">//cs存储四种可达路径的初始情况（不用调整原件）</span></span><br><span class="line">	<span class="comment">//cs与dx，dy，ix，iy对应，分别为左上，左下，右下，右上</span></span><br><span class="line">	<span class="comment">// \为转义字符，故需要写为\\</span></span><br><span class="line">	<span class="comment">//dx，dy存储的是可选路径</span></span><br><span class="line">	<span class="comment">//ix，iy对应于dx，dy路径所在的格子</span></span><br><span class="line">    <span class="comment">//如(-1,1)这条路径对应的格点为(-1,0) </span></span><br><span class="line">    <span class="keyword">char</span> cs[] = <span class="string">"\\/\\/"</span>;</span><br><span class="line">    <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> ix[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> iy[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q.size())</span><br><span class="line">    &#123;</span><br><span class="line">        PII t = q.front();</span><br><span class="line">        q.pop_front();</span><br><span class="line">        <span class="keyword">if</span>(st[t.x][t.y])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        st[t.x][t.y] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a = t.x + dx[i];</span><br><span class="line">            <span class="keyword">int</span> b = t.y + dy[i];</span><br><span class="line">            <span class="keyword">if</span>(a&lt;<span class="number">0</span>||b&lt;<span class="number">0</span>||a&gt;n||b&gt;m)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> ca = t.x + ix[i];</span><br><span class="line">            <span class="keyword">int</span> cb = t.y + iy[i];</span><br><span class="line">            <span class="keyword">int</span> d = dist[t.x][t.y] + (g[ca][cb] != cs[i]);</span><br><span class="line">            <span class="keyword">if</span>(d&lt;dist[a][b])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[a][b] = d;</span><br><span class="line">                <span class="keyword">if</span>(g[ca][cb]==cs[i])</span><br><span class="line">                    q.push_front(&#123;a, b&#125;);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    q.push_back(&#123;a, b&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist[n][m];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>, g[i]);</span><br><span class="line">        <span class="keyword">int</span> t = bfs();</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="number">0x3f3f3f3f</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"NO SOLUTION\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title>股票买卖V acwing 1058</title>
    <url>/2020/04/14/ac1058/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/1060/" target="_blank" rel="noopener">Acwing1058</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定一个长度为 N 的数组，数组中的第 i 个数字表示一个给定股票在第 i 天的价格。</p>
<p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>
<p>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含整数 N，表示数组长度。</p>
<p>第二行包含 N 个不超过 10000 的正整数，表示完整的数组。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个整数，表示最大利润。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤N≤1e5</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1 2 3 0 2</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<h3 id="状态机dp"><a href="#状态机dp" class="headerlink" title="状态机dp"></a>状态机dp</h3><p><code>f[i][0]</code>表示遍历为前<code>i</code>个股票，当前有票<br><code>f[i][1]</code>表示遍历完前<code>i</code>个股票，当前为无票的第<code>1</code>天（当天刚出售了股票）<br><code>f[i][2]</code>表示遍历完前<code>i</code>个股票，当前无票的天数为<code>2</code>天及以上</p>
<p>状态方程：<br><code>f[i][0]=max(f[i-1][0],f[i-1][2]-w[i])</code><br><code>f[i][1]=f[i-1][0]+w[i]</code><br><code>f[i][2]=max(f[i-1][1],f[i-1][2])</code></p>
<p>初始状态<br><code>f[0][0]=f[0][1]=-INF</code><br><code>f[0][2]=0</code></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> w[N];</span><br><span class="line"><span class="keyword">int</span> f[N][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;w[i]);</span><br><span class="line"></span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = f[<span class="number">0</span>][<span class="number">1</span>] = -INF, f[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        f[i][<span class="number">0</span>] = max(f[i - <span class="number">1</span>][<span class="number">0</span>], f[i - <span class="number">1</span>][<span class="number">2</span>] - w[i]);</span><br><span class="line">        f[i][<span class="number">1</span>] = f[i - <span class="number">1</span>][<span class="number">0</span>] + w[i];</span><br><span class="line">        f[i][<span class="number">2</span>] = max(f[i - <span class="number">1</span>][<span class="number">2</span>], f[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, max(f[n][<span class="number">1</span>], f[n][<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>股票买卖IV acwing 1057</title>
    <url>/2020/04/14/ac1057/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/1059/" target="_blank" rel="noopener">Acwing1057</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定一个长度为 N 的数组，数组中的第 i 个数字表示一个给定股票在第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润，你最多可以完成 k 笔交易。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。一次买入卖出合为一笔交易。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含整数 N 和 k，表示数组的长度以及你可以完成的最大交易数量。</p>
<p>第二行包含 N 个不超过 10000 的正整数，表示完整的数组。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个整数，表示最大利润。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤N≤1e5,<br>1≤k≤100</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6 2</span><br><span class="line">3 2 6 5 0 3</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure>

<h3 id="状态机dp"><a href="#状态机dp" class="headerlink" title="状态机dp"></a>状态机dp</h3><p><code>f[i][j][0]</code>表示遍历完前<code>i</code>个股票，做了<code>j</code>次交易且当前无票的状态<br><code>f[i][j][1]</code>表示遍历完前<code>i</code>个股票，做了<code>j</code>次交易且当前有票的状态<br><code>f[i][j][k]</code>的值表示当前状态下所能获得的最大收益<br>初始状态：<code>f[i][0][0]</code> <code>(1≤i≤n)</code>初始化为<code>0</code>,其余初始化为<code>-INF</code><br>保证所有状态从<code>f[i][0][0]</code>转移过来<br>注：购票时算做了一次交易，售票时不再统计</p>
<p>状态方程：<br><code>f[i][j][0]=max(f[i-1][j][0],f[i-1][j][1]+w[i])</code><br><code>f[i][j][1]=max(f[i-1][j][1],f[i-1][j-1][0]-w[i])</code></p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>经观察我们发现，所有的<code>f[i][j][k]</code>均由<code>f[i-1][...][...]</code>转移过来，即本层<code>i</code>只会用到<code>i-1</code>的状态。运用类似01背包的思想，我们可以将<code>j</code>从大到小枚举，这样就可以优化掉一维，且保证当前状态只会由上一层转移过来<br>状态方程：<br><code>f[j][0] = max(f[j][0], f[j][1] + w[i])</code><br><code>f[j][1] = max(f[j][1], f[j - 1][0] - w[i])</code><br>初始状态：<code>f[0][0]=0</code></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">100010</span>][<span class="number">110</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">-0x3f3f3f3f</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">        f[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j][<span class="number">0</span>] = max(f[i - <span class="number">1</span>][j][<span class="number">0</span>], f[i - <span class="number">1</span>][j][<span class="number">1</span>] + a[i]);</span><br><span class="line">            f[i][j][<span class="number">1</span>] = max(f[i - <span class="number">1</span>][j][<span class="number">1</span>], f[i - <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">0</span>] - a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; i++)</span><br><span class="line">        res = max(res, f[n][i][<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优化代码"><a href="#优化代码" class="headerlink" title="优化代码"></a>优化代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">110</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">-0x3f3f3f3f</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    </span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = k; j &gt;= <span class="number">1</span>;j--)</span><br><span class="line">        &#123;</span><br><span class="line">            f[j][<span class="number">0</span>] = max(f[j][<span class="number">0</span>], f[j][<span class="number">1</span>] + a[i]);</span><br><span class="line">            f[j][<span class="number">1</span>] = max(f[j][<span class="number">1</span>], f[j - <span class="number">1</span>][<span class="number">0</span>] - a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; i++)</span><br><span class="line">        res = max(res, f[i][<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>骑士 acwing 1064</title>
    <url>/2020/04/13/ac1064/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/1066/" target="_blank" rel="noopener">Acwing1064</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>在 n×n 的棋盘上放 k 个国王，国王可攻击相邻的 8 个格子，求使它们无法互相攻击的方案总数。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>共一行，包含两个整数 n 和 k。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>共一行，表示方案总数，若不能够放置则输出0。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤n≤10,<br>0≤k≤n2</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 2</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">16</span><br></pre></td></tr></table></figure>

<h3 id="状态压缩dp"><a href="#状态压缩dp" class="headerlink" title="状态压缩dp"></a>状态压缩dp</h3><p><code>f[i][j][k]</code>表示遍历完了前<code>i</code>行，放了<code>j</code>个棋子，最后一行的状态为<code>k</code>的状态的集合，<code>f[i][j][k]</code>的值为方案总数<br>首先找出行内的合法状态(无相邻棋子),再找出相邻两行之间的合法状态（两状态相或后的状态无相邻的1），用二维向量存储<br>状态方程<br><code>f[i][j][a]+=f[i-1][j-cnt[state[a]][b]</code><br><code>a</code>,<code>b</code>分别为状态向量<code>state</code>中元素下标，<code>cnt[state[a]]</code>为<code>state[a]</code>状态中<code>1</code>的个数，<code>a</code>，<code>b</code>互为相邻合法状态</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">12</span>, M = <span class="number">1</span> &lt;&lt; <span class="number">11</span>, K = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[N][K][M];</span><br><span class="line"><span class="keyword">int</span> cnt[M];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; state;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; head[M];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i++)</span><br><span class="line">        <span class="keyword">if</span>((s&gt;&gt;i&amp;<span class="number">1</span>)&amp;&amp;(s&gt;&gt;(i+<span class="number">1</span>)&amp;<span class="number">1</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i++)</span><br><span class="line">        res += s &gt;&gt; i &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n;i++)</span><br><span class="line">        <span class="keyword">if</span>(check(i))</span><br><span class="line">        &#123;</span><br><span class="line">            state.push_back(i);</span><br><span class="line">            cnt[i] = count(i);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; state.size();i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; state.size();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a = state[i];</span><br><span class="line">            <span class="keyword">int</span> b = state[j];</span><br><span class="line">            <span class="keyword">if</span>((a&amp;b)==<span class="number">0</span>&amp;&amp;check(a|b))</span><br><span class="line">                head[i].push_back(j);</span><br><span class="line">        &#125;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= k;j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; state.size();a++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> b:head[a])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> c = cnt[state[b]];</span><br><span class="line">                    <span class="keyword">if</span>(j&gt;=c)</span><br><span class="line">                        f[i][j][b] += f[i - <span class="number">1</span>][j - c][a];</span><br><span class="line">                &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[n + <span class="number">1</span>][k][<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>玉米田 acwing 327</title>
    <url>/2020/04/13/ac327/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/329/" target="_blank" rel="noopener">Acwing327</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>农夫约翰的土地由M*N个小方格组成，现在他要在土地里种植玉米。<br>非常遗憾，部分土地是不育的，无法种植。<br>而且，相邻的土地不能同时种植玉米，也就是说种植玉米的所有方格之间都不会有公共边缘。<br>现在给定土地的大小，请你求出共有多少种种植方法。<br>土地上什么都不种也算一种方法。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第1行包含两个整数M和N。</p>
<p>第2..M+1行：每行包含N个整数0或1，用来描述整个土地的状况，1表示该块土地肥沃，0表示该块土地不育。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出总种植方法对100000000取模后的值。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤M,N≤12</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 3</span><br><span class="line">1 1 1</span><br><span class="line">0 1 0</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure>

<h3 id="状态压缩dp"><a href="#状态压缩dp" class="headerlink" title="状态压缩dp"></a>状态压缩dp</h3><p><code>f[i][j]</code>表示遍历完前<code>i</code>行，且当前行的状态为<code>j</code>的集合，<code>f[i][j]</code>的值表示方案数。<br>本题与<a href="https://www.acwing.com/problem/content/1066/" target="_blank" rel="noopener">Acwing1064</a>不同，本题对放置的个数无要求，故可直接删去数量这一维。<br>状态方程<br><code>f[i][j]+=f[i-1][k]</code> <code>(j,k互为合法状态且j与w[i]互为合法状态)</code></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">14</span>, M = <span class="number">1</span> &lt;&lt; <span class="number">12</span>, mod = <span class="number">1e8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> w[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; state;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; head[M];</span><br><span class="line"><span class="keyword">int</span> f[N][M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + <span class="number">1</span> &lt; m; i ++ )</span><br><span class="line">        <span class="keyword">if</span> ((state &gt;&gt; i &amp; <span class="number">1</span>) &amp;&amp; (state &gt;&gt; i + <span class="number">1</span> &amp; <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">            w[i] += !t * (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; m; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (check(i))</span><br><span class="line">            state.push_back(i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; state.size(); i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; state.size(); j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a = state[i], b = state[j];</span><br><span class="line">            <span class="keyword">if</span> (!(a &amp; b))</span><br><span class="line">                head[i].push_back(j);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; state.size(); j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!(state[j] &amp; w[i]))</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k : head[j])</span><br><span class="line">                    f[i][j] = (f[i][j] + f[i - <span class="number">1</span>][k]) % mod;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[n + <span class="number">1</span>][<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>陪审团 acwing 280</title>
    <url>/2020/04/12/ac280/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/282/" target="_blank" rel="noopener">Acwing280</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>在一个遥远的国家，一名嫌疑犯是否有罪需要由陪审团来决定。</p>
<p>陪审团是由法官从公民中挑选的。</p>
<p>法官先随机挑选N个人（编号1,2…,N）作为陪审团的候选人，然后再从这N个人中按照下列方法选出M人组成陪审团。</p>
<p>首先，参与诉讼的控方和辩方会给所有候选人打分，分值在0到20之间。</p>
<p>第 i 个人的得分分别记为p[i]和d[i]。</p>
<p>为了公平起见，法官选出的M个人必须满足：辩方总分D和控方总分P的差的绝对值|D-P|最小。</p>
<p>如果选择方法不唯一，那么再从中选择辨控双方总分之和D+P最大的方案。</p>
<p>求最终的陪审团获得的辩方总分D、控方总分P，以及陪审团人选的编号。</p>
<p>注意：若陪审团的人选方案不唯一，则任意输出一组合法方案即可。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入包含多组测试数据。</p>
<p>每组测试数据第一行包含两个整数N和M。</p>
<p>接下来N行，每行包含两个整数p[i]和d[i]。</p>
<p>每组测试数据之间隔一个空行。</p>
<p>当输入数据N=0，M=0时，表示结束输入，该数据无需处理。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>对于每组数据，第一行输出’Jury #C’，C为数据编号，从1开始。</p>
<p>第二行输出“Best jury has value P for prosecution and value D for defence:”，P为控方总分，D为辩方总分。</p>
<p>第三行输出按升序排列的陪审人选编号，每个编号前输出一个空格。</p>
<p>每组数据输出完后，输出一个空行。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤N≤200,<br>1≤M≤20<br>0≤p[i],d[i]≤20</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 2</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">4 1</span><br><span class="line">6 2</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Jury #1</span><br><span class="line">Best jury has value 6 for prosecution and value 4 for defence:</span><br><span class="line"> 2 3</span><br></pre></td></tr></table></figure>

<h3 id="状态表示"><a href="#状态表示" class="headerlink" title="状态表示"></a>状态表示</h3><p><code>f[i][j][k]</code>表示遍历完前<code>i</code>个候选人后，选了<code>j</code>个候选人并且两方的总分的差值为<code>k</code>的所有情况的集合<br><code>f[i][j][k]</code>的值表示该种情况下所能取得的两方的总分的和的最大值</p>
<p>初始化<br>保证所有的结果都是从0状态转移过来的<br>所以<code>f[0][0][base]</code>初始化为<code>0</code>，其余为<code>-INF</code><br>状态转移<br>1 不选第<code>i</code>个人<br><code>f[i][j][k]=f[i-1][j][k]</code><br>2.选第<code>i</code>个人<br><code>f[i][j][k]=max(f[i][j][k],f[i-1][j-1][k-(p[i]-d[i])]+p[i]+d[i])</code><br><code>(0&lt;=k-(p[i]-d[i])&lt;=800&amp;&amp;j&gt;=1)</code></p>
<p>还原结果<br>首先在<code>base</code>左右寻找第一个非负值，偏离量为<code>v</code><br>之后枚举<code>f[n][m][v]</code><br>若<code>f[i][j][k]==f[i-1][j][k]</code>,表示没有选第i个人是符合条件的一个解，<br><code>i--</code>即可<br>否则，第<code>i</code>个人的加入使得结果发生了变化，则一定选了第<code>i</code>个人，此时将第<code>i</code>个人加入结果，并更新<code>i--,j--,k-=(p[i]-d[i])</code></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">210</span>, M = <span class="number">801</span>, base = <span class="number">400</span>;</span><br><span class="line"><span class="keyword">int</span> f[N][<span class="number">21</span>][M];</span><br><span class="line"><span class="keyword">int</span> p[N], d[N], ans[N];</span><br><span class="line"><span class="keyword">int</span> n, m, c;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m),n||m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;p[i], &amp;d[i]);</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">-0x3f</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>][base] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m;j++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; M;k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    f[i][j][k] = f[i - <span class="number">1</span>][j][k];</span><br><span class="line">                    <span class="keyword">if</span>(j&lt;<span class="number">1</span>)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">int</span> t = k - (p[i] - d[i]);</span><br><span class="line">                    <span class="keyword">if</span>(t&lt;<span class="number">0</span>||t&gt;=M)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    f[i][j][k] = max(f[i][j][k], f[i - <span class="number">1</span>][j - <span class="number">1</span>][t] + p[i] + d[i]);</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">int</span> v = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(f[n][m][base-v]&lt;<span class="number">0</span>&amp;&amp;f[n][m][base+v]&lt;<span class="number">0</span>)</span><br><span class="line">            v++;</span><br><span class="line">        <span class="keyword">if</span>(f[n][m][base-v]&gt;f[n][m][base+v])</span><br><span class="line">            v = base - v;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            v = base + v;</span><br><span class="line">        <span class="keyword">int</span> i = n, j = m, k = v;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(f[i][j][k]==f[i<span class="number">-1</span>][j][k])</span><br><span class="line">                i--;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ans[cnt++] = i;</span><br><span class="line">                k-=(p[i]-d[i]);</span><br><span class="line">                i--;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> tp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> td = <span class="number">0</span>;</span><br><span class="line">        sort(ans, ans + cnt);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            tp += p[ans[i]];</span><br><span class="line">            td += d[ans[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Jury #%d\n"</span>, ++c);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Best jury has value %d for prosecution and value %d for defence:\n"</span>, tp, td);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt;i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" %d"</span>, ans[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>环路运输 acwing 289</title>
    <url>/2020/04/12/ac289/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/291/" target="_blank" rel="noopener">Acwing289</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>在一条环形公路旁均匀地分布着N座仓库，编号为1~N，编号为 i 的仓库与编号为 j 的仓库之间的距离定义为 dist(i,j)=min⁡(|i-j|,N-|i-j|)，也就是逆时针或顺时针从 i 到 j 中较近的一种。</p>
<p>每座仓库都存有货物，其中编号为 i 的仓库库存量为 Ai。</p>
<p>在 i 和 j 两座仓库之间运送货物需要的代价为 Ai+Aj+dist(i,j)。</p>
<p>求在哪两座仓库之间运送货物需要的代价最大。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含一个整数N。</p>
<p>第二行包含N个整数A1~AN。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个整数，表示最大代价。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤N≤106,<br>1≤Ai≤107</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1 8 6 2 5</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">15</span><br></pre></td></tr></table></figure>

<h3 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3><p>由于dist(i,j)=dist(j,i)，对于任意i，我们只需求[i-n/2,i]区间内的A[i]+A[j]+i-j即可，而对于任意i，i+A[i]为定值。所以原题转化为求任意[i-n/2,i]区间内的-j+A[j]的最大值，即滑动窗口问题<br>题中所给的是环形结构，这里用最经典的破环成链方法，将原数组的复制接到原数组的后面即可。</p>
<h3 id="代码-数组"><a href="#代码-数组" class="headerlink" title="代码(数组)"></a>代码(数组)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> w[N];</span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;w[i]);</span><br><span class="line">        w[i + n] = w[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> len = n / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * <span class="number">2</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (hh &lt;= tt &amp;&amp; q[hh] &lt; i - len) hh ++ ;</span><br><span class="line">        res = max(res, i - q[hh] + w[q[hh]] + w[i]);</span><br><span class="line">        <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; w[q[tt]] - q[tt] &lt;= w[i] - i) tt -- ;</span><br><span class="line">        q[ ++ tt] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码（deque）"><a href="#代码（deque）" class="headerlink" title="代码（deque）"></a>代码（deque）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">int</span> a[N*<span class="number">2</span>];</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        a[i + n] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = n / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (q.size() &amp;&amp; q.front() + len &lt; i)</span><br><span class="line">            q.pop_front();</span><br><span class="line">        res = max(res, i - q.front() + a[q.front()] + a[i]);</span><br><span class="line">        <span class="keyword">while</span> (q.size() &amp;&amp; -q.back() + a[q.back()] &lt;= -i + a[i])</span><br><span class="line">            q.pop_back();</span><br><span class="line">        q.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title>休息时间 acwing 288</title>
    <url>/2020/04/12/ac288/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/290/" target="_blank" rel="noopener">Acwing288</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>在某个星球上，一天由 N 个小时构成，我们称0点到1点为第1个小时、1点到2点为第2个小时，以此类推。</p>
<p>在第 i 个小时睡觉能够恢复Ui点体力。</p>
<p>在这个星球上住着一头牛，它每天要休息B个小时。</p>
<p>它休息的这B个小时不一定连续，可以分成若干段，但是在每段的第一个小时，它需要从清醒逐渐入睡，不能恢复体力，从下一个小时开始才能睡着。</p>
<p>为了身体健康，这头牛希望遵循生物钟，每天采用相同的睡觉计划。</p>
<p>另外，因为时间是连续的，即每一天的第N个小时和下一天的第1个小时是相连的（N点等于0点），这头牛只需要在每N个小时内休息够B个小时就可以了。</p>
<p>请你帮忙给这头牛安排一个睡觉计划，使它每天恢复的体力最多。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第1行输入两个空格隔开的整数N和B。</p>
<p>第2..N+1行，第 i+1 行包含一个整数Ui。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个整数，表示恢复的体力值。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>3≤N≤3830<br>2≤B&lt;N<br>0≤Ui≤200000</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 3</span><br><span class="line">2</span><br><span class="line">0</span><br><span class="line">3</span><br><span class="line">1</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure>

<h3 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h3><p>这头牛每天3点入睡，睡到次日1点，即[1,4,2]时间段休息，每天恢复体力值最大，为0+4+2=6。</p>
<h3 id="状态表示"><a href="#状态表示" class="headerlink" title="状态表示"></a>状态表示</h3><p><code>f[i][j][0]</code>表示第i小时一共睡了j小时且第i小时没有在睡觉的集合<br><code>f[i][j][1]</code>表示第i小时一共睡了j小时且第i小时在睡觉的集合<br>易得状态转移方程<br><code>f[i][j][0]=max(f[i-1][j][0],f[i-1][j][1])</code><br><code>f[i][j][1]=max(f[i-1][j-1][0],f[i-1][j-1][1]+w[i])</code></p>
<p>为了区分是否跨越了一天，这里对第N小时的情况进行了划分：<br>若第N小时在睡觉，同时第1小时在睡觉，那么第一小时可以恢复体力<br>其余情况下第一小时均不可恢复体力<br>故有初始状态为<br><code>f[1][0][0]=0,f[1][1][1]=0</code> (第N小时没有睡觉)<br><code>f[1][0][0]=0,f[1][1][1]=w[i]</code> (第N小时在睡觉)</p>
<p>最终结果为对第一个初始状态求出的<code>f[n][m][0]</code><br>和对第二个初始状态求出的<code>f[n][m][1]</code>取最大值</p>
<p>因空间限制，本题采用了滚动数组</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4000</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">2</span>][N][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> w[N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; w[i];</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-0x3f</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i &amp; <span class="number">1</span>][j][<span class="number">0</span>] = max(f[i - <span class="number">1</span> &amp; <span class="number">1</span>][j][<span class="number">0</span>], f[i - <span class="number">1</span> &amp; <span class="number">1</span>][j][<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(j)</span><br><span class="line">                f[i &amp; <span class="number">1</span>][j][<span class="number">1</span>] = max(f[i - <span class="number">1</span> &amp; <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">0</span>], f[i - <span class="number">1</span> &amp; <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">1</span>] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">int</span> res = f[n &amp; <span class="number">1</span>][m][<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-0x3f</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] = w[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i &amp; <span class="number">1</span>][j][<span class="number">0</span>] = max(f[i - <span class="number">1</span> &amp; <span class="number">1</span>][j][<span class="number">0</span>], f[i - <span class="number">1</span> &amp; <span class="number">1</span>][j][<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(j)</span><br><span class="line">                f[i &amp; <span class="number">1</span>][j][<span class="number">1</span>] = max(f[i - <span class="number">1</span> &amp; <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">0</span>], f[i - <span class="number">1</span> &amp; <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">1</span>] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    res = max(res, f[n &amp; <span class="number">1</span>][m][<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>背包问题</title>
    <url>/2020/04/11/beibao/</url>
    <content><![CDATA[<p>几类背包问题</p>
<a id="more"></a>

<h3 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h3><p>原题链接：<a href="https://www.acwing.com/problem/content/2/" target="_blank" rel="noopener">Acwing2</a></p>
<p>有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。</p>
<p>第 i 件物品的体积是 vi，价值是 wi。</p>
<p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出最大价值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = m; j &gt;= w[i]; j--) </span><br><span class="line">    	f[j] = max(f[j], f[j-w[i]] + v[i]);</span><br></pre></td></tr></table></figure>

<p>从大到小循环的原因是<code>f[i,j]</code>要用<code>f[i-1,j-v[i]]+w[i]</code>来更新，从大到小可以保证算<code>f[j]</code>时用到的<code>f[j-v[i]]</code>存储的是<code>f[i-1,j-v[i]]</code>，而不是<code>f[i,j-v[i]]</code>；如果从小到大循环，那么<code>f[j-v[i]]</code>会在<code>f[j]</code>前被计算出来，那么它就表示<code>f[i,j-v[i]]</code>了。</p>
<p>若f数组全被初始化为0，则直接输出f[V]<br>若f数组除了f[0],其余被初始化为-INF，则要循环枚举所有体积</p>
<p>因为初始化为-INF，所有状态都由0转移过来<br>而初始化为0，所有状态都由任意状态转移过来，此时f[V]包含了所有可能体积的最大可能值</p>
<h3 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h3><p>原题链接：<a href="https://www.acwing.com/problem/content/3/" target="_blank" rel="noopener">Acwing3</a><br>有 N 种物品和一个容量是 V 的背包，每种物品都有无限件可用。</p>
<p>第 i 种物品的体积是 vi，价值是 wi。</p>
<p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出最大价值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = w[i]; j &lt;= m; j++) </span><br><span class="line">    	f[j] = max(f[j], f[j-w[i]] + v[i]);</span><br></pre></td></tr></table></figure>

<p>从小到大循环保证了<code>f[i,j]</code>是用<code>f[i,j-v[i]]+w[i]</code>来更新，那么每一层<code>i</code>循环中<code>f[j-v[i]]</code>会在<code>f[j]</code>前被计算出来，体现了物品可以重复利用</p>
<h3 id="多重背包问题I"><a href="#多重背包问题I" class="headerlink" title="多重背包问题I"></a>多重背包问题I</h3><p>原题链接：<a href="https://www.acwing.com/problem/content/4/" target="_blank" rel="noopener">Acwing4</a><br>有 N 种物品和一个容量是 V 的背包。</p>
<p>第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。</p>
<p>求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。<br>输出最大价值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = m; j &gt;= w[i];j--)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k * w[i] &lt;= j &amp;&amp; k &lt;= s[i]; k++)</span><br><span class="line">            f[j] = max(f[j], f[j - k * w[i]] + k * v[i]);</span><br></pre></td></tr></table></figure>

<p>类似于01背包问题，此方法是将所有物品的体积与价值乘以它们的可能数量加到了可选物品中，多了一层<code>O(n)</code>的循环</p>
<h3 id="多重背包问题II"><a href="#多重背包问题II" class="headerlink" title="多重背包问题II"></a>多重背包问题II</h3><p>原题链接：<a href="https://www.acwing.com/problem/content/5/" target="_blank" rel="noopener">Acwing5</a></p>
<p>有 N 种物品和一个容量是 V 的背包。</p>
<p>第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。</p>
<p>求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。<br>输出最大价值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; v &gt;&gt; w &gt;&gt; c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= c; k *= <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        c -= k;</span><br><span class="line">        t.push_back(&#123;k * v, k * w&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(c)</span><br><span class="line">        t.push_back(&#123;c * v, c * w&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> k:t)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &gt;= k.v; i--)</span><br><span class="line">        f[i] = max(f[i], f[i - k.v] + k.w);</span><br></pre></td></tr></table></figure>

<p>对多重背包问题I中的方法进行优化，此方法是将合法数量中是<code>2</code>的整数次幂的部分加入到可选物品中，再将剩余部分加入，此法将最后一层循环优化到了<code>O(logn)</code></p>
<h3 id="混合背包问题"><a href="#混合背包问题" class="headerlink" title="混合背包问题"></a>混合背包问题</h3><p>原题链接：<a href="https://www.acwing.com/problem/content/7/" target="_blank" rel="noopener">Acwing7</a><br>有 N 种物品和一个容量是 V 的背包。</p>
<p>物品一共有三类：</p>
<p>第一类物品只能用1次（01背包）；<br>第二类物品可以用无限次（完全背包）；<br>第三类物品最多只能用 si 次（多重背包）；<br>每种体积是 vi，价值是 wi。</p>
<p>求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。<br>输出最大价值。<br>si=−1 表示第 i 种物品只能用1次；<br>si=0 表示第 i 种物品可以用无限次；<br>si&gt;0 表示第 i 种物品可以使用 si 次；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; v &gt;&gt; w &gt;&gt; s;</span><br><span class="line">    <span class="keyword">if</span>(s&lt;=<span class="number">0</span>)</span><br><span class="line">        t.push_back(&#123;s, v, w&#125;);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">1</span>; c &lt;= s;c++)</span><br><span class="line">        &#123;</span><br><span class="line">            s -= c;</span><br><span class="line">            t.push_back(&#123;<span class="number">-1</span>, c * v, c * w&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s)</span><br><span class="line">            t.push_back(&#123;<span class="number">-1</span>, s * v, s * w&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> k:t)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (k.s == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = m; j &gt;= k.v;j--)</span><br><span class="line">            f[j] = max(f[j], f[j - k.v] + k.w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = k.v; j &lt;= m;j++)</span><br><span class="line">            f[j] = max(f[j], f[j - k.v] + k.w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先将多重背包的部分用II法中的二进制优化方法转化为01背包，此时便转化为01背包和完全背包相结合的问题，分情况讨论即可</p>
<h3 id="二维费用的背包问题"><a href="#二维费用的背包问题" class="headerlink" title="二维费用的背包问题"></a>二维费用的背包问题</h3><p>原题链接：<a href="https://www.acwing.com/problem/content/8/" target="_blank" rel="noopener">Acwing8</a></p>
<p>有 N 件物品和一个容量是 V 的背包，背包能承受的最大重量是 M。</p>
<p>每件物品只能用一次。体积是 vi，重量是 mi，价值是 wi。</p>
<p>求解将哪些物品装入背包，可使物品总体积不超过背包容量，总重量不超过背包可承受的最大重量，且价值总和最大。<br>输出最大价值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; v &gt;&gt; m &gt;&gt; w;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = V; j &gt;= v;j--)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = M; k &gt;= m;k--)</span><br><span class="line">        	f[j][k] = max(f[j][k], f[j - v][k - m] + w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二维的01背包问题</p>
<h3 id="分组背包问题"><a href="#分组背包问题" class="headerlink" title="分组背包问题"></a>分组背包问题</h3><p>原题链接：<a href="https://www.acwing.com/problem/content/9/" target="_blank" rel="noopener">Acwing9</a></p>
<p>有 N 组物品和一个容量是 V 的背包。</p>
<p>每组物品有若干个，同一组内的物品最多只能选一个。<br>每件物品的体积是 vij，价值是 wij，其中 i 是组号，j 是组内编号。</p>
<p>求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。</p>
<p>输出最大价值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= s;k++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v[k] &gt;&gt; w[k];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = V; j &gt;= <span class="number">0</span>;j--)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= s;k++)</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=v[k])</span><br><span class="line">                f[j] = max(f[j], f[j - v[k]] + w[k]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似01背包问题，多加一层循环枚举每一组内选取的物品即可</p>
]]></content>
      <categories>
        <category>代码模板</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>移动服务 acwing 274</title>
    <url>/2020/04/10/ac274/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/276/" target="_blank" rel="noopener">Acwing274</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>一个公司有三个移动服务员，最初分别在位置1，2，3处。</p>
<p>如果某个位置（用一个整数表示）有一个请求，那么公司必须指派某名员工赶到那个地方去。</p>
<p>某一时刻只有一个员工能移动，且不允许在同样的位置出现两个员工。</p>
<p>从 p 到 q 移动一个员工，需要花费 c(p,q)。</p>
<p>这个函数不一定对称，但保证 c(p,p)=0。</p>
<p>给出N个请求，请求发生的位置分别为 p1~pN。</p>
<p>公司必须按顺序依次满足所有请求，且过程中不能去其他额外的位置，目标是最小化公司花费，请你帮忙计算这个最小花费。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第1行有两个整数L,N，其中L是位置数量，N是请求数量，每个位置从1到L编号。</p>
<p>第2至L+1行每行包含L个非负整数，第i+1行的第j个数表示c(i,j) ，并且它小于2000。</p>
<p>最后一行包含N个整数，是请求列表。</p>
<p>一开始三个服务员分别在位置1，2，3。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个整数M，表示最小花费。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>3≤L≤200,<br>1≤N≤1000</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 9</span><br><span class="line">0 1 1 1 1</span><br><span class="line">1 0 2 3 2</span><br><span class="line">1 1 0 4 1</span><br><span class="line">2 1 5 0 1</span><br><span class="line">4 2 3 4 0</span><br><span class="line">4 2 4 1 5 4 3 2 1</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>

<h3 id="状态表示"><a href="#状态表示" class="headerlink" title="状态表示"></a>状态表示</h3><p><code>f[i][x][y]</code>表示处理完了第i个请求，三个服务员再<code>p[i]</code>,<code>x</code>,<code>y</code>三个位置的所有方案的集合<br><code>f[i][x][y]</code>的值为集合中所有方案的花费的最小值</p>
<p>这题的状态转移比较特殊，<code>f[i][x][y]</code>所依赖的状态难以枚举，但是<code>f[i][x][y]</code>的被依赖状态较容易枚举<br>1位于<code>p[i]</code>的服务员前往<code>p[i+1]</code><br>此时<code>f[i+1][x][y]=f[i][x][y]+w[p[i]][p[i+1]]</code><br>2位于<code>x</code>的服务员前往<code>p[i+1]</code><br>此时<code>f[i+1][p[i]][y]=f[i][x][y]+w[x][p[i+1]]</code><br>3位于<code>y</code>的服务员前往<code>p[i+1]</code><br>此时<code>f[i+1][x][p[i]]=f[i][x][y]+w[y][p[i+1]]</code></p>
<p>答案为<code>f[m][1...n][1...n]</code>中的最小值</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">210</span>, M = <span class="number">1010</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> w[N][N];</span><br><span class="line"><span class="keyword">int</span> f[M][N][N];</span><br><span class="line"><span class="keyword">int</span> p[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;w[i][j]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ ) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p[i]);</span><br><span class="line">	<span class="comment">//初始化p[0]=3,此时f[0][1][2]恰好为题中的初始状态</span></span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">1</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; x ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">1</span>; y &lt;= n; y ++ )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> z = p[i], v = f[i][x][y];</span><br><span class="line">                <span class="keyword">if</span> (x == y || x == z || y == z) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> u = p[i + <span class="number">1</span>];</span><br><span class="line">                f[i + <span class="number">1</span>][x][y] = min(f[i + <span class="number">1</span>][x][y], v + w[z][u]);</span><br><span class="line">                f[i + <span class="number">1</span>][z][y] = min(f[i + <span class="number">1</span>][z][y], v + w[x][u]);</span><br><span class="line">                f[i + <span class="number">1</span>][x][z] = min(f[i + <span class="number">1</span>][x][z], v + w[y][u]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; x ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">1</span>; y &lt;= n; y ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> z = p[m];</span><br><span class="line">            <span class="keyword">if</span> (x == y || x == z || y == z) <span class="keyword">continue</span>;</span><br><span class="line">            res = min(res, f[m][x][y]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>赤壁之战 acwing 297</title>
    <url>/2020/04/10/ac297/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/299/" target="_blank" rel="noopener">Acwing297</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定一个长度为N的序列A，求A有多少个长度为M的严格递增子序列。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含整数T，表示共有T组测试数据。</p>
<p>每组数据，第一行包含两个整数N和M。</p>
<p>第二行包含N个整数，表示完整的序列A。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>每组数据输出一个结果，每个结果占一行。</p>
<p>输出格式为“Case #x: y”，x为数据组别序号，从1开始，y为结果。</p>
<p>由于数据可能很大，请你输入对109+7取模后的结果。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤T≤100,<br>1≤M≤N≤1000,<br>∑Ti=1Ni×Mi≤107<br>序列中的整数的绝对值不超过109。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3 2</span><br><span class="line">1 2 3</span><br><span class="line">3 2</span><br><span class="line">3 2 1</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Case #1: 3</span><br><span class="line">Case #2: 0</span><br></pre></td></tr></table></figure>

<h3 id="状态表示"><a href="#状态表示" class="headerlink" title="状态表示"></a>状态表示</h3><p><code>f[i][j]</code>表示所有以<code>a[i]</code>结尾的，长度为<code>j</code>的递增序列的集合，<code>f[i][j]</code>的值表示集合中元素的数量<br>易得<br><code>f[i][1]=1</code><br><code>f[i][j] = ∑f[i-1][k]</code> <code>(a[k]&lt;a[i],1&lt;=k&lt;=i-1)</code></p>
<p>经观察我们发现，上述做法要加一层循环来寻找所有符合条件的<code>k</code>值，这实际上是求所有上一层循环（长度为<code>j-1</code>的序列）的符合条件的<code>k</code>值的前缀和，快速查找并动态更新前缀和，可以想到树状数组。最终的答案只与序列元素的相对大小有关，可以想到用离散化<br>此时<br><code>f[i][j]=sum(a[i]-1)</code><br>同时每次要更新长度为j-1的序列的前缀和<br><code>add(a[i],f[i][j-1])</code></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> f[N][N];</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">int</span> nums[N];</span><br><span class="line"><span class="keyword">int</span> tr[N];</span><br><span class="line"><span class="keyword">int</span> n, m, t, cnt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;x;x-=lowbit(x))</span><br><span class="line">        res = (res + tr[x]) % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= cnt; i+=lowbit(i))</span><br><span class="line">        tr[i] = (tr[i] + y) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">1</span>; c &lt;= t;c++)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">            nums[cnt++] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        sort(nums, nums + cnt);</span><br><span class="line">        cnt = unique(nums, nums + cnt) - nums;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">            a[i] = lower_bound(nums, nums + cnt, a[i]) - nums + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">            f[i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= m;len++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memset</span>(tr, <span class="number">0</span>, <span class="keyword">sizeof</span>(tr));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                f[i][len] = sum(a[i] - <span class="number">1</span>);</span><br><span class="line">                add(a[i], f[i][len - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">            res = (res + f[i][m]) % mod;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d: %d\n"</span>, c, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>炮兵阵地 acwing 292</title>
    <url>/2020/04/09/ac292/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/294/" target="_blank" rel="noopener">Acwing292</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>司令部的将军们打算在N<em>M的网格地图上部署他们的炮兵部队。一个N</em>M的地图由N行M列组成，地图的每一格可能是山地（用”H” 表示），也可能是平原（用”P”表示），如下图。</p>
<p>在每一格平原地形上最多可以布置一支炮兵部队（山地上不能够部署炮兵部队）；一支炮兵部队在地图上的攻击范围如图中黑色区域所示：</p>
<p><img src="/images/ac292.png" alt="alt"></p>
<p>如果在地图中的灰色所标识的平原上部署一支炮兵部队，则图中的黑色的网格表示它能够攻击到的区域：沿横向左右各两格，沿纵向上下各两格。</p>
<p>图上其它白色网格均攻击不到。</p>
<p>从图上可见炮兵的攻击范围不受地形的影响。</p>
<p>现在，将军们规划如何部署炮兵部队，在防止误伤的前提下（保证任何两支炮兵部队之间不能互相攻击，即任何一支炮兵部队都不在其他支炮兵部队的攻击范围内），在整个地图区域内最多能够摆放多少我军的炮兵部队。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含两个由空格分割开的正整数，分别表示N和M；</p>
<p>接下来的N行，每一行含有连续的M个字符(‘P’或者’H’)，中间没有空格。按顺序表示地图中每一行的数据。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>仅一行，包含一个整数K，表示最多能摆放的炮兵部队的数量。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>N≤100,M≤10</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 4</span><br><span class="line">PHPP</span><br><span class="line">PPHH</span><br><span class="line">PPPP</span><br><span class="line">PHPP</span><br><span class="line">PHHP</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure>

<p>如图，共5种情况</p>
<h3 id="状态表示"><a href="#状态表示" class="headerlink" title="状态表示"></a>状态表示</h3><p>由于每个状态可以影响到往下两层，所以要枚举当前行状态，上一行状态以及上上行的状态<br>同样，记录的时候也要再加一维，<code>f[i][j][k]</code>表示，放好前i行，第i行状态为<code>k</code>，第<code>i-1</code>行状态为<code>j</code>的时候，能放置的最大数量，这里的状态用二进制数来表示,用<code>u</code>表示第<code>i-2</code>行<br><code>f[i][j][k]</code>的值表示当前状态的最大值</p>
<p>合法条件</p>
<ol>
<li>当前行与前两行无交集</li>
<li>当前行已经摆放的位置不能为山地</li>
</ol>
<p>状态转移：<br><code>f[i][j][k]=max(f[i][j][k],f[i-1][u][j]+cnt[state[k]])</code></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>, M = <span class="number">10</span>, S = <span class="number">1</span> &lt;&lt; M;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> g[N];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">2</span>][S][S];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; state;</span><br><span class="line"><span class="keyword">int</span> cnt[S];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//对某一行检查是否存在某一列与前两列有交集的情况</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m;i++)</span><br><span class="line">        <span class="keyword">if</span>((s&gt;&gt;i&amp;<span class="number">1</span>)&amp;&amp;((s&gt;&gt;i+<span class="number">1</span>&amp;<span class="number">1</span>)||(s&gt;&gt;i+<span class="number">2</span>&amp;<span class="number">1</span>)))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//统计1的个数</span></span><br><span class="line">    <span class="keyword">int</span> res= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(s)</span><br><span class="line">    &#123;</span><br><span class="line">        res += s &amp; <span class="number">1</span>;</span><br><span class="line">        s &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> c;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="string">'H'</span>)</span><br><span class="line">                g[i] += <span class="number">1</span> &lt;&lt; j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//找出可以作为一行的合法状态</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; m;i++)</span><br><span class="line">        <span class="keyword">if</span>(check(i))</span><br><span class="line">        &#123;</span><br><span class="line">            state.push_back(i);</span><br><span class="line">            cnt[i] = count(i);</span><br><span class="line">        &#125;</span><br><span class="line">	<span class="comment">//为防止空间溢出，由于当前行状态仅由上一行转移，故可以用滚动数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">2</span>;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; state.size();j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; state.size();k++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; state.size();u++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> a = state[u];</span><br><span class="line">                    <span class="keyword">int</span> b = state[j];</span><br><span class="line">                    <span class="keyword">int</span> c = state[k];</span><br><span class="line">                    <span class="keyword">if</span>((a&amp;b)||(b&amp;c)||(a&amp;c))</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(g[i]&amp;c)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    f[i &amp; <span class="number">1</span>][j][k] = max(f[i&amp;<span class="number">1</span>][j][k], f[i - <span class="number">1</span> &amp; <span class="number">1</span>][u][j] + cnt[c]);</span><br><span class="line">                &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f[n+<span class="number">1</span>&amp;<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>金字塔 acwing 284</title>
    <url>/2020/04/09/ac284/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/286/" target="_blank" rel="noopener">Acwing284</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>虽然探索金字塔是极其老套的剧情，但是有一队探险家还是到了某金字塔脚下。</p>
<p>经过多年的研究，科学家对这座金字塔的内部结构已经有所了解。</p>
<p>首先，金字塔由若干房间组成，房间之间连有通道。</p>
<p>如果把房间看作节点，通道看作边的话，整个金字塔呈现一个有根树结构，节点的子树之间有序，金字塔有唯一的一个入口通向树根。</p>
<p>并且，每个房间的墙壁都涂有若干种颜色的一种。</p>
<p>探险队员打算进一步了解金字塔的结构，为此，他们使用了一种特殊设计的机器人。</p>
<p>这种机器人会从入口进入金字塔，之后对金字塔进行深度优先遍历。</p>
<p>机器人每进入一个房间（无论是第一次进入还是返回），都会记录这个房间的颜色。</p>
<p>最后，机器人会从入口退出金字塔。</p>
<p>显然，机器人会访问每个房间至少一次，并且穿越每条通道恰好两次（两个方向各一次）， 然后，机器人会得到一个颜色序列。</p>
<p>但是，探险队员发现这个颜色序列并不能唯一确定金字塔的结构。</p>
<p>现在他们想请你帮助他们计算，对于一个给定的颜色序列，有多少种可能的结构会得到这个序列。</p>
<p>因为结果可能会非常大，你只需要输出答案对109 取模之后的值。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入仅一行，包含一个字符串S，长度不超过300，表示机器人得到的颜色序列。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个整数表示答案。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ABABABA</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>
<h3 id="样例分析"><a href="#样例分析" class="headerlink" title="样例分析"></a>样例分析</h3><p><img src="/images/ac284.png" alt="alt"><br>如图，共5种情况</p>
<h3 id="状态表示"><a href="#状态表示" class="headerlink" title="状态表示"></a>状态表示</h3><p><code>f[l][r]</code>表示<code>[l,r]</code>区间内树的结构的所有可能集合<br><code>f[l][r]</code>的值表示可能值总数</p>
<p>划分方式：<br>以根节点的最后一颗子树为划分条件，将原区间划分为两个区间<br><code>[l,k]</code>用于表示前面的所有子树<br><code>[k+1,r-1]</code>用于表示最后一颗子树<br>边界:<code>f[l][r]=1  (l==r)</code></p>
<p>状态转移：当前区间的值为所有可能划分下，所有左子树可能区间与右子树可能区间的乘积之和<br><code>f[l][r]=f[l][r]+f[l][k]*f[k+1][r-1]</code></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">310</span>, mod = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line">ll f[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; str + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(str + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//如果有n个节点，那么总路径长度为2n-1，为奇数</span></span><br><span class="line">    <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">1</span>; len &lt;= n; len++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l + len - <span class="number">1</span> &lt;= n; l++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> r = l + len - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(len == <span class="number">1</span>)</span><br><span class="line">                    f[l][r] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//任意子树路径首尾必定相同</span></span><br><span class="line">                    <span class="keyword">if</span>(str[l]==str[r])</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> k = l; k &lt; r; k += <span class="number">2</span>)</span><br><span class="line">                            <span class="keyword">if</span>(str[k]==str[r])</span><br><span class="line">                                f[l][r] = (f[l][r] + f[l][k] * f[k + <span class="number">1</span>][r - <span class="number">1</span>]) % mod;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; f[<span class="number">1</span>][n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>饼干 acwing 277</title>
    <url>/2020/04/08/ac277/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/279/" target="_blank" rel="noopener">Acwing277</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>圣诞老人共有M个饼干，准备全部分给N个孩子。</p>
<p>每个孩子有一个贪婪度，第 i 个孩子的贪婪度为 g[i]。</p>
<p>如果有 a[i] 个孩子拿到的饼干数比第 i 个孩子多，那么第 i 个孩子会产生 g[i]*a[i]的怨气。</p>
<p>给定N、M和序列g，圣诞老人请你帮他安排一种分配方式，使得每个孩子至少分到一块饼干，并且所有孩子的怨气总和最小。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含两个整数N,M。</p>
<p>第二行包含N个整数表示g1~gN。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>第一行一个整数表示最小怨气总和。</p>
<p>第二行N个空格隔开的整数表示每个孩子分到的饼干数，若有多种方案，输出任意一种均可。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤N≤30,<br>N≤M≤5000,<br>1≤gi≤107</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 20</span><br><span class="line">1 2 3</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">2 9 9</span><br></pre></td></tr></table></figure>

<h3 id="状态表示"><a href="#状态表示" class="headerlink" title="状态表示"></a>状态表示</h3><p>先将小朋友按照<code>g[i]</code>的大小进行排序，由排序不等式知，排名靠前的小朋友要分配更多的饼干<br><code>f[i][j]</code>表示前i个小朋友分配了j块饼干的集合，<code>f[i][j]</code>的值表示集合里怒气值总和的最小值</p>
<p>集合的划分<br>1 我们发现由于每个小朋友的怒气值之于它的相对位置有关，故当每个小朋友的饼干数都减少一个时，不会对总怒气值产生影响，所以<br><code>f[i][j]=f[i][j-i](j&gt;=i)</code><br>2 我们将<code>f[i][j]</code>根据末尾有几个1来划分，有<code>k</code>个<code>1</code>时，怒气值的和为<br><code>f[i-k][j-k]+(s[i]-s[i-k])*(i-k)</code></p>
<p>即集合<code>f[i][j]</code>末尾有<code>0</code>个<code>1</code>时<br><code>f[i][j]=f[i][j-i](j&gt;=i)</code><br>有<code>k</code>个<code>1</code>时<br><code>f[i][j]=min(f[i-k][j-k]+(s[i]-s[i-k])*(i-k))</code></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">32</span>, M = <span class="number">5010</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line">PII g[N];</span><br><span class="line"><span class="keyword">int</span> f[N][M];</span><br><span class="line"><span class="keyword">int</span> ans[N];</span><br><span class="line"><span class="keyword">int</span> s[N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; g[i].first;</span><br><span class="line">		g[i].second = i;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(g + <span class="number">1</span>, g + <span class="number">1</span> + n);</span><br><span class="line">	reverse(g + <span class="number">1</span>, g + <span class="number">1</span> + n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		s[i] = s[i - <span class="number">1</span>] + g[i].first;</span><br><span class="line">	f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (j &gt;= i)</span><br><span class="line">				f[i][j] = f[i][j - i];</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= i &amp;&amp; k &lt;= j; k++)</span><br><span class="line">				f[i][j] = min(f[i][j], f[i - k][j - k] + (i - k)*(s[i] - s[i - k]));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; f[n][m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	h用来表示减去1的次数，结尾的饼干数为h + 1</span></span><br><span class="line"><span class="comment">	f[i][j] == f[i][j - i]时，结果是从f[i][j - i]状态转移过来</span></span><br><span class="line"><span class="comment">	直接转移回该状态</span></span><br><span class="line"><span class="comment">	f[i][j] == f[i - k][j - k] + (i - k)*(s[i] - s[i - k])时，</span></span><br><span class="line"><span class="comment">	结果也是从后者状态转移过来，直接转移回该状态，同时得知末尾有k个1，并</span></span><br><span class="line"><span class="comment">	将他们赋值为h + 1</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">int</span> i = n, j = m, h = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (i&amp;&amp;j)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (j &gt;= i &amp;&amp; f[i][j] == f[i][j - i])</span><br><span class="line">		&#123;</span><br><span class="line">			j -= i;</span><br><span class="line">			h++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= i &amp;&amp; k &lt;= j; k++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (f[i][j] == f[i - k][j - k] + (i - k)*(s[i] - s[i - k]))</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> p = k - i + <span class="number">1</span>; p &lt;= i; p++)</span><br><span class="line">						ans[g[p].second] = h + <span class="number">1</span>;</span><br><span class="line">					i -= k;</span><br><span class="line">					j -= k;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>传纸条 acwing 275</title>
    <url>/2020/04/08/ac275/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/277/" target="_blank" rel="noopener">Acwing275</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>小渊和小轩是好朋友也是同班同学，他们在一起总有谈不完的话题。</p>
<p>一次素质拓展活动中，班上同学安排坐成一个 m 行 n 列的矩阵，而小渊和小轩被安排在矩阵对角线的两端，因此，他们就无法直接交谈了。</p>
<p>幸运的是，他们可以通过传纸条来进行交流。</p>
<p>纸条要经由许多同学传到对方手里，小渊坐在矩阵的左上角，坐标(1,1)，小轩坐在矩阵的右下角，坐标(m,n)。</p>
<p>从小渊传到小轩的纸条只可以向下或者向右传递，从小轩传给小渊的纸条只可以向上或者向左传递。 </p>
<p>在活动进行中，小渊希望给小轩传递一张纸条，同时希望小轩给他回复。</p>
<p>班里每个同学都可以帮他们传递，但只会帮他们一次，也就是说如果此人在小渊递给小轩纸条的时候帮忙，那么在小轩递给小渊的时候就不会再帮忙，反之亦然。 </p>
<p>还有一件事情需要注意，全班每个同学愿意帮忙的好感度有高有低（注意：小渊和小轩的好心程度没有定义，输入时用0表示），可以用一个0-100的自然数来表示，数越大表示越好心。</p>
<p>小渊和小轩希望尽可能找好心程度高的同学来帮忙传纸条，即找到来回两条传递路径，使得这两条路径上同学的好心程度之和最大。</p>
<p>现在，请你帮助小渊和小轩找到这样的两条路径。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行有2个用空格隔开的整数 m 和 n，表示学生矩阵有 m 行 n 列。</p>
<p>接下来的 m 行是一个 m∗n 的矩阵，矩阵中第 i 行 j 列的整数表示坐在第 i 行 j 列的学生的好心程度，每行的 n 个整数之间用空格隔开。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个整数，表示来回两条路上参与传递纸条的学生的好心程度之和的最大值。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤n,m≤50</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">0 3 9</span><br><span class="line">2 8 5</span><br><span class="line">5 7 0</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">34</span><br></pre></td></tr></table></figure>

<h3 id="状态表示"><a href="#状态表示" class="headerlink" title="状态表示"></a>状态表示</h3><p><code>f[x1][y1][x2][y2]</code>表示第一个人走到了<code>(x1,y1)</code>且第二个人走到了<code>(x2,y2)</code>的状态。<br><code>f[x1][y1][x2][y2]</code>的值表示该状态下走过路径的最大和</p>
<p>1 当<code>x1==x2&amp;&amp;y1==y2</code>时，表明该状态下两人重合，故只能加一次该位置的权值</p>
<p>2 当<code>x1!=x2||y1!=y2</code>时，表明该状态下两人不重合，则分别加上两个点的权值</p>
<p>这种方法的时间复杂度将是<code>O(n^4)</code></p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>由于结尾处两人走的路径总长度是相同的，故我们只需要考虑所有两个人走的路径长度相同的状态。<br><code>f[p][x1][x2]</code>  ,其中<code>p</code>表示每个人走的路径长度，<code>x1</code>和<code>x2</code>分别表示两个人的横坐标，若<code>p==2||p==n+m||x1==x2</code>，此时两人重合，否则不重合，状态更新方式与未优化方法相同<br>优化后时间复杂度为<code>O(n^3)</code></p>
<h3 id="原始代码"><a href="#原始代码" class="headerlink" title="原始代码"></a>原始代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">51</span>;</span><br><span class="line"><span class="keyword">int</span> f[N][N][N][N];</span><br><span class="line"><span class="keyword">int</span> a[N][N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> x1=<span class="number">1</span>;x1&lt;=n;x1++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> y1=<span class="number">1</span>;y1&lt;=m;y1++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> x2=<span class="number">1</span>;x2&lt;=n;x2++)</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> y2 = <span class="number">1</span>; y2 &lt;= m; y2++)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span> (x1 == x2 &amp;&amp; y1 == y2)</span><br><span class="line">					&#123;</span><br><span class="line">						f[x1][y1][x2][y2] = max(f[x1][y1][x2][y2], f[x1][y1 - <span class="number">1</span>][x2 - <span class="number">1</span>][y2] + a[x1][y1]);</span><br><span class="line">						f[x1][y1][x2][y2] = max(f[x1][y1][x2][y2], f[x1 - <span class="number">1</span>][y1][x2 - <span class="number">1</span>][y2] + a[x1][y1]);</span><br><span class="line">						f[x1][y1][x2][y2] = max(f[x1][y1][x2][y2], f[x1 - <span class="number">1</span>][y1][x2][y2 - <span class="number">1</span>] + a[x1][y1]);</span><br><span class="line">						f[x1][y1][x2][y2] = max(f[x1][y1][x2][y2], f[x1][y1 - <span class="number">1</span>][x2][y2 - <span class="number">1</span>] + a[x1][y1]);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span></span><br><span class="line">					&#123;</span><br><span class="line">						f[x1][y1][x2][y2] = max(f[x1][y1][x2][y2], f[x1 - <span class="number">1</span>][y1][x2 - <span class="number">1</span>][y2] + a[x1][y1] + a[x2][y2]);</span><br><span class="line">						f[x1][y1][x2][y2] = max(f[x1][y1][x2][y2], f[x1][y1 - <span class="number">1</span>][x2 - <span class="number">1</span>][y2] + a[x1][y1] + a[x2][y2]);</span><br><span class="line">						f[x1][y1][x2][y2] = max(f[x1][y1][x2][y2], f[x1 - <span class="number">1</span>][y1][x2][y2 - <span class="number">1</span>] + a[x1][y1] + a[x2][y2]);</span><br><span class="line">						f[x1][y1][x2][y2] = max(f[x1][y1][x2][y2], f[x1][y1 - <span class="number">1</span>][x2][y2 - <span class="number">1</span>] + a[x1][y1] + a[x2][y2]);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; f[n][m][n][m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="优化代码"><a href="#优化代码" class="headerlink" title="优化代码"></a>优化代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">51</span>;</span><br><span class="line"><span class="keyword">int</span> f[N * <span class="number">2</span>][N][N];</span><br><span class="line"><span class="keyword">int</span> a[N][N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">2</span>; p &lt;= n + m; p++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> x1=max(p-m,<span class="number">1</span>);x1&lt;=min(p<span class="number">-1</span>,n);x1++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> x2 = max(p - m, <span class="number">1</span>); x2 &lt;= min(p - <span class="number">1</span>, n); x2++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> t = a[x1][p - x1];</span><br><span class="line">				<span class="keyword">if</span> (x1 != x2 &amp;&amp; p != <span class="number">2</span> &amp;&amp; p != n + m)</span><br><span class="line">					t += a[x2][p - x2];</span><br><span class="line">				f[p][x1][x2] = max(f[p][x1][x2], f[p<span class="number">-1</span>][x1][x2] + t);</span><br><span class="line">				f[p][x1][x2] = max(f[p][x1][x2], f[p<span class="number">-1</span>][x1 - <span class="number">1</span>][x2] + t);</span><br><span class="line">				f[p][x1][x2] = max(f[p][x1][x2], f[p<span class="number">-1</span>][x1][x2 - <span class="number">1</span>] + t);</span><br><span class="line">				f[p][x1][x2] = max(f[p][x1][x2], f[p<span class="number">-1</span>][x1 - <span class="number">1</span>][x2 - <span class="number">1</span>] + t);</span><br><span class="line">			&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; f[n + m][n][n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>蒙德里安的梦想 acwing 291</title>
    <url>/2020/04/08/ac291/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/293/" target="_blank" rel="noopener">Acwing291</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>求把N<em>M的棋盘分割成若干个1</em>2的的长方形，有多少种方案。</p>
<p>例如当N=2，M=4时，共有5种方案。当N=2，M=3时，共有3种方案。</p>
<p>如下图所示：</p>
<p><img src="/images/ac291.png" alt="alt"></p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入包含多组测试用例。</p>
<p>每组测试用例占一行，包含两个整数N和M。</p>
<p>当输入用例N=0，M=0时，表示输入终止，且该用例无需处理。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>每个测试用例输出一个结果，每个结果占一行。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤N,M≤11</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">2 2</span><br><span class="line">2 3</span><br><span class="line">2 4</span><br><span class="line">2 11</span><br><span class="line">4 11</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">144</span><br><span class="line">51205</span><br></pre></td></tr></table></figure>

<h3 id="状态表示"><a href="#状态表示" class="headerlink" title="状态表示"></a>状态表示</h3><p>本题等价于找到所有横着放的<code>1 X 2</code>小方格方案数，因为一旦横着放的小方格数量确定之后，竖着放的方案也一定是唯一的</p>
<p><code>f[i][j]</code>表示第<code>i</code>列的第<code>j</code>个状态。<code>j</code>状态用二进制数表示，如果<code>j</code>中的第<code>t</code>位是<code>1</code>，表示第<code>i-1</code>列的第<code>t</code>行有一个横着放的小方格。<br>状态转移方程为 <code>f[i][j]+=f[i-1][k]</code>, 本列的每一个状态都是由上一列的合法方案转移过来的</p>
<p>转移条件<br>1 第<code>i</code>列和第<code>i-1</code>列不能有矩形出现在同一行<br>2 本列的被捅出来的状态<code>j</code>和上一列被捅出来的状态<code>k</code>求或，可以得知上一列是否有连续的奇数个空格子，如果有，则不合法<br>3 初始化<code>f[0][0]=1</code> 第<code>0</code>列没有前一列，不会有矩形捅出来。<br>4 输出结果为<code>f[m][0]</code> 第<code>m</code>列(最后一列的后一列)不被前一列的任何矩形捅出来，表明前面以及填满</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">12</span>, M = <span class="number">1</span> &lt;&lt; N;</span><br><span class="line"><span class="keyword">int</span> st[M];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[N][M];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &amp;&amp; (n || m))&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n; i ++)&#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            st[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">                <span class="keyword">if</span> (i &gt;&gt; j &amp; <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (cnt &amp; <span class="number">1</span>) st[i] = <span class="literal">false</span>; <span class="comment">// cnt 为当前已经存在多少个连续的0</span></span><br><span class="line">                    cnt = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> cnt ++;</span><br><span class="line">            <span class="keyword">if</span> (cnt &amp; <span class="number">1</span>) st[i] = <span class="literal">false</span>; <span class="comment">// 扫完后要判断一下最后一段有多少个连续的0</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1</span> &lt;&lt; n; j ++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">1</span> &lt;&lt; n; k ++)</span><br><span class="line">                    <span class="keyword">if</span> ((j &amp; k) == <span class="number">0</span> &amp;&amp; (st[j | k])) </span><br><span class="line">                    <span class="comment">// j &amp; k == 0 表示 i 列和 i - 1列同一行不同时捅出来</span></span><br><span class="line">                    <span class="comment">// st[j | k] == 1 表示 在 i 列状态 j， i - 1 列状态 k 的情况下是合法的.</span></span><br><span class="line">                        f[i][j] += f[i - <span class="number">1</span>][k];      </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; f[m][<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>石子合并 acwing 282</title>
    <url>/2020/04/08/ac282/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/284/" target="_blank" rel="noopener">Acwing282</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>设有N堆石子排成一排，其编号为1，2，3，…，N。</p>
<p>每堆石子有一定的质量，可以用一个整数来描述，现在要将这N堆石子合并成为一堆。</p>
<p>每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同。</p>
<p>例如有4堆石子分别为 1 3 5 2， 我们可以先合并1、2堆，代价为4，得到4 5 2， 又合并 1，2堆，代价为9，得到9 2 ，再合并得到11，总代价为4+9+11=24；</p>
<p>如果第二步是先合并2，3堆，则代价为7，得到4 7，最后一次合并代价为11，总代价为4+7+11=22。</p>
<p>问题是：找出一种合理的方法，使总的代价最小，输出最小代价。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行一个数N表示石子的堆数N。</p>
<p>第二行N个数，表示每堆石子的质量(均不超过1000)。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个整数，表示最小代价。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤N≤300</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">1 3 5 2</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">22</span><br></pre></td></tr></table></figure>

<h3 id="状态表示"><a href="#状态表示" class="headerlink" title="状态表示"></a>状态表示</h3><p><code>f[l][r]</code> 表示区间<code>[l,r]</code>内合并所有石子的集合<br><code>f[l][r]</code> 的值表示集合中元素的最小值</p>
<p>集合的划分： 以两区间的合并位置为划分条件，枚举所有可能的合并点</p>
<p>状态方程 <code>f[l][r]=min(f[l][r],f[l][k]+f[k+1][r]+s[r]-s[l-1])</code></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">310</span>;</span><br><span class="line"><span class="keyword">int</span> f[N][N];</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">int</span> s[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		s[i] = s[i - <span class="number">1</span>] + a[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= n; len++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l + len - <span class="number">1</span> &lt;= n; l++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> r = l + len - <span class="number">1</span>;</span><br><span class="line">			f[l][r] = <span class="number">1e9</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = l; k &lt; r; k++)</span><br><span class="line">				f[l][r] = min(f[l][r], f[l][k] + f[k + <span class="number">1</span>][r] + s[r] - s[l - <span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; f[<span class="number">1</span>][n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>最长公共上升子序列 acwing 272</title>
    <url>/2020/04/07/ac272/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/274/" target="_blank" rel="noopener">Acwing272</a></p>
<a id="more"></a>
<p>最长公共子序列：<a href="https://www.acwing.com/problem/content/899/" target="_blank" rel="noopener">Acwing897</a></p>
<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>熊大妈的奶牛在小沐沐的熏陶下开始研究信息题目。</p>
<p>小沐沐先让奶牛研究了最长上升子序列，再让他们研究了最长公共子序列，现在又让他们研究最长公共上升子序列了。</p>
<p>小沐沐说，对于两个数列A和B，如果它们都包含一段位置不一定连续的数，且数值是严格递增的，那么称这一段数是两个数列的公共上升子序列，而所有的公共上升子序列中最长的就是最长公共上升子序列了。</p>
<p>奶牛半懂不懂，小沐沐要你来告诉奶牛什么是最长公共上升子序列。</p>
<p>不过，只要告诉奶牛它的长度就可以了。</p>
<p>数列A和B的长度均不超过3000。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含一个整数N，表示数列A，B的长度。</p>
<p>第二行包含N个整数，表示数列A。</p>
<p>第三行包含N个整数，表示数列B。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个整数，表示最长公共子序列的长度</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤N≤3000,序列中的数字均不超过231−1</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">2 2 1 3</span><br><span class="line">2 1 2 3</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>

<h3 id="状态表示"><a href="#状态表示" class="headerlink" title="状态表示"></a>状态表示</h3><p><code>f[i][j]</code>为所有 <code>a[1~i]</code>和<code>b[1~j]</code>且以<code>b[j]</code>结尾的公共上升序列<br><code>f[i][j]</code>表示集合中的最大值</p>
<p>对此，我们分两种情况讨论<br>1.. <code>f[i][j]</code>不包含 <code>a[i]</code> , 此时集合 <code>f[i][j]</code>等价于 集合<code>f[i-1][j]</code></p>
<p>2.. <code>f[i][j]</code>包含了<code>a[i]</code>, 此时集合<code>f[i][j]</code>的值将被更新,此时应当枚举所有<code>a[1~i-1]</code>且以<code>b[1~j-1]</code>结尾的集合，即枚举<code>f[i-1][1~j-1]</code><br>若倒数第二数是以<code>j-1</code>结尾的，那么<code>f[i][j]=f[i-1][j-1]+1</code><br>若倒数第二数是以<code>j-2</code>结尾的，那么<code>f[i][j]=f[i-1][j-2]+1</code><br>…</p>
<p>这种方法的时间复杂度将是<code>O(n^3)</code></p>
<h3 id="优化一"><a href="#优化一" class="headerlink" title="优化一"></a>优化一</h3><p>经过观察我们发现，每次的<code>maxv</code>是满足<code>a[i]&gt;b[k]</code>的<code>f[i-1][k]+1</code>的前缀最大值，因此我们可以将<code>maxv</code>直接提到第一层循环的外面，这样时间复杂度将会降为<code>O(n^2)</code></p>
<h3 id="优化二"><a href="#优化二" class="headerlink" title="优化二"></a>优化二</h3><p>分析状态转移方程可知<code>f[i][j]</code>都是由<code>f[i-1][j]</code>得来的，因此可以优化空间，设<code>f[i]</code>代表的是<code>a</code>序列前<code>i</code>个元素与b序列的<code>LCIS</code>长度，<code>t</code>为最长<code>LCIS</code>的结尾元素位置</p>
<h3 id="原始代码"><a href="#原始代码" class="headerlink" title="原始代码"></a>原始代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3010</span>;</span><br><span class="line"><span class="keyword">int</span> dp[N][N];</span><br><span class="line"><span class="keyword">int</span> a[N], b[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; b[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">			<span class="keyword">if</span> (a[i] == b[j])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> maxv = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= j - <span class="number">1</span>; k++)</span><br><span class="line">					<span class="keyword">if</span> (b[k] &lt; b[j])</span><br><span class="line">						res = max(dp[i - <span class="number">1</span>][k] + <span class="number">1</span>, maxv);</span><br><span class="line">				dp[i][j] = max(dp[i][j], maxv);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		res = max(res, dp[n][i]);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="优化一-1"><a href="#优化一-1" class="headerlink" title="优化一"></a>优化一</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3010</span>;</span><br><span class="line"><span class="keyword">int</span> dp[N][N];</span><br><span class="line"><span class="keyword">int</span> a[N], b[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; b[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> maxv = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">			<span class="keyword">if</span> (a[i] == b[j])</span><br><span class="line">				dp[i][j] = max(dp[i][j], maxv);</span><br><span class="line">			<span class="keyword">if</span> (b[j] &lt; a[i])</span><br><span class="line">				res = max(dp[i - <span class="number">1</span>][j] + <span class="number">1</span>, maxv);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		res = max(res, dp[n][i]);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优化二-1"><a href="#优化二-1" class="headerlink" title="优化二"></a>优化二</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3010</span>;</span><br><span class="line"><span class="keyword">int</span> dp[N];</span><br><span class="line"><span class="keyword">int</span> a[N], b[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; b[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (a[i] == b[j])</span><br><span class="line">				dp[j] = dp[t] + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (b[j] &lt; a[i] &amp;&amp; dp[j] &gt; dp[t])</span><br><span class="line">				t = j;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		res = max(res, dp[i]);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>LCS</code>(最长公共子序列)<br><code>f[i][j]=f[i-1][j-1]+1  (a[i]=a[j])</code><br><code>f[i][j]=max(f[i][j-1],f[i-1][j])  (a[i]!=a[j])</code><br>其中，<code>f[i][j]</code>为<code>a</code>序列的前<code>i</code>个元素和<code>b</code>序列的前<code>j</code>个元素的<code>LCS</code>长度</p>
<p><code>LIS</code>(最长上升子序列)<br><code>f[i] = max f[j]+1(a[j]&lt;a[i],j&lt;i)</code><br>f[i]为以第i个元素结尾的LISLIS长度。</p>
<p><code>LCIS</code>(最长公共上升子序列)<br><code>f[i][j]=f[i-1][j](a[i]!=b[j])</code><br><code>f[i][j]=max(f[i-1][j],f[i-1][t]+1) (a[i]=b[j])</code><br><code>f[i][j]</code>代表的是<code>a</code>序列前<code>i</code>个元素与<code>b</code>序列前<code>j</code>个元素的<code>LCIS</code>长度，<code>t</code>为最长<code>LCIS</code>的结尾元素位置</p>
<p>优化<br><code>f[i]=f[t]+1(a[i]=b[j])</code><br><code>f[i]</code>代表的是<code>a</code>序列前<code>i</code>个元素与<code>b</code>序列的<code>LCIS</code>长度，<code>t</code>为最长<code>LCIS</code>的结尾元素位置</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树的基本操作</title>
    <url>/2020/03/28/segmenttree/</url>
    <content><![CDATA[<p>线段树的创建、单点修改、查询</p>
<a id="more"></a>

<h3 id="线段树的创建"><a href="#线段树的创建" class="headerlink" title="线段树的创建"></a>线段树的创建</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> l, r;</span><br><span class="line">	<span class="keyword">int</span> dat;</span><br><span class="line">&#125;t[SIZE * <span class="number">4</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	t[p].l = l;</span><br><span class="line">	t[p].r = r;</span><br><span class="line">	<span class="keyword">if</span> (l == r)</span><br><span class="line">	&#123;</span><br><span class="line">		t[p].dat = a[l];</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	build(p * <span class="number">2</span>, l, mid);</span><br><span class="line">	build(p * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">	t[p].dat = max(t[p * <span class="number">2</span>].dat, t[p * <span class="number">2</span> + <span class="number">1</span>].dat);</span><br><span class="line">&#125;</span><br><span class="line">bulid(<span class="number">1</span>, <span class="number">1</span>, n);</span><br></pre></td></tr></table></figure>
<h3 id="线段树的单点修改"><a href="#线段树的单点修改" class="headerlink" title="线段树的单点修改"></a>线段树的单点修改</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (t[p].l == t[p].r)</span><br><span class="line">	&#123;</span><br><span class="line">		t[p].dat = v;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid = t[p].l + t[p].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (x &lt;= mid)</span><br><span class="line">		change(p * <span class="number">2</span>, x, v);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		change(p * <span class="number">2</span> + <span class="number">1</span>, x, v);</span><br><span class="line">	t[p].dat = max(t[p * <span class="number">2</span>].dat, t[p * <span class="number">2</span> + <span class="number">1</span>].dat);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">change(<span class="number">1</span>, x, v);</span><br></pre></td></tr></table></figure>

<h3 id="线段树的查询"><a href="#线段树的查询" class="headerlink" title="线段树的查询"></a>线段树的查询</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (t[p].l &gt;= l &amp;&amp; t[p].r &lt;= r)</span><br><span class="line">		<span class="keyword">return</span> t[p].dat;</span><br><span class="line">	<span class="keyword">int</span> mid = t[p].l + t[p].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> val = -(<span class="number">1</span> &lt;&lt; <span class="number">30</span>);</span><br><span class="line">	<span class="keyword">if</span> (l &lt;= mid)</span><br><span class="line">		val = max(val, ask(p * <span class="number">2</span>, l, r));</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		val = max(val, ask(p * <span class="number">2</span> + <span class="number">1</span>, l, r));</span><br><span class="line">	<span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ask(<span class="number">1</span>, l, r);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>代码模板</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>银河英雄传说 acwing 238</title>
    <url>/2020/03/25/ac238/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/240/" target="_blank" rel="noopener">Acwing238</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>有一个划分为N列的星际战场，各列依次编号为1,2,…,N。</p>
<p>有N艘战舰，也依次编号为1,2,…,N,其中第i号战舰处于第i列。</p>
<p>有T条指令，每条指令格式为以下两种之一：</p>
<p>1、M i j，表示让第i号战舰所在列的全部战舰保持原有顺序，接在第j号战舰所在列的尾部。</p>
<p>2、C i j，表示询问第i号战舰与第j号战舰当前是否处于同一列中，如果在同一列中，它们之间间隔了多少艘战舰。</p>
<p>现在需要你编写一个程序，处理一系列的指令。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含整数T，表示共有T条指令。</p>
<p>接下来T行，每行一个指令，指令有两种形式：M i j或C i j。</p>
<p>其中M和C为大写字母表示指令类型，i和j为整数，表示指令涉及的战舰编号。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>你的程序应当依次对输入的每一条指令进行分析和处理：</p>
<p>如果是M i j形式，则表示舰队排列发生了变化，你的程序要注意到这一点，但是不要输出任何信息；</p>
<p>如果是C i j形式，你的程序要输出一行，仅包含一个整数，表示在同一列上，第i号战舰与第j号战舰之间布置的战舰数目，如果第i号战舰与第j号战舰当前不在同一列上，则输出-1。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>N≤30000,T≤500000</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">M 2 3</span><br><span class="line">C 1 2</span><br><span class="line">M 2 4</span><br><span class="line">C 4 2</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-1</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>1.并查集的存储<br>使用一个数组fa保存父节点（根的父节点设为自己）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> fa[SIZE];</span><br></pre></td></tr></table></figure>

<p>2.并查集的初始化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) fa[i]=i;</span><br></pre></td></tr></table></figure>
<p>3.并查集的get操作<br>若x是树根，则x就是集合代表，否则递归访问fa[x]直至根节点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==fa[x]) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">return</span> fa[x]=get(fa[x]);<span class="comment">//路径压缩</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.并查集的Merge操作<br>合并元素x和元素y所在的集合，等价于让x的树根作为y的树根的子节点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	fa[get(x)]=get(y)l</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">30010</span>;</span><br><span class="line"><span class="comment">//fa数组用于存储根节点</span></span><br><span class="line"><span class="comment">//d数组用于存储当前元素在当前列中前面元素的个数</span></span><br><span class="line"><span class="comment">//siz数组用于存储当前列元素的个数</span></span><br><span class="line"><span class="keyword">int</span> fa[N], d[N], siz[N];</span><br><span class="line"><span class="keyword">int</span> i, j, t;</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x == fa[x])</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">int</span> root = get(fa[x]);</span><br><span class="line">	d[x] += d[fa[x]];</span><br><span class="line">	fa[x] = root;</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x = get(x);</span><br><span class="line">	y = get(y);</span><br><span class="line">	fa[x] = y;</span><br><span class="line">	d[x] = siz[y];</span><br><span class="line">	siz[y] += siz[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		fa[i] = i;</span><br><span class="line">		siz[i] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%c%d%d"</span>, &amp;c, &amp;i, &amp;j);</span><br><span class="line">		getchar();</span><br><span class="line">		<span class="keyword">if</span> (c == <span class="string">'M'</span>)</span><br><span class="line">			merge(i, j);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (get(i) == get(j))</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="built_in">fabs</span>(d[i] - d[j]) - <span class="number">1</span>;<span class="comment">//之间的元素不包含本身</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">"-1"</span>;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>楼兰图腾 acwing 241</title>
    <url>/2020/03/25/ac241/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/243/" target="_blank" rel="noopener">Acwing241</a></p>
<a id="more"></a>
<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>在完成了分配任务之后，西部314来到了楼兰古城的西部。</p>
<p>相传很久以前这片土地上(比楼兰古城还早)生活着两个部落，一个部落崇拜尖刀(‘V’)，一个部落崇拜铁锹(‘∧’)，他们分别用V和∧的形状来代表各自部落的图腾。</p>
<p>西部314在楼兰古城的下面发现了一幅巨大的壁画，壁画上被标记出了N个点，经测量发现这N个点的水平位置和竖直位置是两两不同的。</p>
<p>西部314认为这幅壁画所包含的信息与这N个点的相对位置有关，因此不妨设坐标分别为(1,y1),(2,y2),…,(n,yn),其中y1~yn是1到n的一个排列。<br>西部314打算研究这幅壁画中包含着多少个图腾。<br>如果三个点(i,yi),(j,yj),(k,yk)满足1 ≤ i &lt; j &lt; k ≤ n且yi &gt; yj,yj &lt; yk，则称这三个点构成V图腾;<br>如果三个点(i,yi),(j,yj),(k,yk)满足1 ≤ i &lt; j &lt; k ≤ n且yi &lt; yj,yj &gt; yk，则称这三个点构成∧图腾;<br>西部314想知道，这n个点中两个部落图腾的数目。</p>
<p>因此，你需要编写一个程序来求出V的个数和∧的个数。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行一个数n。</p>
<p>第二行是n个数，分别代表y1，y2,…,yn。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>两个数，中间用空格隔开，依次为V的个数和∧的个数。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于所有数据，n≤200000,且输出答案不会超过int64。<br>y1∼yn 是 1 到 n 的一个排列。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1 5 3 2 4</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 4</span><br></pre></td></tr></table></figure>

<h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h3><p>树状数组是一种基于二进制分解思想的数据结构，其基本用途是维护序列的前缀和。<br>对于给定的序列a，我们建立一个数组c，其中c[x]保存序列a的区间<br>[x-lowbit(x)+1,x]中所有数的和</p>
<p>该数据结构满足一下性质：<br>1.每个内部检点c[x]保以它位根的子树中所有叶节点的和。<br>2.每个内部节点c[x]的子节点个数等于lowbit(x)的位数。<br>3.除树根外，每个内部节点c[x]的父节点是c[x+lowbit(x)]。<br>4.树的深度为O(log N)。</p>
<p>树状数组支持的两个基本操作</p>
<p>1.查询前缀和<br>若要计算[l,r]中的和，只需计算<code>ask(r)-ask(l-1)</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (; x; x -= lowbit(x))</span><br><span class="line">		ans += c[x];</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.单点增加：给序列中的一个数 <code>a[x]</code> 加上一个<code>y</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (; x &lt;= n; x += lowbit(x))</span><br><span class="line">		c[x] += y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>左右各遍历一次数组，并计算出每个元素左右比它大的元素的个数即可</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) x&amp;(-x)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line">ll a[N], c[N], l[N], r[N];</span><br><span class="line">ll n, resl, resr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(ll x, ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (; x &lt;= n; x += lowbit(x))</span><br><span class="line">		c[x] += y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">ask</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (; x; x -= lowbit(x))</span><br><span class="line">		ans += c[x];</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">counts</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//每个元素的权值为1</span></span><br><span class="line">		<span class="comment">//ask(a[i])表示在它左边的元素（也就是比它小的元素）的个数</span></span><br><span class="line">		<span class="comment">//ask(n)表示已经插入的总元素个数</span></span><br><span class="line">		l[i] = ask(n) - ask(a[i]);</span><br><span class="line">		add(a[i], <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span>(c));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		r[i] = ask(n) - ask(a[i]);</span><br><span class="line">		add(a[i], <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>); </span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">	counts();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		resl += l[i] * r[i];</span><br><span class="line">		resr += (i - <span class="number">1</span> - l[i])*(n - i - r[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; resl &lt;&lt; <span class="string">" "</span> &lt;&lt; resr &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>免费馅饼 HDU1176</title>
    <url>/2020/03/22/HDU1176/</url>
    <content><![CDATA[<p>原题链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1176" target="_blank" rel="noopener">HDU1176</a></p>
<a id="more"></a>
<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>都说天上不会掉馅饼，但有一天gameboy正走在回家的小径上，忽然天上掉下大把大把的馅饼。说来gameboy的人品实在是太好了，这馅饼别处都不掉，就掉落在他身旁的10米范围内。馅饼如果掉在了地上当然就不能吃了，所以gameboy马上卸下身上的背包去接。但由于小径两侧都不能站人，所以他只能在小径上接。由于gameboy平时老呆在房间里玩游戏，虽然在游戏中是个身手敏捷的高手，但在现实中运动神经特别迟钝，每秒种只有在移动不超过一米的范围内接住坠落的馅饼。<br>为了使问题简化，假设在接下来的一段时间里，馅饼都掉落在0-10这11个位置。开始时gameboy站在5这个位置，因此在第一秒，他只能接到4,5,6这三个位置中其中一个位置上的馅饼。问gameboy最多可能接到多少个馅饼？（假设他的背包可以容纳无穷多个馅饼）</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入数据有多组。每组数据的第一行为以正整数n(0&lt; n &lt;100000)，表示有n个馅饼掉在这条小径上。在结下来的n行中，每行有两个整数x,T(0&lt;T&lt;100000),表示在第T秒有一个馅饼掉在x点上。同一秒钟在同一点上可能掉下多个馅饼。n=0时输入结束。</p>
<p>n=0表示数据结束。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>每一组输入数据对应一行输出。输出一个整数m，表示gameboy最多可能接到m个馅饼。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">5 1</span><br><span class="line">4 1</span><br><span class="line">6 1</span><br><span class="line">7 2</span><br><span class="line">7 2</span><br><span class="line">8 3</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>

<h3 id="dp"><a href="#dp" class="headerlink" title="dp"></a>dp</h3><p>首先记录每一秒的掉落情况<br>dp[t][x] 为第t秒在x出所能获得的最的馅饼数量<br>转移方程为:<br>dp[t][x]  += max3(dp[t+1][x],dp[t+1][x-1],dp[t+1][x+1]);</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">100010</span>][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> x, t, T;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n, n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; t;</span><br><span class="line">			f[t][x]++;</span><br><span class="line">			T = max(T, t);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = T; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">10</span>; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">"?"</span> &lt;&lt; f[<span class="number">3</span>][<span class="number">-1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">"!="</span> &lt;&lt; f[i + <span class="number">1</span>][j - <span class="number">1</span>]&lt;&lt;<span class="string">"  i="</span>&lt;&lt;i&lt;&lt;<span class="string">"  j-1="</span>&lt;&lt;j<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">				f[i][j] += max(max(f[i + <span class="number">1</span>][j], f[i + <span class="number">1</span>][j - <span class="number">1</span>]), f[i + <span class="number">1</span>][j + <span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; f[<span class="number">0</span>][<span class="number">5</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>P1496 火烧赤壁</title>
    <url>/2020/03/22/P1494/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.luogu.com.cn/problem/P1496" target="_blank" rel="noopener">P1496</a></p>
<a id="more"></a>
<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>曹操平定北方以后，公元 208 年，率领大军南下，进攻刘表。他的人马还没有到荆州，刘表已经病死。他的儿子刘琮听到曹军声势浩大，吓破了胆，先派人求降了。</p>
<p>孙权任命周瑜为都督，拨给他三万水军，叫他同刘备协力抵抗曹操。</p>
<p>隆冬的十一月，天气突然回暖，刮起了东南风。</p>
<p>没想到东吴船队离开北岸大约二里距离，前面十条大船突然同时起火。火借风势，风助火威。十条火船，好比十条火龙一样，闯进曹军水寨。那里的船舰，都挤在一起，又躲不开，很快地都烧起来。一眨眼工夫，已经烧成一片火海。</p>
<p>曹操气急败坏的把你找来，要你钻入火海把连环线上着火的船只的长度统计出来！</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行一个整数 NN。<br>以后 NN 行，每行两个数：Ai, Bi<br>表示连环线上着火船只的起始位置和终点。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出着火船只的总长度。保证答案在 32 位带符号整数的表示范围内。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">-1 1</span><br><span class="line">5 11</span><br><span class="line">2 9</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure>

<h3 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h3><p>先将所有的坐标全都加入一个新的数组中去，再对其进行离散化</p>
<p>因左端点一定先于右端点出现，任意区间左端点数&gt;=右端点数<br>遍历数组，若某一段内<br>左端点数&gt;右端点数      下一段有效<br>左端点数=右端点数      下一段无效</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, l[<span class="number">30000</span>], r[<span class="number">30000</span>], x[<span class="number">40010</span>], add[<span class="number">40010</span>];</span><br><span class="line"><span class="keyword">int</span> cnt, temp, res;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; l[i] &gt;&gt; r[i];</span><br><span class="line">		x[++cnt] = l[i];</span><br><span class="line">		x[++cnt] = r[i];</span><br><span class="line">	&#125;</span><br><span class="line">	sort(x + <span class="number">1</span>, x + <span class="number">1</span> + cnt);</span><br><span class="line">	<span class="comment">//unique函数用于将有序数组的非重复元素取出并放在前面</span></span><br><span class="line">	<span class="comment">//返回值为最后一个非重复元素的地址</span></span><br><span class="line">	cnt = unique(x + <span class="number">1</span>, x + <span class="number">1</span> + n) - (x + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//lower_bound(起始地址，结束地址，要查找的数值) 返回的是数值 第一个 出现的位置。</span></span><br><span class="line">		<span class="comment">//upper_bound(起始地址，结束地址，要查找的数值) 返回的是数值 最后一个 出现的位置。</span></span><br><span class="line">		<span class="comment">//binary_search(起始地址，结束地址，要查找的数值)  返回的是是否存在这么一个数，是一个bool值。</span></span><br><span class="line">		<span class="keyword">int</span> ll = lower_bound(x + <span class="number">1</span>, x + cnt + <span class="number">1</span>, l[i]) - x;</span><br><span class="line">		<span class="keyword">int</span> rr = lower_bound(x + <span class="number">1</span>, x + cnt + <span class="number">1</span>, r[i]) - x;</span><br><span class="line">		add[ll]++;</span><br><span class="line">		add[rr]--;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		temp += add[i];</span><br><span class="line">		<span class="keyword">if</span> (temp &gt; <span class="number">0</span>)</span><br><span class="line">			res += (x[i + <span class="number">1</span>] - x[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title>离散化</title>
    <url>/2020/03/22/lisanhua/</url>
    <content><![CDATA[<p>离散化的两种方法</p>
<a id="more"></a>



<h3 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h3><p>1.用辅助数组存下离散的数据<br>2.排序<br>3.去重<br>4.放回原数组</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> lsh[MAXN] , cnt , num[MAXN] , n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;num[i]);</span><br><span class="line">	lsh[i] = num[i];	</span><br><span class="line">&#125;</span><br><span class="line">sort(lsh+<span class="number">1</span> , lsh+n+<span class="number">1</span>);</span><br><span class="line"><span class="comment">//unique函数用于将数组中所有不重复的元素取出放在前面</span></span><br><span class="line"><span class="comment">//返回值为最后一个不重复元素的地址</span></span><br><span class="line">cnt = unique(lsh+<span class="number">1</span> , lsh+n+<span class="number">1</span>) - lsh - <span class="number">1</span>;</span><br><span class="line"><span class="comment">//lower_bound(起始地址，结束地址，要查找的数值) 返回的是数值 第一个 出现的位置。</span></span><br><span class="line"><span class="comment">//upper_bound(起始地址，结束地址，要查找的数值) 返回的是数值 最后一个 出现的位置。</span></span><br><span class="line"><span class="comment">//binary_search(起始地址，结束地址，要查找的数值)  返回的是是否存在这么一个数，是一个bool值。</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">	num[i] = lower_bound(lsh+<span class="number">1</span> , lsh+cnt+<span class="number">1</span> , num[i]) - lsh;</span><br></pre></td></tr></table></figure>
<p>注意事项：<br>1.去重并不是把数组中的元素删除，而是将重复的元素方法数组末尾<br>2.二分的范围是离散化后的区间</p>
<h3 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h3><p>1.排序<br>2.枚举放回原数组</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> data , id;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> data &lt; a.data;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Node num[MAXN];</span><br><span class="line"><span class="keyword">int</span> rank[MAXN] , n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;num[i].data);</span><br><span class="line">	num[i].id = i;</span><br><span class="line">&#125;</span><br><span class="line">sort(num+<span class="number">1</span> , num+n+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">	rank[num[i].id] = i;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title>饭卡 HDU2546</title>
    <url>/2020/03/22/HDU2546/</url>
    <content><![CDATA[<p>原题链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2546" target="_blank" rel="noopener">HDU2546</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>电子科大本部食堂的饭卡有一种很诡异的设计，即在购买之前判断余额。如果购买一个商品之前，卡上的剩余金额大于或等于5元，就一定可以购买成功（即使购买后卡上余额为负），否则无法购买（即使金额足够）。所以大家都希望尽量使卡上的余额最少。<br>某天，食堂中有n种菜出售，每种菜可购买一次。已知每种菜的价格以及卡上的余额，问最少可使卡上的余额为多少。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>多组数据。对于每组数据：<br>第一行为正整数n，表示菜的数量。n&lt;=1000。<br>第二行包括n个正整数，表示每种菜的价格。价格不超过50。<br>第三行包括一个正整数m，表示卡上的余额。m&lt;=1000。</p>
<p>n=0表示数据结束。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>对于每组输入,输出一行,包含一个整数，表示卡上可能的最小余额。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">50</span><br><span class="line">5</span><br><span class="line">10</span><br><span class="line">1 2 3 2 1 1 2 3 2 1</span><br><span class="line">50</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-45</span><br><span class="line">32</span><br></pre></td></tr></table></figure>

<h3 id="dp"><a href="#dp" class="headerlink" title="dp"></a>dp</h3><p>对数据从小到大排序，在不考虑最大元素的情况下求出m-5的余额能购买的最大值。 结果为 m - max(f[j]) - a[n] </p>
<p>特判m&lt;5的情况</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n, n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">		<span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">		<span class="keyword">if</span> (m &lt; <span class="number">5</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; m &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		sort(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = m - <span class="number">5</span>; j &gt;= a[i]; j--)</span><br><span class="line">				f[j] = max(f[j], f[j - a[i]] + a[i]);</span><br><span class="line">		<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m - <span class="number">5</span>; j++)</span><br><span class="line">			res = max(res, f[j]);</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; m-res-a[n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>滑雪 P1434</title>
    <url>/2020/03/21/P1434/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.luogu.com.cn/problem/P1434" target="_blank" rel="noopener">P1434</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>Michael 喜欢滑雪。这并不奇怪，因为滑雪的确很刺激。可是为了获得速度，滑的区域必须向下倾斜，而且当你滑到坡底，你不得不再次走上坡或者等待升降机来载你。Michael 想知道在一个区域中最长的滑坡。区域由一个二维数组给出。数组的每个数字代表点的高度。下面是一个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1   2   3   4   5</span><br><span class="line">16  17  18  19  6</span><br><span class="line">15  24  25  20  7</span><br><span class="line">14  23  22  21  8</span><br><span class="line">13  12  11  10  9</span><br></pre></td></tr></table></figure>

<p>一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度会减小。在上面的例子中，一条可行的滑坡为 24－17－16－1（从 2424 开始，在 11 结束）。当然 25－24－23－…－3－2－1 更长。事实上，这是最长的一条。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入的第一行为表示区域的二维数组的行数 RR 和列数 CC。下面是 RR 行，每行有 CC 个数，代表高度(两个数字之间用 11 个空格间隔)。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出区域中最长滑坡的长度。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤R,C≤100</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 5</span><br><span class="line">1  2  3  4  5</span><br><span class="line">16 17 18 19 6</span><br><span class="line">15 24 25 20 7</span><br><span class="line">14 23 22 21 8</span><br><span class="line">13 12 11 10 9</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">25</span><br></pre></td></tr></table></figure>

<h3 id="记忆化dfs"><a href="#记忆化dfs" class="headerlink" title="记忆化dfs"></a>记忆化dfs</h3><p>如果某一个点搜过了，那么下一次经过这个点时直接取之前搜索得到的结果即可</p>
<h3 id="直接搜索代码："><a href="#直接搜索代码：" class="headerlink" title="直接搜索代码："></a>直接搜索代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="keyword">int</span> moves[<span class="number">4</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125; &#125;;</span><br><span class="line"><span class="keyword">int</span> r, c;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> nx = x + moves[i][<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">int</span> ny = y + moves[i][<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span> (nx &gt;= <span class="number">1</span> &amp;&amp; nx &lt;= r &amp;&amp; ny &gt;= <span class="number">1</span> &amp;&amp; ny &lt;= c &amp;&amp; a[nx][ny] &gt; a[x][y])</span><br><span class="line">		&#123;</span><br><span class="line">			res = max(res, dfs(nx, ny));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	res++;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; r &gt;&gt; c;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= r; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= c; j++)</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= r; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= c; j++)</span><br><span class="line">			res=max(dfs(i, j),res);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<h3 id="记忆化搜索代码："><a href="#记忆化搜索代码：" class="headerlink" title="记忆化搜索代码："></a>记忆化搜索代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="keyword">int</span> moves[<span class="number">4</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125; &#125;;</span><br><span class="line"><span class="keyword">int</span> r, c;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (dp[x][y]) <span class="keyword">return</span> dp[x][y];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> nx = x + moves[i][<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">int</span> ny = y + moves[i][<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span> (nx &gt;= <span class="number">1</span> &amp;&amp; nx &lt;= r &amp;&amp; ny &gt;= <span class="number">1</span> &amp;&amp; ny &lt;= c &amp;&amp; a[nx][ny] &gt; a[x][y])</span><br><span class="line">		&#123;</span><br><span class="line">			dp[x][y] = max(dp[x][y], dfs(nx, ny));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	dp[x][y]++;</span><br><span class="line">	<span class="keyword">return</span> dp[x][y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; r &gt;&gt; c;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= r; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= c; j++)</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= r; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= c; j++)</span><br><span class="line">			res=max(dfs(i, j),res);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>记忆化</tag>
      </tags>
  </entry>
  <entry>
    <title>VS2017使用scanf()读取字符串</title>
    <url>/2020/03/21/scanf-s/</url>
    <content><![CDATA[<p>scanf_s()函数的第三个参数</p>
<a id="more"></a>


<p>vs2017上无法使用scanf()函数，但是提供了scanf_s()函数，在使用scanf_s()读取二维数组时遇到了以下问题</p>
<p>代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> dt[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">	scanf_s(<span class="string">"%s"</span>, dt[i]);</span><br></pre></td></tr></table></figure>
<p>在读取字符串时，读完第一行程序就崩溃了</p>
<p>解决方法</p>
<p>给scanf_s函数制定一个参数，告诉编译器预留多大的空间来存储字符串sizeof()或直接给定一个数字大小，够用就可以。<br>代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> dt[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">	scanf_s(<span class="string">"%s"</span>, dt[i], <span class="keyword">sizeof</span>(dt[<span class="number">0</span>]));</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>最大的和 acwing 126</title>
    <url>/2020/03/20/ac126/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/128/" target="_blank" rel="noopener">Acwing126</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定一个包含整数的二维矩阵，子矩形是位于整个阵列内的任何大小为1 * 1或更大的连续子阵列。</p>
<p>矩形的总和是该矩形中所有元素的总和。</p>
<p>在这个问题中，具有最大和的子矩形被称为最大子矩形。</p>
<p>例如，下列数组：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 -2 -7 0 </span><br><span class="line">9 2 -6 2 </span><br><span class="line">-4 1 -4 1 </span><br><span class="line">-1 8 0 -2</span><br></pre></td></tr></table></figure>
<p>其最大子矩形为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9 2 </span><br><span class="line">-4 1 </span><br><span class="line">-1 8</span><br></pre></td></tr></table></figure>
<p>它拥有最大和15</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入中将包含一个N<em>N的整数数组。<br>第一行只输入一个整数N，表示方形二维数组的大小。<br>从第二行开始，输入N</em>N个整数</p>
<p>数组中的数字会保持在[-127,127]的范围内。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个整数，代表最大子矩形的总和。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤N≤100</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">0 -2 -7 0</span><br><span class="line">9 2 -6 2</span><br><span class="line">-4 1 -4 1 </span><br><span class="line">-1 8 0 -2</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">15</span><br></pre></td></tr></table></figure>

<h3 id="贪心-前缀和"><a href="#贪心-前缀和" class="headerlink" title="贪心/前缀和"></a>贪心/前缀和</h3><p>思路一：二维前缀和，枚举起点和终点，因起点与终点各需要两个变量表示，故时间复杂度为o(N^4)</p>
<p>思路二：对每一列求出一维前缀和，再枚举矩形的上下界，得到每一列的和，再用贪心的方法求出对于每一个上下界，矩形面积的最大值，时间复杂度O(N^3)</p>
<h3 id="法一："><a href="#法一：" class="headerlink" title="法一："></a>法一：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> a[N][N], s[N][N], n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line">			s[i][j] = s[i - <span class="number">1</span>][j] + s[i][j - <span class="number">1</span>] - s[i - <span class="number">1</span>][j - <span class="number">1</span>] + a[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> p = i; p &lt;= n; p++)</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> q = j; q &lt;= n; q++)</span><br><span class="line">					res = max(res, s[p][q] - s[p][j - <span class="number">1</span>] - s[i - <span class="number">1</span>][q] + s[i - <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<h3 id="法二："><a href="#法二：" class="headerlink" title="法二："></a>法二：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> a[N][N], s[N][N], n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">int</span> maxv = <span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line">			<span class="comment">//求出每一列的前缀和</span></span><br><span class="line">			s[i][j] = s[i - <span class="number">1</span>][j] + a[i][j];</span><br><span class="line">			maxv = max(a[i][j], maxv);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (maxv &lt;= <span class="number">0</span>)<span class="comment">//若矩阵元素全部为非正，则直接输出最大值</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; maxv &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> tans = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> temp = s[j][k] - s[i - <span class="number">1</span>][k];<span class="comment">//得到每一列的和</span></span><br><span class="line">				tans += temp;</span><br><span class="line">				<span class="keyword">if</span> (tans &lt; <span class="number">0</span>) tans = <span class="number">0</span>;<span class="comment">//贪心</span></span><br><span class="line">				ans = max(ans, tans);</span><br><span class="line">			&#125;</span><br><span class="line">			res = max(res, ans);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵 acwing 156</title>
    <url>/2020/03/20/ac156/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/158/" target="_blank" rel="noopener">Acwing156</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定一个M行N列的01矩阵（只包含数字0或1的矩阵），再执行Q次询问，每次询问给出一个A行B列的01矩阵，求该矩阵是否在原矩阵中出现过。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行四个整数M,N,A,B。</p>
<p>接下来一个M行N列的01矩阵，数字之间没有空格。</p>
<p>接下来一个整数Q。</p>
<p>接下来Q个A行B列的01矩阵，数字之间没有空格。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>对于每个询问，输出1表示出现过，0表示没有出现过。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>A≤100，M,N,B≤1000，Q≤1000</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 3 2 2</span><br><span class="line">111</span><br><span class="line">000</span><br><span class="line">111</span><br><span class="line">3</span><br><span class="line">11</span><br><span class="line">00</span><br><span class="line">11</span><br><span class="line">11</span><br><span class="line">00</span><br><span class="line">11</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h3 id="二维字符串哈希"><a href="#二维字符串哈希" class="headerlink" title="二维字符串哈希"></a>二维字符串哈希</h3><p>原思路：<br>1.先将每一行字符串哈希<br>2.分别将原矩阵中每个A<em>B的矩阵哈希并插入set（自动删除相同元素）中<br>3.在set中查找询问的值<br>acwing运行时间4000ms<br>改进思路：<br>1.先将每一行字符串哈希<br>2.将询问的值插入到set中<br>3.分别将原矩阵每个A</em>B的矩阵哈希的哈希值从set中删除<br>4.set中查找询问的值<br>acwing运行时间1000ms</p>
<p>后者与前者相比，set中的元素少了很多。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>, P = <span class="number">131</span>;</span><br><span class="line">ull hashv[N][N], p[N*N];</span><br><span class="line"><span class="keyword">int</span> m, n, a, b, q;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="function">ull <span class="title">calc</span><span class="params">(ull h[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;m, &amp;n, &amp;a, &amp;b);</span><br><span class="line">	p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m * n; i++)</span><br><span class="line">		p[i] = p[i - <span class="number">1</span>] * P;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)<span class="comment">//计算每一行hash</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>, str + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">			hashv[i][j] = hashv[i][j - <span class="number">1</span>] * P + str[j] - <span class="string">'0'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">unordered_set</span> &lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line">	<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; V;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line">	<span class="keyword">while</span> (q--)<span class="comment">//读取查询元素并将其插入set</span></span><br><span class="line">	&#123;</span><br><span class="line">		ull s = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%s"</span>, str + <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= b; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				s = s * P + str[j] - <span class="string">'0'</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		S.insert(s);</span><br><span class="line">		V.push_back(s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = b; i &lt;= n; i++)<span class="comment">//计算每个子矩阵值并将其从set中删除</span></span><br><span class="line">	&#123;</span><br><span class="line">		ull s = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> l = i - b + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> r = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			s = s * p[b] + calc(hashv[j], l, r);</span><br><span class="line">			<span class="keyword">if</span> (j &gt; a) s -= calc(hashv[j - a], l, r)*p[a*b];</span><br><span class="line">			<span class="keyword">if</span> (j &gt;= a) S.erase(s);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V.size(); i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, S.count(V[i]) ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title>树形地铁系统 acwing 157</title>
    <url>/2020/03/20/ac157/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/159/" target="_blank" rel="noopener">Acwing157</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>一些主要城市拥有树形的地铁系统，即在任何一对车站之间，有且只有一种方式可以乘坐地铁。</p>
<p>此外，这些城市大多数都有一个中央车站。</p>
<p>想象一下，你是一名在拥有树形地铁系统的城市游玩的游客，你想探索该城市完整的地铁线路。</p>
<p>你从中央车站出发，随机选择一条地铁线，然后乘坐地铁行进。</p>
<p>每次到达一个车站，你都将选择一条尚未乘坐过的地铁线路进行乘坐。</p>
<p>如果不存在未乘坐过的线路，则退回到上一个车站，再做选择。</p>
<p>直到你将所有地铁线路都乘坐过两次（往返各一次），此时你将回到中央车站。</p>
<p>之后，你以一种特殊的方式回忆自己的坐车过程，你将你的完整地铁乘坐路线编码为一个二进制字符串。</p>
<p>其中0编码表示你乘坐地铁线路到达距离中央车站更远的一站，1编码表示你乘坐地铁线路到达距离中央车站更近的一站。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行输入一个正整数n，代表测试用例数量。</p>
<p>每个测试用例由两行组成，每行输入一个由字符“0”和“1”构成的字符串，长度最多为3000， 两个字符串都描述了一种树形地铁系统的正确探索路线。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>对于每个测试用例，如果两个字符串描述的探索路线可以视为同一个地铁系统的两种探索路线，则输出same。</p>
<p>否则，输出different。</p>
<p>每行输出一个结果</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">0010011101001011</span><br><span class="line">0100011011001011</span><br><span class="line">0100101100100111</span><br><span class="line">0011000111010101</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">same</span><br><span class="line">different</span><br></pre></td></tr></table></figure>

<h3 id="树的最小表示"><a href="#树的最小表示" class="headerlink" title="树的最小表示"></a>树的最小表示</h3><p>题意：给定n组数据，每个数据表示两个dfs序列，0表示向下走，1表示向上走，问这两棵树是不是同构的</p>
<p>判断方式：求出每个树的最小表示，即与这棵树同构的最小dfs序。如果这两棵树同构，那么它们的最小表示应该相同</p>
<p>求树的最小表示可以递归实现，求出所有子树的dfs序，然后从小到大排序拼接</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> &amp;seq, <span class="keyword">int</span> &amp;u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u++;<span class="comment">//去掉开头的字符0</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;seqs;</span><br><span class="line">	<span class="keyword">while</span> (seq[u] == <span class="string">'0'</span>) </span><br><span class="line">	    seqs.push_back(dfs(seq, u));</span><br><span class="line">	u++;<span class="comment">//去掉结尾的字符1</span></span><br><span class="line">	sort(seqs.begin(), seqs.end());</span><br><span class="line">	<span class="built_in">string</span> res;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;s : seqs) res += s;</span><br><span class="line">	res = <span class="string">'0'</span> + res + <span class="string">'1'</span>; </span><br><span class="line">	<span class="comment">//首尾分别加0和1避免了边界的考虑</span></span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">	<span class="keyword">while</span> (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">string</span> a, b;</span><br><span class="line">		<span class="keyword">int</span> ua = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> ub = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">		a = <span class="string">'0'</span> + a + <span class="string">'1'</span>;</span><br><span class="line">		b = <span class="string">'0'</span> + b + <span class="string">'1'</span>;</span><br><span class="line">		<span class="keyword">if</span> (dfs(a, ua) == dfs(b, ub))</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"same"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"different"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>树的最小表示</tag>
      </tags>
  </entry>
  <entry>
    <title>滑动窗口 acwing 154</title>
    <url>/2020/03/19/ac154/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/156/" target="_blank" rel="noopener">Acwing154</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定一个大小为n≤10^6的数组。</p>
<p>有一个大小为k的滑动窗口，它从数组的最左边移动到最右边。</p>
<p>您只能在窗口中看到k个数字。</p>
<p>每次滑动窗口向右移动一个位置。</p>
<p>以下是一个例子：</p>
<p>该数组为[1 3 -1 -3 5 3 6 7]，k为3。</p>
<table>
<thead>
<tr>
<th>窗口位置</th>
<th align="center">最小值</th>
<th align="center">最大值</th>
</tr>
</thead>
<tbody><tr>
<td>[1 3 -1] -3 5 3 6 7</td>
<td align="center">-1</td>
<td align="center">3</td>
</tr>
<tr>
<td>1 [3 -1 -3] 5 3 6 7</td>
<td align="center">-3</td>
<td align="center">3</td>
</tr>
<tr>
<td>1 3 [-1 -3 5] 3 6 7</td>
<td align="center">-3</td>
<td align="center">5</td>
</tr>
<tr>
<td>1 3 -1 [-3 5 3] 6 7</td>
<td align="center">-3</td>
<td align="center">5</td>
</tr>
<tr>
<td>1 3 -1 -3 [5 3 6] 7</td>
<td align="center">3</td>
<td align="center">6</td>
</tr>
<tr>
<td>1 3 -1 -3 5 [3 6 7]</td>
<td align="center">3</td>
<td align="center">7</td>
</tr>
</tbody></table>
<p>您的任务是确定滑动窗口位于每个位置时，窗口中的最大值和最小值。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入包含两行。</p>
<p>第一行包含两个整数n和k，分别代表数组长度和滑动窗口的长度。</p>
<p>第二行有n个整数，代表数组的具体数值。</p>
<p>同行数据之间用空格隔开。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出包含两个。</p>
<p>第一行输出，从左至右，每个位置滑动窗口中的最小值。</p>
<p>第二行输出，从左至右，每个位置滑动窗口中的最大值。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>n≤10^6</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8 3</span><br><span class="line">1 3 -1 -3 5 3 6 7</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-1 -3 -3 -3 3 3</span><br><span class="line">3 3 5 5 6 7</span><br></pre></td></tr></table></figure>

<h3 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3><p>观察后易发现，若a[i] &gt;= a[j] &amp;&amp;i &lt; j，那么此后必然不会再取a[i]作为最小值了，所以可以将a[i]从队列中删掉，这样队列中的元素是单调递增的，且每个元素只进队出队各一次，时间复杂度为O(n)</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1000010</span>];</span><br><span class="line"><span class="built_in">deque</span>&lt;intq, p;</span><br><span class="line"><span class="keyword">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> n, k;</span><br><span class="line">	<span class="built_in">cin</span> &gt;n &gt;k;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		<span class="built_in">cin</span> &gt;a[i];</span><br><span class="line">	<span class="keyword">int</span> head = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (q.size() &amp;&amp; q.front() + k - <span class="number">1</span> &lt; i)</span><br><span class="line">			q.pop_front();<span class="comment">//若超出范围，则将队头弹出</span></span><br><span class="line">		<span class="keyword">while</span> (q.size() &amp;&amp; a[i] &lt;= a[q.back()])</span><br><span class="line">			q.pop_back();<span class="comment">//保证队列内单调递增</span></span><br><span class="line">		q.push_back(i);</span><br><span class="line">		<span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>)</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; a[q.front()] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (p.size() &amp;&amp; p.front() + k - <span class="number">1</span> &lt; i)</span><br><span class="line">			p.pop_front();</span><br><span class="line">		<span class="keyword">while</span> (p.size() &amp;&amp; a[i] &gt;= a[p.back()])</span><br><span class="line">			p.pop_back();</span><br><span class="line">		p.push_back(i);</span><br><span class="line">		<span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>)</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; a[p.front()] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title>Sunday算法</title>
    <url>/2020/03/19/sunday/</url>
    <content><![CDATA[<p>sunday字符串匹配算法</p>
<a id="more"></a>


<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SundayMatch</span><span class="params">(<span class="built_in">string</span> str, <span class="built_in">string</span> patten)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len1 = str.length();</span><br><span class="line">	<span class="keyword">int</span> len2 = patten.length();</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">map</span>[<span class="number">100000</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">map</span>[i] = <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len2; i++) &#123;<span class="comment">//如果有相同的，保存最后出现的index</span></span><br><span class="line">		<span class="built_in">map</span>[patten[i]] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1 - len2 + <span class="number">1</span>;) &#123;</span><br><span class="line">		<span class="keyword">int</span> j = <span class="number">0</span>;<span class="comment">//每次跳完后j都是0</span></span><br><span class="line">		<span class="keyword">while</span> (j &lt; len2) &#123;</span><br><span class="line">			<span class="keyword">if</span> (str[i] == patten[j]) &#123;</span><br><span class="line">				i++;</span><br><span class="line">				j++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;  <span class="comment">//一遇到不匹配就往后跳</span></span><br><span class="line">				<span class="keyword">int</span> index = i + len2 - j;<span class="comment">//跳到不重合的第一个字符，index表示它的位置</span></span><br><span class="line">				<span class="keyword">char</span> p = str[index];</span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">map</span>[p] == <span class="number">-1</span>) &#123;   <span class="comment">//如果str中没有这个字符i直接跳</span></span><br><span class="line">					i = index + <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					i = index - <span class="built_in">map</span>[p];<span class="comment">//对齐，把i移动到对齐后的位置</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//cout &lt;&lt; "j=" &lt;&lt; j &lt;&lt; "  len2=" &lt;&lt; len2 &lt;&lt; endl;</span></span><br><span class="line">		<span class="keyword">if</span> (j == len2) &#123;</span><br><span class="line">			<span class="keyword">return</span> i - len2;<span class="comment">//匹配成功后j停留在尾端，和头相差len2的距离</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> a, b;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; SundayMatch(a, b) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>代码模板</category>
      </categories>
  </entry>
  <entry>
    <title>网站</title>
    <url>/2020/03/18/changyongwz/</url>
    <content><![CDATA[<p>有用网站</p>
<a id="more"></a>

<p>1 视频片头动画模板 <!--`https://panzoid.com/`--><a href="https://panzoid.com/" target="_blank" rel="noopener">https://panzoid.com/</a></p>
<p>2 在线抠图 <!--`https://www.remove.bg/`--><a href="https://www.remove.bg/" target="_blank" rel="noopener">https://www.remove.bg/</a></p>
<p>3 字体下载 <!--`https://www.zitijia.com/`--><a href="https://www.zitijia.com/" target="_blank" rel="noopener">https://www.zitijia.com/</a></p>
<p>4 p站 （二次元插画网站）<!--` https://www.pixiv.net/`--><a href="https://www.pixiv.net/" target="_blank" rel="noopener">https://www.pixiv.net/</a></p>
<p>5 论文下载 <!--`https://www.cn-ki.net/`--><a href="https://www.cn-ki.net/" target="_blank" rel="noopener">https://www.cn-ki.net/</a></p>
<p>6 文档格式在线转换 <!--`https://smallpdf.com/`--><a href="https://smallpdf.com/" target="_blank" rel="noopener">https://smallpdf.com/</a></p>
<p>7 录屏投屏 <!--`http://web.airdroid.com/`--><a href="http://web.airdroid.com/" target="_blank" rel="noopener">http://web.airdroid.com/</a></p>
<p>8 各大网站热榜 <!--`https://tophub.today/`--><a href="https://tophub.today/" target="_blank" rel="noopener">https://tophub.today/</a></p>
<p>9 超清图片壁纸 <!--`https://www.pexels.com/`--><a href="https://www.pexels.com/" target="_blank" rel="noopener">https://www.pexels.com/</a></p>
<p>10 找网站的网站 <!--`http://www.addog.vip/`--><a href="http://www.addog.vip/" target="_blank" rel="noopener">http://www.addog.vip/</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>最长异或值路径 acwing 144</title>
    <url>/2020/03/17/ac144/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/146/" target="_blank" rel="noopener">Acwing144</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定一个树，树上的边都具有权值。</p>
<p>树中一条路径的异或长度被定义为路径上所有边的权值的异或和</p>
<p>给定上述的具有n个节点的树，你能找到异或长度最大的路径吗？</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含整数n，表示树的节点数目。</p>
<p>接下来n-1行，每行包括三个整数u，v，w，表示节点u和节点v之间有一条边权重为w。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个整数，表示异或长度最大的路径的最大异或和。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤n≤100000,<br>0≤u,v,w&lt; n<br>0≤w&lt;2^31</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">0 1 3</span><br><span class="line">1 2 4</span><br><span class="line">1 3 6</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure>

<h3 id="trie-数组模拟邻接表"><a href="#trie-数组模拟邻接表" class="headerlink" title="trie + 数组模拟邻接表"></a>trie + 数组模拟邻接表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">首先，由异或的性质易知，树上任意两点路径上所有点的异或值等于这两个点分别到根节点的路径的异或值相异或</span><br><span class="line"></span><br><span class="line">之后，用数组模拟邻接表的方式模拟出题中的数据结构，并遍历一遍，统计出每个节点到根节点路径的异或值</span><br><span class="line"></span><br><span class="line">最后，问题转化为了上一题，用同样的方法求解即可</span><br></pre></td></tr></table></figure>


<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>, M=<span class="number">3000000</span>;</span><br><span class="line"><span class="keyword">int</span> a[N], f[M][<span class="number">2</span>], n, idx;</span><br><span class="line"><span class="keyword">int</span> h[N], e[N*<span class="number">2</span>], c[N*<span class="number">2</span>], ne[N*<span class="number">2</span>], cnt;</span><br><span class="line"><span class="comment">//无向图所以为N*2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	e[cnt] = v, c[cnt] = w, ne[cnt] = h[u], h[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> father, <span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	a[u] = sum;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> j = e[i];</span><br><span class="line">		<span class="keyword">if</span> (j != father) dfs(j, u, sum^c[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> &amp;s = f[p][x &gt;&gt; i &amp; <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span> (!s) s = ++idx;</span><br><span class="line">		p = s;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>, p = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> t = x &gt;&gt; i &amp; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (f[p][!t])</span><br><span class="line">		&#123;</span><br><span class="line">			res += (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">			p = f[p][!t];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			p = f[p][t];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> u, v, w;</span><br><span class="line">	<span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span>(h));</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">		add(u, v, w);</span><br><span class="line">		add(v, u, w);</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">		insert(a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		res = max(res, query(a[i]));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>trie</tag>
      </tags>
  </entry>
  <entry>
    <title>最大异或对 acwing 143</title>
    <url>/2020/03/17/ac143/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/145/" target="_blank" rel="noopener">Acwing143</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>在给定的N个整数A1，A2……AN中选出两个进行xor（异或）运算，得到的结果最大是多少？</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行输入一个整数N。</p>
<p>第二行输入N个整数A1～AN。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个整数表示答案。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤N≤105,<br>0≤Ai&lt;2^31</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 2 3</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<h3 id="trie"><a href="#trie" class="headerlink" title="trie"></a>trie</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">将所有整数插入到trie中，再自高位向低位查询，优先选择与当前位不同的路径</span><br></pre></td></tr></table></figure>


<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100100</span>, M=<span class="number">3000000</span>;</span><br><span class="line"><span class="keyword">int</span> a[N], f[M][<span class="number">2</span>], n, idx;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">30</span>; ~i ; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> &amp;s = f[p][x &gt;&gt; i &amp; <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span> (!s) s = ++idx;</span><br><span class="line">		p = s;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>, p = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">30</span>; ~i; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> t = x &gt;&gt; i &amp; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (f[p][!t])</span><br><span class="line">		&#123;</span><br><span class="line">			res += (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">			p = f[p][!t];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			p = f[p][t];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">		insert(a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		res = max(res, query(a[i]));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>trie</tag>
      </tags>
  </entry>
  <entry>
    <title>前缀统计 acwing 142</title>
    <url>/2020/03/17/ac142/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/144/" target="_blank" rel="noopener">Acwing142</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定N个字符串S1,S2…SN，接下来进行M次询问，每次询问给定一个字符串T，求S1～SN中有多少个字符串是T的前缀。</p>
<p>输入字符串的总长度不超过106，仅包含小写字母。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行输入两个整数N，M。</p>
<p>接下来N行每行输入一个字符串Si。</p>
<p>接下来M行每行一个字符串T用以询问。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>对于每个询问，输出一个整数表示答案。</p>
<p>每个答案占一行。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 2</span><br><span class="line">ab</span><br><span class="line">bc</span><br><span class="line">abc</span><br><span class="line">abc</span><br><span class="line">efg</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<h3 id="trie"><a href="#trie" class="headerlink" title="trie"></a>trie</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">先将前N个字符串插入到字典树trie中，再将后M个字符串逐一查询</span><br></pre></td></tr></table></figure>


<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500000</span>, M = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> son[N][<span class="number">26</span>], cnt[N], idx;</span><br><span class="line"><span class="keyword">char</span> str[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> s = str[i] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][s]) son[p][s] = ++ idx;</span><br><span class="line">        p = son[p][s];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p] ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> s = str[i] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][s]) <span class="keyword">break</span>;</span><br><span class="line">        p = son[p][s];</span><br><span class="line">        res += cnt[p];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, str);</span><br><span class="line">        insert();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, str);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, search());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>trie</tag>
      </tags>
  </entry>
  <entry>
    <title>分级 acwing 273</title>
    <url>/2020/03/16/ac273/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/275/" target="_blank" rel="noopener">Acwing273</a></p>
<a id="more"></a>
]]></content>
  </entry>
  <entry>
    <title>mysql</title>
    <url>/2020/03/11/mysql/</url>
    <content><![CDATA[<p>MySQL基础内容</p>
<a id="more"></a>
<h1 id="MySQL-学习笔记"><a href="#MySQL-学习笔记" class="headerlink" title="MySQL 学习笔记"></a>MySQL 学习笔记</h1><h3 id="登录和退出MySQL服务器"><a href="#登录和退出MySQL服务器" class="headerlink" title="登录和退出MySQL服务器"></a>登录和退出MySQL服务器</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 登录MySQL</span></span><br><span class="line">$ mysql -u root -p12345612</span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出MySQL数据库服务器</span></span><br><span class="line">exit;</span><br></pre></td></tr></table></figure>

<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 显示所有数据库</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">databases</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建数据库</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> <span class="keyword">test</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 切换数据库</span></span><br><span class="line"><span class="keyword">use</span> <span class="keyword">test</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 显示数据表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> pet (</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    owner <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    species <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    sex <span class="built_in">CHAR</span>(<span class="number">1</span>),</span><br><span class="line">    birth <span class="built_in">DATE</span>,</span><br><span class="line">    death <span class="built_in">DATE</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看数据表结构</span></span><br><span class="line"><span class="comment">-- describe pet;</span></span><br><span class="line">desc pet;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询表</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">from</span> pet;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> pet <span class="keyword">VALUES</span> (<span class="string">'puffball'</span>, <span class="string">'Diane'</span>, <span class="string">'hamster'</span>, <span class="string">'f'</span>, <span class="string">'1990-03-30'</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改数据</span></span><br><span class="line"><span class="keyword">UPDATE</span> pet <span class="keyword">SET</span> <span class="keyword">name</span> = <span class="string">'squirrel'</span> <span class="keyword">where</span> owner = <span class="string">'Diane'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除数据</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> pet <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'squirrel'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除表</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> myorder;</span><br></pre></td></tr></table></figure>

<h3 id="建表约束"><a href="#建表约束" class="headerlink" title="建表约束"></a>建表约束</h3><h3 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h3>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>html1</title>
    <url>/2020/02/19/html1/</url>
    <content><![CDATA[<p>HTML基础内容</p>
<a id="more"></a>
<h1 id="HTML笔记"><a href="#HTML笔记" class="headerlink" title="HTML笔记"></a>HTML笔记</h1><h3 id="HTML基础部分"><a href="#HTML基础部分" class="headerlink" title="HTML基础部分"></a>HTML基础部分</h3><h6 id="HTML-Hypertext-Markup-Language-超文本标记语言"><a href="#HTML-Hypertext-Markup-Language-超文本标记语言" class="headerlink" title="HTML(Hypertext Markup Language 超文本标记语言)"></a>HTML(Hypertext Markup Language 超文本标记语言)</h6><p> 网页大致可以分为结构（HTML）表现（CSS）行为 (JS)<br> 元素和标签是一样的，元素就是标签，标签就是元素。</p>
<p><strong>1.基础元素</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>[1]<br> doctype元素: h5文档声明，该网页是按照后<br>标准来写的</p>
</li>
<li><p>[2]<br>根元素<br>lang=en表示语言是英文的</p>
</li>
<li><p>[3]<br>头元素<br>meta元素：提供多字访问，源数据<br>charset元素：修改编码<br>title元素：标题，不会显示但会被搜索引擎检索</p>
</li>
<li><p>[4]<br>body元素 内容都在body元素中输入，面向对象的，网页中可以输出<br>标签可以嵌套，但是不可以交叉嵌套</p>
</li>
<li><p>[5]<br>单位：px，百分比，em<br>其中百分比是相对其父元素的百分比</p>
</li>
</ul>
<p><strong>2.body元素</strong></p>
<ul>
<li>h1元素:一级标题，重要性仅次于title标签，字体最大(有h2-h6)</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>世界如此美好<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/html1.png" alt="alt"></p>
<ul>
<li>p标签：表示一个段落，独占一行</li>
<li>i标签：斜体</li>
<li>b标签：粗体</li>
<li>small标签：用来表示细则，小字</li>
<li>em元素： 斜体（强调语气）</li>
<li>strong元素：粗体（强调内容）<br>H5中规定，对于不需要着重的内容而是单纯的加粗或者是斜体<br>就可以用b标签和i标签表示</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>a<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">b</span>&gt;</span>lalala<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">b</span>&gt;</span>lalala<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>cite标签（表示参考的内容）</li>
<li>q标签（表示一个短的引用 即行内引用，q标签引用的内容，浏览器默认会加上引号）</li>
<li>blockquote标签（表示一个长引用即块级引用 ）</li>
<li>sup标签（表示上标）</li>
<li>sup标签（表示下标）</li>
<li>del标签（表示一个删除的内容，del标签中的内容，会自己添加删除线）</li>
<li>ins标签（ins内容会自动添加下划线）</li>
<li>需要页面中直接编写一些代码，pre是一个预格式标签，会将代码的格式保存，不会忽略多个空格，code专门用来表示代码，我们一般结合使用pre和code来表示一段代码</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>赵薇<span class="tag">&lt;<span class="name">sup</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"500294514.jpg"</span>&gt;</span>[1]<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">sup</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>H<span class="tag">&lt;<span class="name">sub</span>&gt;</span>2<span class="tag">&lt;/<span class="name">sub</span>&gt;</span>O<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">del</span>&gt;</span>19.99<span class="tag">&lt;/<span class="name">del</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">            16.66</span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/html2.png" alt="alt"></p>
<ul>
<li>实体（一些特殊元素不能使用，例如大于号之类的，因为与标签冲突，所以一般用一些特殊符号表示，这些特殊符号称为实体，又叫转义字符串）<br>&lt; &amp;lt； &gt; &amp;gt； 空格 &amp;nbsp； 版权符号：&amp;copy；</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    a<span class="symbol">&amp;gt;</span>b</span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    a<span class="symbol">&amp;lt;</span>b</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/html3.png" alt="alt"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="symbol">&amp;copy;</span>爱冒险的梦</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/html4.png" alt="alt"></p>
<ul>
<li>a标签：构成超链接,后面href属性代表所链接的url；有target属性，又分为blank属性和self属性；blank属性:构成的url点击后以新的窗口打开。self属性即默认属性，就是在当前网页中进行打开url。（超链接可以用#做占位符，可以跳转到顶部 ）</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"500294514.jpg"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span>选这个<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>table 元素（表格元素）<br>tr元素 ：代表着表格中的一行；可以嵌套着td元素，代表着一个单元格<br>th元素：标题，字体加粗，且居中<br>border属性：边框属性，但是不推荐使用，后面可以跟1px，代表着1像素。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"1px"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>AAA<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>BBB<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>CCC<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/html5.png" alt="alt"></p>
<p>拆分单元格<br>colspan用来合并行;<br>rowspan用来合并列</p>
<p><strong>行合并</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"1px"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>AAA<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>BBB<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>CCC<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/html6.png" alt="alt"></p>
<p><strong>列合并</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"1px"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">"2"</span>&gt;</span>AAA<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>BBB<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>CCC<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>bbb<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>ccc<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/html7.png" alt="alt"></p>
<ul>
<li>列表元素（li：列表中的项）（有序列表和无序列表可以互相嵌套）<br>有序列表ol（默认升序，可以进行嵌套的，在一个有序列表中可以嵌套多个有序列表，从而实现标题的整齐）</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span>为什么喜欢我</span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span>&gt;</span>你长得太好看<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span>&gt;</span>你也太可爱了<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span>&gt;</span>无需理由<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/html8.png" alt="alt"></p>
<p>reversed元素：html最新元素，实现列表可以降序排列</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">reversed</span>&gt;</span>为什么喜欢我</span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>你长得太好看<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>你也太可爱了<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>无需理由<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/html9.png" alt="alt"></p>
<p>type元素：可以改变排序的前标，是123还是ABC都可以选择</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">type</span>=<span class="string">"A"</span>&gt;</span>为什么喜欢我</span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>你长得太好看<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>你也太可爱了<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>无需理由<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/html10.png" alt="alt"></p>
<ul>
<li>无序列表（ul）顺序用黑点排列（由于每个浏览器的符号大小不一样，所以我们一般都不用默认的符号，用css中ul的list-type的none去掉）ul和li都是块元素</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>bbb<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>ccc<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/html11.png" alt="alt"></p>
<ul>
<li>定义列表（dl dd dt来创建一个定义列表）<br>dl有两个子标签，dt为被定义的内容，dd是对定义内容的描述</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dt</span>&gt;</span>中国<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dd</span>&gt;</span>最强大的国家<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>表单元素 form元素（用户可以自己输入内容）<ul>
<li>method属性</li>
<li>input元素</li>
<li>action属性</li>
<li>textarea元素</li>
<li>select属性</li>
<li>datalist属性</li>
</ul>
</li>
</ul>
<p>input元素（单行文本框，有29种属性）<br>text属性（默认就是text属性）<br>value属性（占位符，自动填充上所写的字）<br>placeholder属性（提示，没点击是暗的，点击消失）<br>maxlength属性（最大字符数，超过就输不进去）<br>type中password属性 实现以黑点形式出现</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">"12123213"</span> <span class="attr">placeholder</span>=<span class="string">"密码"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/html12.png" alt="alt"></p>
<ul>
<li>type中button属性（按钮属性）<br>分为三种形式</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.button按钮（和js合作，用来绑定事件的）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3.提交按钮</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/html13.png" alt="alt"></p>
<p>type中range属性（数字滑动块 ）<br>max:滑块最大值<br>min:滑块最小值<br>step:每次滑动的距离<br>value：起始的位置，默认为0，在滑表的中间</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"range"</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/html14.png" alt="alt"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"range"</span> <span class="attr">step</span>=<span class="string">"12"</span> <span class="attr">max</span>=<span class="string">"200"</span> <span class="attr">min</span>=<span class="string">"-100"</span> <span class="attr">value</span>=<span class="string">"0"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>type中number属性(可以手动输入的，可以调节大小的值)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"number"</span> <span class="attr">min</span>=<span class="string">"0"</span> <span class="attr">max</span>=<span class="string">"100"</span> <span class="attr">value</span>=<span class="string">"90"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>type中checkbox属性（相当于打对勾的功能，只有选择才能传输到服务器中去，传送到服务器上是布尔型）</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span>  <span class="attr">type</span>=<span class="string">"checkbox"</span>选择 &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/html15.png" alt="alt"></p>
<ul>
<li>type中radio属性（和checkbox功能一样，但是这个选择后就不能取消了，生成一组固定选项）<br>name属性，当多个选项出现时，由name选项可以实现三选一的效果<br>checked属性，默认一个选项</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span>你最喜欢的水果</span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"a"</span>&gt;</span>苹果</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"a"</span>&gt;</span>葡萄</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"a"</span> <span class="attr">checked</span>&gt;</span>芒果</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/html16.png" alt="alt"></p>
<ul>
<li>select元素（可以进行选择，但是不可以自己输入）<br>option元素：可供选择的项</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span>你最喜欢的水果</span><br><span class="line">   <span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">option</span>&gt;</span>香蕉<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">option</span>&gt;</span>橙子<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">option</span>&gt;</span>西瓜<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/html17.png" alt="alt"></p>
<ul>
<li>datalist元素(实现选择，类似是select，但是这个可以自己输入，不过要用id引导)<br>用id引导后，用input元素中的list属性来进行引导</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span>你最喜欢的水果</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">list</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">datalist</span> <span class="attr">id</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span>&gt;</span>香蕉<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span>&gt;</span>西瓜<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span>&gt;</span>橙子<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">datalist</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/html18.png" alt="alt"></p>
<ul>
<li><p>img标签即图片标签，引入外部图片，src属性是图片的地址，也就是图片路径（相对路径，相对于当前资源所在目录的位置，如果图片在当前网页的上一个文件夹，可以用…/来返回上一级 例：…/2.gif）width属性是宽度，height属性是高度（一般开发不设置这两个图片，设置了图片可能会失真），alt是设置图片的备用内容，设置图片的描述<br>（当图片找不到时候，会出现alt备用的内容，搜索引擎会通过alt属性来识别不同的图片，如果没有alt属性，搜索引擎不会对img图片进行收录）</p>
</li>
<li><p>img属性和a标签相结合构成图片可以点击进入url</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"0722.1html.html"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"500294514.jpg"</span> <span class="attr">width</span>=<span class="string">"100px"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>video元素中基本属性<br>src：视频地址<br>height：视频高度<br>width：宽度大小<br>autoplay：自动播放<br>contros：播放控制键<br>preload：预先载入视频<br>none：不会载入视频。<br>metadata：只载入第一帧。<br>auto：请求下载整个视频，默认行为。<br>loop：循环播放。<br>poster：视频载入时显示图片，视频的封面。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">"001_如何学习JAVA300集（一定要看…………）.mp4"</span></span></span><br><span class="line"><span class="tag"> <span class="attr">controls</span> <span class="attr">height</span>=<span class="string">"440"</span> <span class="attr">width</span>=<span class="string">"600px"</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="内联元素-inline-："><a href="#内联元素-inline-：" class="headerlink" title="内联元素(inline)："></a>内联元素(inline)：</h3><ul>
<li>a – 锚点 </li>
<li>abbr – 缩写 </li>
<li>acronym – 首字 </li>
<li>b – 粗体(不推荐) </li>
<li>big – 大字体 </li>
<li>br – 换行 </li>
<li>cite – 引用 </li>
<li>code – 计算机代码(在引用源码的时候需要) </li>
<li>dfn – 定义字段 </li>
<li>em – 强调 </li>
<li>font – 字体设定(不推荐) </li>
<li>i – 斜体 </li>
<li>img – 图片 </li>
<li>input – 输入框 </li>
<li>kbd – 定义键盘文本 </li>
<li>label – 表格标签 </li>
<li>q – 短引用 </li>
<li>s – 中划线(不推荐) </li>
<li>samp – 定义范例计算机代码 </li>
<li>select – 项目选择 </li>
<li>small – 小字体文本 </li>
<li>span – 常用内联容器，定义文本内区块 </li>
<li>strike – 中划线 </li>
<li>strong – 粗体强调 </li>
<li>sub – 下标 </li>
<li>sup – 上标 </li>
<li>textarea – 多行文本输入框 </li>
<li>tt – 电传文本 </li>
<li>u – 下划线</li>
</ul>
<h3 id="块级元素-block-："><a href="#块级元素-block-：" class="headerlink" title="块级元素(block)："></a>块级元素(block)：</h3><ul>
<li>address – 地址 </li>
<li>blockquote – 块引用 </li>
<li>center – 举中对齐块 </li>
<li>dir – 目录列表 </li>
<li>div – 常用块级容易，也是CSS layout的主要标签 </li>
<li>dl – 定义列表 </li>
<li>fieldset – form控制组 </li>
<li>form – 交互表单 </li>
<li>h1 – 大标题 </li>
<li>h2 – 副标题 </li>
<li>h3 – 3级标题 </li>
<li>h4 – 4级标题 </li>
<li>h5 – 5级标题 </li>
<li>h6 – 6级标题 </li>
<li>hr – 水平分隔线 </li>
<li>menu – 菜单列表 </li>
<li>ol – 有序表单 </li>
<li>p – 段落 </li>
<li>pre – 格式化文本 </li>
<li>table – 表格 </li>
<li>ul – 无序列表 </li>
<li>li</li>
</ul>
<h2 id="内联元素与块级元素的区别"><a href="#内联元素与块级元素的区别" class="headerlink" title="内联元素与块级元素的区别:"></a>内联元素与块级元素的区别:</h2><h3 id="内联元素："><a href="#内联元素：" class="headerlink" title="内联元素："></a>内联元素：</h3><ol>
<li>内联元素不会独占一行，相邻的内联元素会排在同一行。其宽度随内容的变化而变化。 </li>
<li>内联元素不可以设置宽高 </li>
<li>内联元素可以设置margin，padding，但只在水平方向有效。</li>
</ol>
<h3 id="块状元素："><a href="#块状元素：" class="headerlink" title="块状元素："></a>块状元素：</h3><ol>
<li>块级元素会独占一行，默认情况下宽度自动填满其父元素宽度 </li>
<li>块级元素可以设置宽高 </li>
<li>块级元素可以设置margin，padding</li>
</ol>
<h3 id="关联："><a href="#关联：" class="headerlink" title="关联："></a>关联：</h3><p>可以通过修改display属性来切换块级元素和内联元素 </p>
<ol>
<li>块级：display:block; </li>
<li>内联：display:inline;</li>
<li>内联块状元素: display:inline-block;</li>
</ol>
<p>内联块状元素inline-block：<br>简单来说就是将对象呈现为inline对象，但是对象的内容作为block对象呈现（可以设置宽高和margin值）。之后的内联对象会被排列在同一内联。比如我们可以给一个link（a元素）inline-block属性值，使其既具有block的宽度高度特性又具有inline的同行特性。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>2n皇后</title>
    <url>/2020/02/17/8queen/</url>
    <content><![CDATA[<p>原题链接：<a href="http://lx.lanqiao.cn/problem.page?gpid=T68" target="_blank" rel="noopener">蓝桥杯T86</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定一个n*n的棋盘，棋盘中有一些位置不能放皇后。现在要向棋盘中放入n个黑皇后和 n个白皇后，使任意的两个黑皇后都不在同一行、同一列或同一条对角线上，任意的两个白皇后都不在同一行、同一列或同一条对角线上。问总共有多少种放法？n小于等于8</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入的第一行为一个整数n，表示棋盘的大小。<br>接下来n行，每行n个0或1的整数，如果一个整数为1，表示对应的位置可以放皇后，如果一个整数为0，表示对应的位置不可以放皇后。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个整数，表示总共有多少种放法。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">1 1 1 1</span><br><span class="line">1 1 1 1</span><br><span class="line">1 1 1 1</span><br><span class="line">1 1 1 1</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[<span class="number">8</span>][<span class="number">8</span>];</span><br><span class="line"><span class="keyword">int</span> n, ans;</span><br><span class="line"><span class="keyword">int</span> bqueenpos[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> wqueenpos[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WQueen</span><span class="params">(<span class="keyword">int</span> k)</span><span class="comment">//摆放白皇后</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (k == n)</span><br><span class="line">		ans++;</span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (bqueenpos[k] == i||<span class="built_in">map</span>[k][i]==<span class="number">0</span>)<span class="comment">//与黑色查重</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; k; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (wqueenpos[j] == i || <span class="built_in">abs</span>(wqueenpos[j] - i) == <span class="built_in">abs</span>(k - j))</span><br><span class="line">				<span class="keyword">break</span>;  <span class="comment">//与之前摆放的白色查重</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (j == k)</span><br><span class="line">		&#123;</span><br><span class="line">			wqueenpos[k] = i;</span><br><span class="line">			WQueen(k + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BQueen</span><span class="params">(<span class="keyword">int</span> k)</span><span class="comment">//摆放黑皇后，k表示行</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (k == n)<span class="comment">//黑色摆放好</span></span><br><span class="line">	&#123;</span><br><span class="line">		WQueen(<span class="number">0</span>);<span class="comment">//开始摆放白</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)<span class="comment">//i枚举所有列</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">map</span>[k][i] == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; k; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (bqueenpos[j] == i || <span class="built_in">abs</span>(bqueenpos[j] - i) == <span class="built_in">abs</span>(k - j))</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (j == k)<span class="comment">//不发生冲突</span></span><br><span class="line">		&#123;</span><br><span class="line">			bqueenpos[k] = i;<span class="comment">//记录位置</span></span><br><span class="line">			BQueen(k + <span class="number">1</span>);<span class="comment">//递归下一个位置</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; <span class="built_in">map</span>[i][j];</span><br><span class="line">	BQueen(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>防晒 acwing 110</title>
    <url>/2020/02/17/ac110/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/112/" target="_blank" rel="noopener">Acwing110</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>有C头奶牛进行日光浴，第i头奶牛需要minSPF[i]到maxSPF[i]单位强度之间的阳光。<br>每头奶牛在日光浴前必须涂防晒霜，防晒霜有L种，涂上第i种之后，身体接收到的阳光强度就会稳定为SPF[i]，第i种防晒霜有cover[i]瓶。<br>求最多可以满足多少头奶牛进行日光浴。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行输入整数C和L。</p>
<p>接下来的C行，按次序每行输入一头牛的minSPF和maxSPF值,即第i行输入minSPF[i]和maxSPF[i]。</p>
<p>再接下来的L行，按次序每行输入一种防晒霜的SPF和cover值,即第i行输入SPF[i]和cover[i]。</p>
<p>每行的数据之间用空格隔开。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个整数，代表最多可以满足奶牛日光浴的奶牛数目。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤C,L≤2500 ,<br>1≤minSPF≤maxSPF≤1000,<br>1≤SPF≤1000</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 2</span><br><span class="line">3 10</span><br><span class="line">2 5</span><br><span class="line">1 5</span><br><span class="line">6 2</span><br><span class="line">4 1</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>

<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>(贪心) O(nlogn)</p>
<p>算法流程：</p>
<ol>
<li>将所有奶牛按照 minSPF 从大到小的顺序排序，然后依次考虑每头奶牛；</li>
<li>对于每头奶牛，扫描当前所有能用的防晒霜，选择 SPF 值最大的防晒霜来用；</li>
</ol>
<p>根据匈牙利算法的原理，如果一个匹配不存在增广路径，则该匹配是二分图的一个最大匹配。下面我们来证明按照上述做法得到的匹配方案，不存在增广路径。<br>运用反证法证明，上述方法得到的匹配方案不存在增广路径。<br>假设有某瓶未被防晒霜可以与第k头牛匹配，那么它必然不能和小于k的牛<br>匹配，否则根据算法思路，它必然已经被小于k的牛使用了。故若存在<br>增广路径，那么它只能与k以上的牛匹配，如果存在增广路径，那么第一头<br>牛在一开始必然没有匹配，这与算法矛盾，因为最上面的牛应当最先匹配一个<br>点，所以原算法不存在增广路径</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;PII;</span><br><span class="line">priority_queue&lt;PII, <span class="built_in">vector</span>&lt;PII&gt;, less&lt;PII&gt;&gt; q;</span><br><span class="line">PII p[<span class="number">2510</span>];</span><br><span class="line"><span class="keyword">int</span> C, L, minSPF, maxSPF, SPF, cover, counts, tempi, j;</span><br><span class="line">PII tempp;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(PII a, PII b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.first &gt; b.first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; C &gt;&gt; L;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; C; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; minSPF &gt;&gt; maxSPF;</span><br><span class="line">		q.push(&#123; minSPF,maxSPF &#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; p[i].first &gt;&gt; p[i].second;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	sort(p, p + L, cmp);</span><br><span class="line">	<span class="keyword">while</span> (!q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		tempp = q.top();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; L; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (p[j].first &gt;= tempp.first&amp;&amp;p[j].first &lt;= tempp.second&amp;&amp;p[j].second != <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				counts++;</span><br><span class="line">				p[j].second--;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		q.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; counts &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>直方图中最大的矩形 acwing 131</title>
    <url>/2020/02/17/ac131/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/133/" target="_blank" rel="noopener">Acwing131</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>直方图是由在公共基线处对齐的一系列矩形组成的多边形。</p>
<p>矩形具有相等的宽度，但可以具有不同的高度。</p>
<p>例如，图例左侧显示了由高度为2,1,4,5,1,3,3的矩形组成的直方图，矩形的宽度都为1：</p>
<p><img src="/ac131.png" alt="alt"></p>
<p>通常，直方图用于表示离散分布，例如，文本中字符的频率。</p>
<p>现在，请你计算在公共基线处对齐的直方图中最大矩形的面积。</p>
<p>图例右图显示了所描绘直方图的最大对齐矩形。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入包含几个测试用例。</p>
<p>每个测试用例占据一行，用以描述一个直方图，并以整数n开始，表示组成直方图的矩形数目。</p>
<p>然后跟随n个整数h1，…，hn。</p>
<p>这些数字以从左到右的顺序表示直方图的各个矩形的高度。</p>
<p>每个矩形的宽度为1。</p>
<p>同行数字用空格隔开。</p>
<p>当输入用例为n=0时，结束输入，且该用例不用考虑。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>对于每一个测试用例，输出一个整数，代表指定直方图中最大矩形的区域面积。</p>
<p>每个数据占一行。</p>
<p>请注意，此矩形必须在公共基线处对齐。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤n≤100000,<br>0≤hi≤1000000000</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7 2 1 4 5 1 3 3</span><br><span class="line">4 1000 1000 1000 1000</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">4000</span><br></pre></td></tr></table></figure>

<h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">此问题用到单调栈的思想，即栈内元素单调增或单调减，经过观察，我们发现</span><br><span class="line">当某一个矩形左侧的矩形比它自身要高时，它自身的高度对于左侧便失去了</span><br><span class="line">意义，所以我们可以保持栈内的元素是单调递增的，每次遇到比栈顶元素小的</span><br><span class="line">元素时，就不断弹出栈内元素，直到栈顶元素小于当前元素，同时计算出弹出</span><br><span class="line">元素所形成的最大面积</span><br></pre></td></tr></table></figure>



<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">101010</span>;</span><br><span class="line">ll n, p, len, res, a[N], s[N], w[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n, n)</span><br><span class="line">	&#123;</span><br><span class="line">		res = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">		a[n + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">		p = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (s[p] &lt; a[i])<span class="comment">//保证栈中是递增序列</span></span><br><span class="line">			&#123;</span><br><span class="line">				s[++p] = a[i];</span><br><span class="line">				w[p] = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				len = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">while</span> (s[p] &gt; a[i])</span><br><span class="line">				&#123;</span><br><span class="line">					len += w[p];</span><br><span class="line">					res = max(res, s[p] * len);</span><br><span class="line">					p--;</span><br><span class="line">				&#125;</span><br><span class="line">				s[++p] = a[i];</span><br><span class="line">				w[p] = len + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>编辑器 acwing 128</title>
    <url>/2020/02/17/ac128/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/130/" target="_blank" rel="noopener">Acwing128</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>你将要实现一个功能强大的整数序列编辑器。</p>
<p>在开始时，序列是空的。</p>
<p>编辑器共有五种指令，如下：</p>
<p>1、“I x”，在光标处插入数值x。<br>2、“D”，将光标前面的第一个元素删除，如果前面没有元素，则忽略此操作。<br>3、“L”，将光标向左移动，跳过一个元素，如果左边没有元素，则忽略此操作。<br>4、“R”，将光标向右移动，跳过一个元素，如果右边没有元素，则忽略次操作。<br>5、“Q k”，假设此刻光标之前的序列为a1,a2,…,an,输出max1≤i≤kSi，其中Si=a1+a2+…+ai。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含一个整数Q，表示指令的总数。</p>
<p>接下来Q行，每行一个指令，具体指令格式如题目描述。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>每一个“Q k”指令，输出一个整数作为结果，每个结果占一行</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤Q≤106,<br>|x|≤103,<br>1≤k≤n</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">I 2</span><br><span class="line">I -1</span><br><span class="line">I 1</span><br><span class="line">Q 3</span><br><span class="line">L</span><br><span class="line">D</span><br><span class="line">R</span><br><span class="line">Q 2</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在光标左侧和右侧分别建立一个栈，L操作对应于将左侧栈顶元素弹出并加入</span><br><span class="line">到右侧栈，R操作反之，每次在左侧栈中加入元素(L 或 l x 操作)都要计算</span><br><span class="line">一下当前的和</span><br></pre></td></tr></table></figure>


<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1E6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; p, q;</span><br><span class="line"><span class="keyword">int</span> sum[N], f[N], n, v;</span><br><span class="line"><span class="keyword">char</span> a;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	f[<span class="number">0</span>] = <span class="number">-1e7</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">		<span class="keyword">if</span> (a == <span class="string">'L'</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!p.empty())</span><br><span class="line">			&#123;</span><br><span class="line">				q.push(p.top());</span><br><span class="line">				p.pop();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="string">'R'</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!q.empty())</span><br><span class="line">			&#123;</span><br><span class="line">				p.push(q.top());</span><br><span class="line">				q.pop();</span><br><span class="line">				sum[p.size()] = sum[p.size() - <span class="number">1</span>] + p.top();</span><br><span class="line">				f[p.size()] = max(f[p.size() - <span class="number">1</span>], sum[p.size()]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="string">'D'</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!p.empty())</span><br><span class="line">				p.pop();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="string">'I'</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; v;</span><br><span class="line">			p.push(v);</span><br><span class="line">			sum[p.size()] = sum[p.size() - <span class="number">1</span>] + p.top();</span><br><span class="line">			f[p.size()] = max(f[p.size() - <span class="number">1</span>], sum[p.size()]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="string">'Q'</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; v;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; f[v] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>兔子与兔子 acwing 138</title>
    <url>/2020/02/17/ac138/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/140/" target="_blank" rel="noopener">Acwing138</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>很久很久以前，森林里住着一群兔子。</p>
<p>有一天，兔子们想要研究自己的 DNA 序列。</p>
<p>我们首先选取一个好长好长的 DNA 序列（小兔子是外星生物，DNA 序列可能包含 26 个小写英文字母）。</p>
<p>然后我们每次选择两个区间，询问如果用两个区间里的 DNA 序列分别生产出来两只兔子，这两个兔子是否一模一样。</p>
<p>注意两个兔子一模一样只可能是他们的 DNA 序列一模一样。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行输入一个 DNA 字符串 S。</p>
<p>第二行一个数字 m，表示 m 次询问。</p>
<p>接下来 m 行，每行四个数字 l1,r1,l2,r2，分别表示此次询问的两个区间，注意字符串的位置从1开始编号。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>对于每次询问，输出一行表示结果。</p>
<p>如果两只兔子完全相同输出 Yes，否则输出 No（注意大小写）。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤length(S),m≤1000000</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aabbaabb</span><br><span class="line">3</span><br><span class="line">1 3 5 7</span><br><span class="line">1 3 6 8</span><br><span class="line">1 2 1 2</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">Yes</span><br></pre></td></tr></table></figure>

<h3 id="字符串hash"><a href="#字符串hash" class="headerlink" title="字符串hash"></a>字符串hash</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">字符串哈希，就是将字符串变成数值，最终得到的数值是一个p进制数，并且</span><br><span class="line">p最好是素数，这里p一般取131和13331</span><br><span class="line">由于这种方式得到的数很大，我们一般要模上一个数字，这里的取模数字一般</span><br><span class="line">取2^64,即unsigned ll 的默认取模即可</span><br></pre></td></tr></table></figure>


<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ULL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000100</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line">ULL hashh[N], p[N], n, len, b1, e1, b2, e2;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%s"</span>, str + <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	len = <span class="built_in">strlen</span>(str + <span class="number">1</span>);</span><br><span class="line">	p[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">	    hashh[i] = hashh[i - <span class="number">1</span>] * <span class="number">131</span> + str[i] - <span class="string">'a'</span> + <span class="number">1</span>;<span class="comment">//前缀和递推求出每一个哈希值</span></span><br><span class="line">	    p[i] = p[i<span class="number">-1</span>] * <span class="number">131</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; b1 &gt;&gt; e1 &gt;&gt; b2 &gt;&gt; e2;</span><br><span class="line">		ULL fir = hashh[e1] - hashh[b1] * p[e1-b1];</span><br><span class="line">		ULL sec=  hashh[e2] - hashh[b2] * p[e1-b1];</span><br><span class="line">		<span class="keyword">if</span> (fir == sec) <span class="built_in">cout</span> &lt;&lt; <span class="string">"Yes"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"No"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title>回文子串的最大长度 acwing 139</title>
    <url>/2020/02/17/ac139/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/141/" target="_blank" rel="noopener">Acwing139</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>如果一个字符串正着读和倒着读是一样的，则称它是回文的。</p>
<p>给定一个长度为N的字符串S，求他的最长回文子串的长度是多少。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入将包含最多30个测试用例，每个测试用例占一行，以最多1000000个小写字符的形式给出。</p>
<p>输入以一个以字符串“END”（不包括引号）开头的行表示输入终止。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>对于输入中的每个测试用例，输出测试用例编号和最大回文子串的长度（参考样例格式）。</p>
<p>每个输出占一行。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abcbabcbabcba</span><br><span class="line">abacacbaaaab</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Case 1: 13</span><br><span class="line">Case 2: 6</span><br></pre></td></tr></table></figure>

<h3 id="字符串hash"><a href="#字符串hash" class="headerlink" title="字符串hash"></a>字符串hash</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">先正反各计算出字符串hash值，之后再遍历所有中心，并运用二分的方法</span><br><span class="line">求出最大长度</span><br><span class="line"></span><br><span class="line">由于奇数回文串和偶数回文串不一样，我们为了统一这两种情况，将原字符串</span><br><span class="line">扩展为两倍，即在原字符串每两个直接插入一个无关元素，这样便只需在最后</span><br><span class="line">处理结果时判断回文串的边界是否为无关元素即可</span><br></pre></td></tr></table></figure>


<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2000010</span>, base = <span class="number">131</span>;</span><br><span class="line">ull hl[N], hr[N], p[N];</span><br><span class="line"><span class="comment">//hl表示从左往右的字符串hash</span></span><br><span class="line"><span class="comment">//hr表示从右往左的字符串hash</span></span><br><span class="line">ull l, r, mid, res, t;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="function">ull <span class="title">gett</span><span class="params">(ull h[], ull l, ull r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];  <span class="comment">//计算出l~r的字符串的哈希值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%s"</span>, str + <span class="number">1</span>), <span class="built_in">strcmp</span>(str + <span class="number">1</span>, <span class="string">"END"</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> len = <span class="built_in">strlen</span>(str + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = len * <span class="number">2</span>; i; i -= <span class="number">2</span>)<span class="comment">//扩充字符串以合并奇偶串两种情况</span></span><br><span class="line">		&#123;</span><br><span class="line">			str[i] = str[i / <span class="number">2</span>];</span><br><span class="line">			str[i - <span class="number">1</span>] = <span class="string">'z'</span> + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		len *= <span class="number">2</span>;<span class="comment">//合并完长度要乘以2</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = len; i &lt;= len; i++, j--)<span class="comment">//初始化信息</span></span><br><span class="line">		&#123;</span><br><span class="line">			hl[i] = hl[i - <span class="number">1</span>] * base + str[i] - <span class="string">'a'</span> + <span class="number">1</span>;</span><br><span class="line">			hr[i] = hr[i - <span class="number">1</span>] * base + str[j] - <span class="string">'a'</span> + <span class="number">1</span>;</span><br><span class="line">			p[i] = p[i - <span class="number">1</span>] * base;</span><br><span class="line">		&#125;</span><br><span class="line">		res = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			l = <span class="number">0</span>;</span><br><span class="line">			r = min(i - <span class="number">1</span>, len - i);</span><br><span class="line">			<span class="keyword">while</span> (l &lt; r)<span class="comment">//二分法</span></span><br><span class="line">			&#123;</span><br><span class="line">				mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span> (gett(hl, i - mid, i - <span class="number">1</span>) != gett(hr, len - mid - i + <span class="number">1</span>, len - i))<span class="comment">//注意边界的取值</span></span><br><span class="line">					r = mid - <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					l = mid;</span><br><span class="line">			&#125; </span><br><span class="line">			<span class="comment">//mid可理解为回文串中心到两边的距离</span></span><br><span class="line">			mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (str[i - mid] &gt; <span class="string">'z'</span>)<span class="comment">//如果边界是无用字符</span></span><br><span class="line">				res = max(res, mid);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				res = max(res, mid + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Case %d: %d\n"</span>, ++t, res);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title>城市游戏 acwing 152</title>
    <url>/2020/02/17/ac152/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/154/" target="_blank" rel="noopener">Acwing152</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>有一天，小猫rainbow和freda来到了湘西张家界的天门山玉蟾宫，玉蟾宫宫主蓝兔盛情地款待了它们，并赐予它们一片土地。</p>
<p>这片土地被分成N*M个格子，每个格子里写着’R’或者’F’，R代表这块土地被赐予了rainbow，F代表这块土地被赐予了freda。</p>
<p>现在freda要在这里卖萌。。。它要找一块矩形土地，要求这片土地都标着’F’并且面积最大。</p>
<p>但是rainbow和freda的OI水平都弱爆了，找不出这块土地，而蓝兔也想看freda卖萌（她显然是不会编程的……），所以它们决定，如果你找到的土地面积为S，它们将给你3*S两银子。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包括两个整数N,M，表示矩形土地有N行M列。</p>
<p>接下来N行，每行M个用空格隔开的字符’F’或’R’，描述了矩形土地。</p>
<p>每行末尾没有多余空格。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个整数，表示你能得到多少银子，即(3*最大’F’矩形土地面积)的值。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤N,M≤1000</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 6</span><br><span class="line">R F F F F F</span><br><span class="line">F F F F F F</span><br><span class="line">R R R F F F</span><br><span class="line">F F F F F F</span><br><span class="line">F F F F F F</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">45</span><br></pre></td></tr></table></figure>

<h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">与直方图中的最大矩形问题类似，在此问题中，如果我们将每一行上方的F的</span><br><span class="line">个数看作是矩形的高度，那么该问题就等效为求出每一行的最大矩形面积，即</span><br><span class="line">对每一行分别运用单调栈的思想求解</span><br></pre></td></tr></table></figure>


<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">char</span> g[N][N];</span><br><span class="line"><span class="keyword">int</span> h[N][N];</span><br><span class="line"><span class="keyword">int</span> q[N], l[N], r[N];</span><br><span class="line"><span class="comment">// l[i]表示比第i个元素小且在i左边的第一个元素的右边一个元素(即左边可达的最大长度)</span></span><br><span class="line"><span class="comment">// r[i]表示比第i个元素小且在i右边的第一个元素的右边一个元素(即右边可达的最大长度)</span></span><br><span class="line"><span class="comment">// q是一个单调栈，栈内元素单调递增，存放的是元素的下标</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> l[])</span><span class="comment">//初始化l，r数组</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">	a[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (a[q[tt]] &gt;= a[i]) tt--;</span><br><span class="line">		l[i] = q[tt] + <span class="number">1</span>;</span><br><span class="line">		q[++tt] = i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> a[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cal(a, l);</span><br><span class="line">	reverse(a + <span class="number">1</span>, a + <span class="number">1</span> + m);</span><br><span class="line">	cal(a, r);</span><br><span class="line">	reverse(a + <span class="number">1</span>, a + <span class="number">1</span> + m);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> left = l[i];<span class="comment">//左边可达长度</span></span><br><span class="line">		<span class="keyword">int</span> right = m + <span class="number">1</span> - r[m + <span class="number">1</span> - i];<span class="comment">//右边可达长度</span></span><br><span class="line">		res = max(res, a[i] * (right - left + <span class="number">1</span>));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; g[i][j];</span><br><span class="line">			<span class="comment">//运用dp求出每个元素上方的F的个数</span></span><br><span class="line">			<span class="keyword">if</span> (g[i][j] == <span class="string">'F'</span>) h[i][j] = h[i - <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> h[i][j] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) res = max(res, work(h[i]));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; res * <span class="number">3</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>可达性统计 acwing 164</title>
    <url>/2020/02/17/ac164/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/166/" target="_blank" rel="noopener">Acwing164</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定一张N个点M条边的有向无环图，分别统计从每个点出发能够到达的点的数量。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行两个整数N,M，接下来M行每行两个整数x,y，表示从x到y的一条有向边。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出共N行，表示每个点能够到达的点的数量。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤N,M≤30000</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 10</span><br><span class="line">3 8</span><br><span class="line">2 3</span><br><span class="line">2 5</span><br><span class="line">5 9</span><br><span class="line">5 9</span><br><span class="line">2 3</span><br><span class="line">3 9</span><br><span class="line">4 8</span><br><span class="line">2 10</span><br><span class="line">4 9</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">6</span><br><span class="line">3</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h3 id="拓扑排序-bitset二进制数组"><a href="#拓扑排序-bitset二进制数组" class="headerlink" title="拓扑排序+bitset二进制数组"></a>拓扑排序+bitset二进制数组</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">有向无环图是拓扑排序的必要条件,而且这道题目明确告诉我们统计从每个点</span><br><span class="line">出发能够到达的点的数量,也就是说统计这个点可以抵达的个数,这样的话我</span><br><span class="line">们只需要再开一个数组f.f[i]表示i这个点的可以抵达点的数量.我们很快</span><br><span class="line">就可以发现性质.</span><br><span class="line">f[i]&#x3D;所有出边上点的交集.既然如此的话,我们不妨开一个二进制数组来</span><br><span class="line">进行并集|运算即可.</span><br></pre></td></tr></table></figure>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> net[N], head[N], ver[N], deg[N], tot, cnt, a[N], n, m;</span><br><span class="line"><span class="built_in">bitset</span> &lt;N&gt; f[N]; <span class="comment">//二进制数组 默认为N位的0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span><span class="comment">//添加有向边</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ver[++tot] = y;</span><br><span class="line">	net[tot] = head[x];<span class="comment">//保存上一条路径</span></span><br><span class="line">	head[x] = tot;<span class="comment">//更新当前头节点</span></span><br><span class="line">	deg[y]++;<span class="comment">//入度+1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topsort</span><span class="params">()</span><span class="comment">//拓扑排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!deg[i])<span class="comment">//找出入度为0的点</span></span><br><span class="line">			q.push(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (q.size())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> x = q.front();</span><br><span class="line">		a[++cnt] = x;</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = net[i])<span class="comment">//访问所有边</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> y = ver[i];</span><br><span class="line">			deg[y]--;</span><br><span class="line">			<span class="keyword">if</span> (!deg[y])</span><br><span class="line">				q.push(y);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">()</span><span class="comment">//统计路径个数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = cnt; j; j--) <span class="comment">//从后向前遍历</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> x = a[j];</span><br><span class="line">		f[x][x] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = net[i])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> y = ver[i];</span><br><span class="line">			f[x] |= f[y]; <span class="comment">//求并集</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x, y;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		add(x, y);</span><br><span class="line">	&#125;</span><br><span class="line">	topsort();</span><br><span class="line">	calc();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; f[i].count() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//统计1的个数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>小猫爬山 acwing 165</title>
    <url>/2020/02/17/ac165/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/167/" target="_blank" rel="noopener">Acwing165</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>翰翰和达达饲养了N只小猫，这天，小猫们要去爬山。</p>
<p>经历了千辛万苦，小猫们终于爬上了山顶，但是疲倦的它们再也不想徒步走下山了（呜咕&gt;_&lt;）。</p>
<p>翰翰和达达只好花钱让它们坐索道下山。</p>
<p>索道上的缆车最大承重量为W，而N只小猫的重量分别是C1、C2……CN。</p>
<p>当然，每辆缆车上的小猫的重量之和不能超过W。</p>
<p>每租用一辆缆车，翰翰和达达就要付1美元，所以他们想知道，最少需要付多少美元才能把这N只小猫都运送下山？</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第1行：包含两个用空格隔开的整数，N和W。</p>
<p>第2..N+1行：每行一个整数，其中第i+1行的整数表示第i只小猫的重量Ci。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个整数，表示最少需要多少美元，也就是最少需要多少辆缆车。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤N≤18,<br>1≤Ci≤W≤1E8</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 1996</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">1994</span><br><span class="line">12</span><br><span class="line">29</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>

<h3 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.将猫的体重从大到小排序</span><br><span class="line">2.如果当前答案大于已知最小答案则立即回溯</span><br></pre></td></tr></table></figure>
<p>代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, w, res = <span class="number">30</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">20</span>], a[<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (res &lt;= cnt) <span class="comment">//剪枝2</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (cur == n)</span><br><span class="line">	&#123;</span><br><span class="line">		res = min(res, cnt);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= cnt; i++)<span class="comment">//遍历所有的车</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (f[i] + a[cur] &lt;= w)</span><br><span class="line">		&#123;</span><br><span class="line">			f[i] += a[cur];</span><br><span class="line">			dfs(cur + <span class="number">1</span>, cnt);</span><br><span class="line">			f[i] -= a[cur];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//未返回说明当前车不够，需再加车</span></span><br><span class="line">	f[cnt + <span class="number">1</span>] = a[cur];</span><br><span class="line">	dfs(cur + <span class="number">1</span>, cnt + <span class="number">1</span>);</span><br><span class="line">	f[cnt + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; w;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	sort(a, a + n, cmp);<span class="comment">//剪枝1</span></span><br><span class="line">	dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; res + <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>数独 acwing 166</title>
    <url>/2020/02/17/ac166/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/168/" target="_blank" rel="noopener">Acwing166</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>数独是一种传统益智游戏，你需要把一个9 × 9的数独补充完整，使得图中每行、每列、每个3 × 3的九宫格内数字1~9均恰好出现一次。</p>
<p>请编写一个程序填写数独。</p>
<p><img src="/images/shudu.png" alt="alt"></p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入包含多组测试用例。</p>
<p>每个测试用例占一行，包含81个字符，代表数独的81个格内数据（顺序总体由上到下，同行由左到右）。</p>
<p>每个字符都是一个数字（1-9）或一个”.”（表示尚未填充）。</p>
<p>您可以假设输入中的每个谜题都只有一个解决方案。</p>
<p>文件结尾处为包含单词“end”的单行，表示输入结束。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>每个测试用例，输出一行数据，代表填充完全后的数独。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.2738..1..1...6735.......293.5692.8...........6.1745.364.......9518...7..8..6534.</span><br><span class="line">......52..8.4......3...9...5.1...6..2..7........3.....6...1..........7.4.......3.</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">527389416819426735436751829375692184194538267268174593643217958951843672782965341</span><br><span class="line">416837529982465371735129468571298643293746185864351297647913852359682714128574936</span><br></pre></td></tr></table></figure>

<h3 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.优化搜索顺序，每次找可选数字最少的位置填数</span><br></pre></td></tr></table></figure>

<p>###优化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.位运算，通过位运算&amp; 可以方便求出当前位置可填的数</span><br><span class="line">2.lowbit可取出当前位的可能填的数</span><br></pre></td></tr></table></figure>

<p>代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[<span class="number">1</span> &lt;&lt; N], ones[<span class="number">1</span> &lt;&lt; N];</span><br><span class="line"><span class="keyword">int</span> row[N], col[N], cell[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x &amp; (-x);  <span class="comment">//返回最低位的1 ，如1011100返回100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> row[x] &amp; col[y] &amp; cell[x / <span class="number">3</span>][y / <span class="number">3</span>];<span class="comment">//求出当前位置能填的数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span><span class="comment">//初始化，将每位都初始化为1</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		row[i] = (<span class="number">1</span> &lt;&lt; N) - <span class="number">1</span>;</span><br><span class="line">		col[i] = (<span class="number">1</span> &lt;&lt; N) - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">			cell[i][j] = (<span class="number">1</span> &lt;&lt; N) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (cnt == <span class="number">0</span>)<span class="comment">//填完所有的数</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">int</span> mins = <span class="number">10</span>, x, y;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)<span class="comment">//找出可填数最少的位置</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (str[i * <span class="number">9</span> + j] == <span class="string">'.'</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> t = get(i, j);</span><br><span class="line">				<span class="keyword">int</span> s = ones[t];</span><br><span class="line">				<span class="keyword">if</span> (s &lt; mins)</span><br><span class="line">				&#123;</span><br><span class="line">					mins = s;</span><br><span class="line">					x = i;</span><br><span class="line">					y = j;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = get(x, y); i; i -= lowbit(i))<span class="comment">//遍历所有可填的数</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> t = lowbit(i);</span><br><span class="line">		row[x] -= t;</span><br><span class="line">		col[y] -= t;</span><br><span class="line">		cell[x / <span class="number">3</span>][y / <span class="number">3</span>] -= t;</span><br><span class="line">		str[x * <span class="number">9</span> + y] = <span class="string">'1'</span> + <span class="built_in">map</span>[t];</span><br><span class="line">		<span class="keyword">if</span> (dfs(cnt - <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		row[x] += t;</span><br><span class="line">		col[y] += t;</span><br><span class="line">		cell[x / <span class="number">3</span>][y / <span class="number">3</span>] += t;</span><br><span class="line">		str[x * <span class="number">9</span> + y] = <span class="string">'.'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">		<span class="built_in">map</span>[<span class="number">1</span> &lt;&lt; i] = i;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; N; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j; j -= lowbit(j))</span><br><span class="line">		&#123;</span><br><span class="line">			s++;</span><br><span class="line">		&#125;</span><br><span class="line">		ones[i] = s;<span class="comment">//统计每个数中1的个数</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; str, str[<span class="number">0</span>] != <span class="string">'e'</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		init();</span><br><span class="line">		<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> t = i * <span class="number">9</span> + j;</span><br><span class="line">				<span class="keyword">if</span> (str[t] != <span class="string">'.'</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">int</span> b = str[t] - <span class="string">'1'</span>;<span class="comment">//将该为变为0</span></span><br><span class="line">					row[i] -= (<span class="number">1</span> &lt;&lt; b);</span><br><span class="line">					col[j] -= (<span class="number">1</span> &lt;&lt; b);</span><br><span class="line">					cell[i / <span class="number">3</span>][j / <span class="number">3</span>] -= (<span class="number">1</span> &lt;&lt; b);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					cnt++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		dfs(cnt);</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>加成序列 acwing 170</title>
    <url>/2020/02/17/ac170/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/172/" target="_blank" rel="noopener">Acwing170</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>满足如下条件的序列X（序列中元素被标号为1、2、3…m）被称为“加成序列”：</p>
<p>1、X[1]=1</p>
<p>2、X[m]=n</p>
<p>3、X[1]&lt;X[2]&lt;…&lt;X[m-1]&lt;X[m]</p>
<p>4、对于每个 k（2≤k≤m）都存在两个整数 i 和 j （1≤i,j≤k−1，i 和 j 可相等），使得X[k]=X[i]+X[j]。</p>
<p>你的任务是：给定一个整数n，找出符合上述条件的长度m最小的“加成序列”。</p>
<p>如果有多个满足要求的答案，只需要找出任意一个可行解。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入包含多组测试用例。</p>
<p>每组测试用例占据一行，包含一个整数n。</p>
<p>当输入为单行的0时，表示输入结束。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>对于每个测试用例，输出一个满足需求的整数序列，数字之间用空格隔开。</p>
<p>每个输出占一行。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤n≤100</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">7</span><br><span class="line">12</span><br><span class="line">15</span><br><span class="line">77</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 2 4 5</span><br><span class="line">1 2 4 6 7</span><br><span class="line">1 2 4 8 12</span><br><span class="line">1 2 4 5 10 15</span><br><span class="line">1 2 4 8 9 17 34 68 77</span><br></pre></td></tr></table></figure>


<h3 id="迭代加深"><a href="#迭代加深" class="headerlink" title="迭代加深"></a>迭代加深</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">由题意，再经稍加推算已知100以内的数的迭代序列长度不会超过10，</span><br><span class="line">所以这里可以用迭代加深的思想，一层一层地向下搜索</span><br></pre></td></tr></table></figure>

<h3 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.从大到小枚举</span><br><span class="line">2.值相同的元素不用再次搜索</span><br></pre></td></tr></table></figure>



<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span>  a[N];</span><br><span class="line"><span class="keyword">int</span> jud[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (now == depth)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (a[now - <span class="number">1</span>] == n)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(jud, <span class="number">0</span>, <span class="keyword">sizeof</span>(jud));<span class="comment">//每次进入都要初始化一次</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = now - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)<span class="comment">//剪枝1</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span>  t = a[i] + a[j];</span><br><span class="line">			<span class="keyword">if</span> (!jud[t] &amp;&amp; t &lt;= n &amp;&amp; t &gt; a[now - <span class="number">1</span>])<span class="comment">//剪枝2</span></span><br><span class="line">			&#123;</span><br><span class="line">				jud[t] = <span class="number">1</span>;</span><br><span class="line">				a[now] = t;</span><br><span class="line">				<span class="keyword">if</span> (dfs(now + <span class="number">1</span>, depth))</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n, n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> depth = <span class="number">1</span>;</span><br><span class="line">		a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (!dfs(<span class="number">1</span>, depth))<span class="comment">//迭代加深</span></span><br><span class="line">		&#123;</span><br><span class="line">			depth++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; depth; i++)</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>dfs</tag>
        <tag>迭代加深</tag>
      </tags>
  </entry>
  <entry>
    <title>生日蛋糕 acwing 168</title>
    <url>/2020/02/17/ac168/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/170/" target="_blank" rel="noopener">Acwing168</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>7月17日是Mr.W的生日，ACM-THU为此要制作一个体积为Nπ的M层生日蛋糕，每层都是一个圆柱体。</p>
<p>设从下往上数第i层蛋糕是半径为Ri, 高度为Hi的圆柱。</p>
<p>当i &lt; M时，要求Ri &gt; Ri+1且Hi &gt; Hi+1。</p>
<p>由于要在蛋糕上抹奶油，为尽可能节约经费，我们希望蛋糕外表面（最下一层的下底面除外）的面积Q最小。</p>
<p>令Q = Sπ ，请编程对给出的N和M，找出蛋糕的制作方案（适当的Ri和Hi的值），使S最小。</p>
<p>除Q外，以上所有数据皆为正整数 。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入包含两行，第一行为整数N（N &lt;= 10000），表示待制作的蛋糕的体积为Nπ。</p>
<p>第二行为整数M(M &lt;= 20)，表示蛋糕的层数为M。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出仅一行，是一个正整数S（若无解则S = 0）。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤N≤10000,<br>1≤M≤20</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">100</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">68</span><br></pre></td></tr></table></figure>

<h3 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.从体积大的盘子搜到体积小的盘子</span><br><span class="line">2.通过数学推导缩小上下界</span><br><span class="line">3.当前体积+剩余可能最小体积&gt;n,返回</span><br><span class="line">4.当前面积+剩余可能最优面积&gt;ans,返回</span><br><span class="line">5.数学剪枝,2(n-v)&#x2F;r[dep] +s &gt;ans,返回</span><br></pre></td></tr></table></figure>



<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxx = <span class="number">0x7ffff</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> minv[<span class="number">30</span>], mins[<span class="number">30</span>];</span><br><span class="line"><span class="keyword">int</span> h[<span class="number">30</span>], r[<span class="number">30</span>], ans = maxx;</span><br><span class="line"><span class="keyword">int</span> v, s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> dep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!dep)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (v == n)</span><br><span class="line">			ans = min(ans, s);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (r[dep] = min((<span class="keyword">int</span>)<span class="built_in">sqrt</span>(n - v), r[dep + <span class="number">1</span>] - <span class="number">1</span>); r[dep] &gt;= dep; r[dep]--)<span class="comment">//剪枝1，2</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (h[dep] = min((<span class="keyword">int</span>)((<span class="keyword">double</span>)(n - v) / (r[dep] * r[dep])), h[dep + <span class="number">1</span>] - <span class="number">1</span>); h[dep] &gt;= dep; h[dep]--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (v + minv[dep] &gt; n) <span class="keyword">continue</span>;<span class="comment">//剪枝3</span></span><br><span class="line">			<span class="keyword">if</span> (s + mins[dep] &gt; ans) <span class="keyword">continue</span>;<span class="comment">//剪枝4</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="number">2</span> * (n - v) / r[dep] + s &gt; ans) <span class="keyword">continue</span>;<span class="comment">//剪枝5</span></span><br><span class="line">			<span class="keyword">if</span> (dep == m) s += r[dep] * r[dep];</span><br><span class="line">			s += <span class="number">2</span> * r[dep] * h[dep];</span><br><span class="line">			v += r[dep] * r[dep] * h[dep];</span><br><span class="line">			dfs(dep - <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span> (dep == m) s -= r[dep] * r[dep];</span><br><span class="line">			s -= <span class="number">2</span> * r[dep] * h[dep];</span><br><span class="line">			v -= r[dep] * r[dep] * h[dep];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)<span class="comment">//求出剩下部分可能的最小值</span></span><br><span class="line">	&#123;</span><br><span class="line">		minv[i] = minv[i - <span class="number">1</span>] + i * i * i;</span><br><span class="line">		mins[i] = mins[i - <span class="number">1</span>] + i * i * <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	h[m + <span class="number">1</span>] = r[m + <span class="number">1</span>] = maxx;</span><br><span class="line">	dfs(m);</span><br><span class="line">	<span class="keyword">if</span> (ans == maxx)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"0"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>dfs</tag>
        <tag>剪枝</tag>
      </tags>
  </entry>
  <entry>
    <title>杨老师的照相排列 acwing 271</title>
    <url>/2020/02/17/ac271/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/273/" target="_blank" rel="noopener">Acwing271</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>有 N 个学生合影，站成左端对齐的 k 排，每排分别有 N1,N2,…,Nk 个人。 (N1≥N2≥…≥Nk)</p>
<p>第1排站在最后边，第 k 排站在最前边。</p>
<p>学生的身高互不相同，把他们从高到底依次标记为 1,2,…,N。</p>
<p>在合影时要求每一排从左到右身高递减，每一列从后到前身高也递减。</p>
<p>问一共有多少种安排合影位置的方案？</p>
<p>下面的一排三角矩阵给出了当 N=6,k=3,N1=3,N2=2,N3=1 时的全部16种合影方案。注意身高最高的是1，最低的是6。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">123 123 124 124 125 125 126 126 134 134 135 135 136 136 145 146</span><br><span class="line">45  46  35  36  34  36  34  35  25  26  24  26  24  25  26  25</span><br><span class="line">6   5   6   5   6   4   5   4   6   5   6   4   5   4   3   3</span><br></pre></td></tr></table></figure>


<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入包含多组测试数据。</p>
<p>每组数据两行，第一行包含一个整数k表示总排数。</p>
<p>第二行包含k个整数，表示从后向前每排的具体人数。</p>
<p>当输入k=0的数据时，表示输入终止，且该数据无需处理。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>每组测试数据输出一个答案，表示不同安排的数量。</p>
<p>每个答案占一行。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤k≤5,学生总人数不超过30人。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">30</span><br><span class="line">5</span><br><span class="line">1 1 1 1 1</span><br><span class="line">3</span><br><span class="line">3 2 1</span><br><span class="line">4</span><br><span class="line">5 3 3 1</span><br><span class="line">5</span><br><span class="line">6 5 4 3 2</span><br><span class="line">2</span><br><span class="line">15 15</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">1</span><br><span class="line">16</span><br><span class="line">4158</span><br><span class="line">141892608</span><br><span class="line">9694845</span><br></pre></td></tr></table></figure>

<h3 id="字符串hash"><a href="#字符串hash" class="headerlink" title="字符串hash"></a>字符串hash</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">先正反各计算出字符串hash值，之后再遍历所有中心，并运用二分的方法</span><br><span class="line">求出最大长度</span><br><span class="line"></span><br><span class="line">由于奇数回文串和偶数回文串不一样，我们为了统一这两种情况，将原字符串</span><br><span class="line">扩展为两倍，即在原字符串每两个直接插入一个无关元素，这样便只需在最后</span><br><span class="line">处理结果时判断回文串的边界是否为无关元素即可</span><br></pre></td></tr></table></figure>


<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2000010</span>, base = <span class="number">131</span>;</span><br><span class="line">ull hl[N], hr[N], p[N];</span><br><span class="line"><span class="comment">//hl表示从左往右的字符串hash</span></span><br><span class="line"><span class="comment">//hr表示从右往左的字符串hash</span></span><br><span class="line">ull l, r, mid, res, t;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="function">ull <span class="title">gett</span><span class="params">(ull h[], ull l, ull r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];  <span class="comment">//计算出l~r的字符串的哈希值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%s"</span>, str + <span class="number">1</span>), <span class="built_in">strcmp</span>(str + <span class="number">1</span>, <span class="string">"END"</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> len = <span class="built_in">strlen</span>(str + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = len * <span class="number">2</span>; i; i -= <span class="number">2</span>)<span class="comment">//扩充字符串以合并奇偶串两种情况</span></span><br><span class="line">		&#123;</span><br><span class="line">			str[i] = str[i / <span class="number">2</span>];</span><br><span class="line">			str[i - <span class="number">1</span>] = <span class="string">'z'</span> + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		len *= <span class="number">2</span>;<span class="comment">//合并完长度要乘以2</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = len; i &lt;= len; i++, j--)<span class="comment">//初始化信息</span></span><br><span class="line">		&#123;</span><br><span class="line">			hl[i] = hl[i - <span class="number">1</span>] * base + str[i] - <span class="string">'a'</span> + <span class="number">1</span>;</span><br><span class="line">			hr[i] = hr[i - <span class="number">1</span>] * base + str[j] - <span class="string">'a'</span> + <span class="number">1</span>;</span><br><span class="line">			p[i] = p[i - <span class="number">1</span>] * base;</span><br><span class="line">		&#125;</span><br><span class="line">		res = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			l = <span class="number">0</span>;</span><br><span class="line">			r = min(i - <span class="number">1</span>, len - i);</span><br><span class="line">			<span class="keyword">while</span> (l &lt; r)<span class="comment">//二分法</span></span><br><span class="line">			&#123;</span><br><span class="line">				mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span> (gett(hl, i - mid, i - <span class="number">1</span>) != gett(hr, len - mid - i + <span class="number">1</span>, len - i))<span class="comment">//注意边界的取值</span></span><br><span class="line">					r = mid - <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					l = mid;</span><br><span class="line">			&#125; </span><br><span class="line">			<span class="comment">//mid可理解为回文串中心到两边的距离</span></span><br><span class="line">			mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (str[i - mid] &gt; <span class="string">'z'</span>)<span class="comment">//如果边界是无用字符</span></span><br><span class="line">				res = max(res, mid);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				res = max(res, mid + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Case %d: %d\n"</span>, ++t, res);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>线性DP</tag>
      </tags>
  </entry>
  <entry>
    <title>递归实现指数型枚举 acwing 92</title>
    <url>/2020/02/17/digui1/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/94/" target="_blank" rel="noopener">Acwing92</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>从 1~n 这 n 个整数中随机选取任意多个，输出所有可能的选择方案。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入一个整数n。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>每行输出一种方案。<br>同一行内的数必须升序排列，相邻两个数用恰好1个空格隔开。<br>对于没有选任何数的方案，输出空行。<br>本题有自定义校验器（SPJ），各行（不同方案）之间的顺序任意。</p>
<!--more-->
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>用二进制数表示每个数的选择情况<br>通过移位运算来枚举所有情况</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (now &gt; n) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (now == n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (state &gt;&gt; i &amp; <span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(now + <span class="number">1</span>, (state &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>); <span class="comment">//选择第now个数</span></span><br><span class="line">	dfs(now + <span class="number">1</span>, state &lt;&lt; <span class="number">1</span>);       <span class="comment">//不选第now个数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>递归实现组合型枚举 acwing 93</title>
    <url>/2020/02/17/digui2/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/95/" target="_blank" rel="noopener">Acwing93</a></p>
<a id="more"></a>
<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>从 1~n 这 n 个整数中随机选出 m 个，输出所有可能的选择方案。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>两个整数 n,m ,在同一行用空格隔开。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>按照从小到大的顺序输出所有方案，每行1个。<br>首先，同一行内的数升序排列，相邻两个数用一个空格隔开。<br>其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面（例如1 3 5 7排在1 3 6 8前面）。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>用二进制数表示每个数的选择情况<br>通过移位运算来枚举所有情况</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> state, <span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (now &gt; n || count + (n-now+<span class="number">1</span>) &lt; m)<span class="comment">//若剩下不足m个则返回</span></span><br><span class="line">		 <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (count == m)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (state &gt;&gt; i &amp; <span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(now + <span class="number">1</span>, state+ (<span class="number">1</span> &lt;&lt; now), count + <span class="number">1</span>);<span class="comment">//选择第now位</span></span><br><span class="line">	dfs(now + <span class="number">1</span>, state , count);<span class="comment">//不选第now位</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>递归实现排列型枚举 acwing 94</title>
    <url>/2020/02/17/digui3/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/96/" target="_blank" rel="noopener">Acwing94</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>把 1~n 这 n 个整数排成一行后随机打乱顺序，输出所有可能的次序。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入一个整数n。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>按照从小到大的顺序输出所有方案，每行1个。<br>首先，同一行相邻两个数用一个空格隔开。<br>其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>直接dfs</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> n,j;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (j == n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; a[k] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!b[i])</span><br><span class="line">        &#123;</span><br><span class="line">            b[i] = <span class="number">1</span>;</span><br><span class="line">            a[j] = i;</span><br><span class="line">            j++;</span><br><span class="line">            dfs();</span><br><span class="line">            j--;</span><br><span class="line">            a[j] = <span class="number">0</span>;</span><br><span class="line">            b[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    dfs();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>最短Hamilton路径 acwing 91</title>
    <url>/2020/02/17/hamilton/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/93/" target="_blank" rel="noopener">Acwing91</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定一张n个点的带权无向图，点从 0~n-1 标号，求起点0 到终点n-1的最短Hamilton路径。 Hamilton路径的定义是从0到 n-1不重不漏地经过每个点恰好一次。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入的第一行为一个整数n，表示棋盘的大小。<br>接下来n行，每行n个0或1的整数，如果一个整数为1，表示对应的位置可以放皇后，如果一个整数为0，表示对应的位置不可以放皇后。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个整数，表示总共有多少种放法。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1≤n≤20</span><br><span class="line">0≤a[i,j]≤1e7</span><br></pre></td></tr></table></figure>

<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">0 2 4 5 1</span><br><span class="line">2 0 6 5 3</span><br><span class="line">4 6 0 8 3</span><br><span class="line">5 5 8 0 5</span><br><span class="line">1 3 3 5 0</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">18</span><br></pre></td></tr></table></figure>

<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e8</span>;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">1</span> &lt;&lt; <span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> w[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hamilton</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(f));     <span class="comment">//将f初始化为无穷(每个值并不等于0x3f)</span></span><br><span class="line">	f[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//经过了一个点，且处在一个点为起始位置</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">			<span class="keyword">if</span> (i &gt;&gt; j &amp; <span class="number">1</span>)<span class="comment">//如果该位为1，假设它为当前所处的点</span></span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++)<span class="comment">//用其他路径更新f[i][j]</span></span><br><span class="line">					<span class="keyword">if</span> ((i ^ (<span class="number">1</span> &lt;&lt; j)) &gt;&gt; k &amp; <span class="number">1</span>)</span><br><span class="line">						f[i][j] = min(f[i][j], f[i ^ (<span class="number">1</span> &lt;&lt; j)][k] + w[k][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; w[i][j];</span><br><span class="line">	hamilton();</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; f[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>][n - <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>位运算</tag>
        <tag>状态压缩dp</tag>
      </tags>
  </entry>
  <entry>
    <title>飞行员兄弟 acwing 116</title>
    <url>/2020/02/17/html-day01/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/118/" target="_blank" rel="noopener">Acwing116</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>飞行员兄弟”这个游戏，需要玩家顺利的打开一个拥有16个把手的冰箱。</p>
<p>已知每个把手可以处于以下两种状态之一：打开或关闭。</p>
<p>只有当所有把手都打开时，冰箱才会打开。</p>
<p>把手可以表示为一个4х4的矩阵，您可以改变任何一个位置[i,j]上把手的状态。</p>
<p>但是，这也会使得第i行和第j列上的所有把手的状态也随着改变。</p>
<p>请你求出打开冰箱所需的切换把手的次数最小值是多少。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入一共包含四行，每行包含四个把手的初始状态。</p>
<p>符号“+”表示把手处于闭合状态，而符号“-”表示把手处于打开状态。</p>
<p>至少一个手柄的初始状态是关闭的。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>第一行输出一个整数N，表示所需的最小切换把手次数。</p>
<p>接下来N行描述切换顺序，每行输入两个整数，代表被切换状态的把手的行号和列号，数字之间用空格隔开。</p>
<p>注意：如果存在多种打开冰箱的方式，则按照优先级整体从上到下，同行从左到右打开。</p>
<p>###思路<br>用二进制数表示每个位置的开关状态<br>并定义一个二维数组，每当状态异或这个数组，便改变其对应行与列的状态</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> change[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;PII;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getbit</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">4</span> * x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, k, state=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">string</span> a;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (a[j] == <span class="string">'+'</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				state += <span class="number">1</span> &lt;&lt; getbit(i, j);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++)</span><br><span class="line">			&#123;</span><br><span class="line">				change[i][j] += <span class="number">1</span> &lt;&lt; getbit(i, k);</span><br><span class="line">				change[i][j] += <span class="number">1</span> &lt;&lt; getbit(k, j);</span><br><span class="line">			&#125;</span><br><span class="line">			change[i][j] -= <span class="number">1</span> &lt;&lt; getbit(i, j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">vector</span>&lt;PII&gt; path;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; <span class="number">16</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">vector</span>&lt;PII&gt; temp;</span><br><span class="line">		<span class="keyword">int</span> now = state;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">16</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (i &gt;&gt; j &amp; <span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> x = j / <span class="number">4</span>;</span><br><span class="line">				<span class="keyword">int</span> y = j % <span class="number">4</span>;</span><br><span class="line">				now ^= change[x][y];</span><br><span class="line">				temp.push_back(&#123; x,y &#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!now &amp;&amp; (path.empty()||path.size()&gt;temp.size())) </span><br><span class="line">			path = temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; path.size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; path.size(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; path[i].first + <span class="number">1</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; path[i].second + <span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>位运算</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>火车进栈 acwing 129</title>
    <url>/2020/02/17/huochejinzhan/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/131/" target="_blank" rel="noopener">Acwing129</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>题目描述<br>这里有nn列火车将要进站再出站，但是，每列火车只有1节，那就是车头。</p>
<p>这nn列火车按11到nn的顺序从东方左转进站，这个车站是南北方向的，它虽然无限长，只可惜是一个死胡同，而且站台只有一条股道，火车只能倒着从西方出去，而且每列火车必须进站，先进后出。</p>
<p>也就是说这个火车站其实就相当于一个栈，每次可以让右侧头火车进栈，或者让栈顶火车出站。</p>
<p>车站示意如图：</p>
<pre><code>出站&lt;——    &lt;——进站
         |车|
         |站|
         |__|</code></pre><p>现在请你按《字典序》输出前2020种可能的出栈方案。</p>
<p>输入格式<br>输入一个整数nn，代表火车数量。</p>
<p>输出格式<br>按照《字典序》输出前2020种答案，每行一种，不要空格。</p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">123</span><br><span class="line">132</span><br><span class="line">213</span><br><span class="line">231</span><br><span class="line">321</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>dfs 分为三块，出栈，栈内，未进栈，dfs搜索所有情况</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, cnt=<span class="number">20</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;p3;  <span class="comment">//表示出栈的火车</span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;p2;   <span class="comment">//表示栈中的火车</span></span><br><span class="line"><span class="keyword">int</span> p1=<span class="number">1</span>;       <span class="comment">//表示还未进栈的火车</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (cnt == <span class="number">0</span>)    <span class="comment">//当输出满20个时结束</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (p3.size() == n)</span><br><span class="line">	&#123;</span><br><span class="line">		cnt--;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> x : p3) <span class="built_in">cout</span> &lt;&lt; x;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//为了保证字典序，出栈应优先于入栈</span></span><br><span class="line">	<span class="keyword">if</span> (p2.size())<span class="comment">//搜索出栈情况</span></span><br><span class="line">	&#123;</span><br><span class="line">		p3.push_back(p2.top());</span><br><span class="line">		p2.pop();</span><br><span class="line">		dfs();</span><br><span class="line">		p2.push(p3.back());</span><br><span class="line">		p3.pop_back();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (p1 &lt;= n)<span class="comment">//搜索所有入栈的情况</span></span><br><span class="line">	&#123;</span><br><span class="line">		p2.push(p1);</span><br><span class="line">		p1++;</span><br><span class="line">		dfs();</span><br><span class="line">		p1--;</span><br><span class="line">		p2.pop();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	dfs();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>木棒 acwing 167</title>
    <url>/2020/02/17/mubang/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/169/" target="_blank" rel="noopener">Acwing167</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>乔治拿来一组等长的木棒，将它们随机地砍断，使得每一节木棍的长度都不超过50个长度单位。然后他又想把这些木棍恢复到为裁截前的状态，但忘记了初始时有多少木棒以及木棒的初始长度。请你设计一个程序，帮助乔治计算木棒的可能最小长度。每一节木棍的长度都用大于零的整数表示</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入包含多组数据，每组数据包括两行。</p>
<p>第一行是一个不超过64的整数，表示砍断之后共有多少节木棍。</p>
<p>第二行是截断以后，所得到的各节木棍的长度。</p>
<p>在最后一组数据之后，是一个零。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>为每组数据，分别输出原始木棒的可能最小长度，每组数据占一行。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>数据保证每一节木棍的长度均不大于50。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9</span><br><span class="line">5 2 1 5 2 1 5 2 1</span><br><span class="line">4</span><br><span class="line">1 2 3 4</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">5</span><br></pre></td></tr></table></figure>

<h3 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.优化搜索顺序</span><br><span class="line">  把木棒的长度从大到小排序，优先尝试较长的木棍</span><br><span class="line">2.排除等效冗余</span><br><span class="line"> (1)可以限制先后加入一根原始木棒的木棍长度是递减的。这是因为先拼</span><br><span class="line">    上长度为x的木棍，再拼上一根长度为y的木棍与先拼y再拼x是等效的。</span><br><span class="line"> (2)对于当前原始木棒，记录最近一次尝试拼接的木棒长度。如果分支搜索</span><br><span class="line">    失败回溯，不再尝试向该木棒中拼接其他相同长度的木棍</span><br><span class="line"> (3)如果在当前拼接的木棒中，尝试拼接第一根木棍就失败，那么该分支</span><br><span class="line">    直接判定为失败，因为剩余的待拼接的木棒都是等价的。</span><br><span class="line"> (4)如果在当前木棒中拼入最后一根木棍后，当前木棒恰被拼接完整，但在</span><br><span class="line">    接下来的某分支中返回失败，则当前分支直接判定为失败，立即回溯。</span><br><span class="line">    因为即使接下来可以将当前木棒拼接完整，用的也是多个更小的木棒</span><br><span class="line">	显然不会优于当前情况</span><br></pre></td></tr></table></figure>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> vis[N], a[N], n, true_n, len, cnt, temp, sum, i, j;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//正在拼第stick根木棒(已经拼好了stick-1根)</span></span><br><span class="line"><span class="comment">//第stick根木棒的当前长度为cab</span></span><br><span class="line"><span class="comment">//拼接到第stick根木棒中的上一根小木棍为last</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> stick, <span class="keyword">int</span> cab, <span class="keyword">int</span> last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (stick &gt; cnt)<span class="comment">//</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span> (cab == len)</span><br><span class="line">		<span class="keyword">return</span> dfs(stick + <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> fail = <span class="number">0</span>;<span class="comment">//剪枝2</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = last; i &lt;= true_n; i++)<span class="comment">//剪枝1</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!vis[i]&amp;&amp;cab+a[i]&lt;=len&amp;&amp;a[i]!=fail)</span><br><span class="line">		&#123;</span><br><span class="line">			vis[i] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (dfs(stick, cab + a[i], i + <span class="number">1</span>))</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			vis[i] = <span class="number">0</span>;</span><br><span class="line">			fail = a[i];</span><br><span class="line">			<span class="keyword">if</span> (cab == <span class="number">0</span> || cab + a[i] == len)<span class="comment">//剪枝3，4</span></span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//所有分支均尝试过，搜索失败</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &amp;&amp; n)</span><br><span class="line">	&#123;</span><br><span class="line">		true_n = <span class="number">0</span>;</span><br><span class="line">		sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">			<span class="keyword">if</span> (temp &gt; <span class="number">50</span>)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			a[++true_n] = temp;</span><br><span class="line">			sum += temp;</span><br><span class="line">		&#125;</span><br><span class="line">		sort(a + <span class="number">1</span>, a + <span class="number">1</span> + true_n, cmp);</span><br><span class="line">		<span class="keyword">for</span> (j = a[true_n]; j &lt;= sum; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (sum%j != <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="comment">//原木棒长度为len，共cnt根</span></span><br><span class="line">			len = j;</span><br><span class="line">			cnt = sum / j;</span><br><span class="line">			<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">			<span class="keyword">if</span> (dfs(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; j &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>dfs</tag>
        <tag>剪枝</tag>
      </tags>
  </entry>
  <entry>
    <title>a^b acwing 89</title>
    <url>/2020/02/17/quickcloth/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/91/" target="_blank" rel="noopener">Acwing89</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>求a的b次方对p取模的值。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>三个整数 a,b,p ,在同一行用空格隔开。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个整数，表示<code>a^b mod p</code>的值。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0≤a,b,p≤1e9</span><br></pre></td></tr></table></figure>

<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 2 7</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll res=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">power</span><span class="params">(ll a, ll b,ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">			res = res * a%p;</span><br><span class="line">		a = a * a%p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll a, b, p;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; p;</span><br><span class="line">	power(a, b, p);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>位运算</tag>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>数组模拟邻接表</title>
    <url>/2020/02/17/shuzuljb/</url>
    <content><![CDATA[<p>数组模拟邻接表模板</p>
<a id="more"></a>

<p>这两天做到了很多这样的问题，所以我就想写一下关于这个问题的一些总结</p>
<p>首先我们先看一下常见的代码模板</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to;  <span class="comment">//子节点</span></span><br><span class="line">	<span class="keyword">int</span> w;   <span class="comment">//权值</span></span><br><span class="line">	<span class="keyword">int</span> next;<span class="comment">//head链表的下一个节点</span></span><br><span class="line"></span><br><span class="line">&#125; edge[N * <span class="number">2</span>]; <span class="comment">//N表示的是边的个数，两倍是针对无向边</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], idx = <span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	edge[idx].to = to; <span class="comment">//标记子节点</span></span><br><span class="line">	edge[idx].w = w;   <span class="comment">//记录权值</span></span><br><span class="line">	edge[idx].next = head[from];  <span class="comment">//找出head[from]链表里的下一个元素</span></span><br><span class="line">	head[from] = idx++; </span><br><span class="line">	<span class="comment">//head[from]链表的表头为idx，下一条插入图中的边idx将为idx+1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这里面比较难理解的地方在与这个加边算法，也就是链式向前星。为了思考的方便，我们先不加上w，也就是权重去除。先从一个简单的情况开始思考，也就是存在这样几条边<font color="#bf0000" size="6px"><code>0,1</code></font>、<font color="#bf0000" size="6px"><code>0,2</code></font>、<font color="#bf0000" size="6px"><code>0,3</code></font>、<font color="#bf0000" size="6px"><code>1,3</code></font>、<font color="#bf0000" size="6px"><code>2,3</code></font>。</p>
<p><img src="/images/shuzuljb1.png" alt="alt"></p>
<p>首先考虑添加<font color="#bf0000" size="6px"><code>0-&gt;1</code></font>这条边，此时我们的<font color="#bf0000" size="6px"><code>edge[0] = {to:1, next:-1}</code></font></p>
<p><img src="/images/shuzuljb2.png" alt="alt"></p>
<p>此时我们就可以通过<font color="#bf0000" size="6px"><code>head[0]</code></font>找到<font color="#bf0000" size="6px"><code>edge[0]</code></font>，怎么做的呢？可以这样做</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = head[<span class="number">0</span>];</span><br><span class="line">i = edge[i].next;</span><br></pre></td></tr></table></figure>
<p>上面这两个代码非常重要，使我们遍历整个图的基础。接着添加边<font color="#bf0000" size="6px"><code>0-&gt;2</code></font>，此时我们的<font color="#bf0000" size="6px"><code>edge[1] = {to:2, next:0}</code></font></p>
<p><img src="/images/shuzuljb3.png" alt="alt"></p>
<p>此时我们就可以通过<font color="#bf0000" size="6px"><code>head[0]</code></font>找到<font color="#bf0000" size="6px"><code>edge[1]</code></font>。接下来的过程就是一些重复操作了，最后结果如下</p>
<p><img src="/images/shuzuljb4.png" alt="alt"></p>
<p>那么通过这个图，你就可以发现，每个<font color="#bf0000" size="6px"><code>head[x]</code></font>后面存储的实际上就是<font color="#bf0000" size="6px"><code>x</code></font>的所有子节点。</p>
<p>接着我们就需要思考一下如何遍历这个图，首先通过<font color="#bf0000" size="6px"><code>dfs</code></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    visited[u] = <span class="literal">true</span>;</span><br><span class="line">	<span class="comment">//  ~运算，遇到-1时停止，可替代 &gt;=0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = edge[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> son = edge[i].to;</span><br><span class="line">        <span class="keyword">if</span> (!visited[son]) dfs(son);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>其中<font color="#bf0000" size="6px"><code>u</code></font>表示我们当前遍历的节点。对于深度优先搜索的话，有了前面的图就很好理解了，就是每次遍历一个<font color="#bf0000" size="6px"><code>head</code></font>的所有节点，再从每个节点开始<font color="#bf0000" size="6px"><code>dfs</code></font>。对于访问过的节点，我们需要将其标记为<font color="#bf0000" size="6px"><code>visited</code></font>。</p>
<p>接着我们看如何<font color="#bf0000" size="6px"><code>bfs</code></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"><span class="keyword">bool</span> visited[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">    q[<span class="number">0</span>] = u;</span><br><span class="line">    visited[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = q[hh++];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[t]; ~i; i = edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> son = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span> (!visited[son])</span><br><span class="line">            &#123;</span><br><span class="line">                q[++tt] = son;</span><br><span class="line">                visited[son] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于广度优先搜索的话，有了前面的图就很好理解了，就是每次遍历一个<font color="#bf0000" size="6px"><code>head</code></font>的所有节点。我们每次将当前节点<font color="#bf0000" size="6px"><code>u</code></font>的所有子节点添加到队列<font color="#bf0000" size="6px"><code>q</code></font>中，然后将其标记为访问过了（添加到<font color="#bf0000" size="6px"><code>visited</code></font>中）。终止条件就是遍历到了<font color="#bf0000" size="6px"><code>-1</code></font>，也就是<font color="#bf0000" size="6px"><code>~i</code></font>继续遍历。</p>
]]></content>
      <categories>
        <category>代码模板</category>
      </categories>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
</search>
