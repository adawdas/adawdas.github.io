<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>股票买卖V acwing 1058</title>
    <url>/2020/04/14/ac1058/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/1060/" target="_blank" rel="noopener">Acwing1058</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定一个长度为 N 的数组，数组中的第 i 个数字表示一个给定股票在第 i 天的价格。</p>
<p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>
<p>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含整数 N，表示数组长度。</p>
<p>第二行包含 N 个不超过 10000 的正整数，表示完整的数组。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个整数，表示最大利润。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤N≤1e5</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1 2 3 0 2</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<h3 id="状态机dp"><a href="#状态机dp" class="headerlink" title="状态机dp"></a>状态机dp</h3><p><code>f[i][0]</code>表示遍历为前<code>i</code>个股票，当前有票<br><code>f[i][1]</code>表示遍历完前<code>i</code>个股票，当前为无票的第<code>1</code>天（当天刚出售了股票）<br><code>f[i][2]</code>表示遍历完前<code>i</code>个股票，当前无票的天数为<code>2</code>天及以上</p>
<p>状态方程：<br><code>f[i][0]=max(f[i-1][0],f[i-1][2]-w[i])</code><br><code>f[i][1]=f[i-1][0]+w[i]</code><br><code>f[i][2]=max(f[i-1][1],f[i-1][2])</code></p>
<p>初始状态<br><code>f[0][0]=f[0][1]=-INF</code><br><code>f[0][2]=0</code></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> w[N];</span><br><span class="line"><span class="keyword">int</span> f[N][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;w[i]);</span><br><span class="line"></span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = f[<span class="number">0</span>][<span class="number">1</span>] = -INF, f[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        f[i][<span class="number">0</span>] = max(f[i - <span class="number">1</span>][<span class="number">0</span>], f[i - <span class="number">1</span>][<span class="number">2</span>] - w[i]);</span><br><span class="line">        f[i][<span class="number">1</span>] = f[i - <span class="number">1</span>][<span class="number">0</span>] + w[i];</span><br><span class="line">        f[i][<span class="number">2</span>] = max(f[i - <span class="number">1</span>][<span class="number">2</span>], f[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, max(f[n][<span class="number">1</span>], f[n][<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>股票买卖IV acwing 1057</title>
    <url>/2020/04/14/ac1057/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/1059/" target="_blank" rel="noopener">Acwing1057</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定一个长度为 N 的数组，数组中的第 i 个数字表示一个给定股票在第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润，你最多可以完成 k 笔交易。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。一次买入卖出合为一笔交易。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含整数 N 和 k，表示数组的长度以及你可以完成的最大交易数量。</p>
<p>第二行包含 N 个不超过 10000 的正整数，表示完整的数组。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个整数，表示最大利润。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤N≤1e5,<br>1≤k≤100</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6 2</span><br><span class="line">3 2 6 5 0 3</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure>

<h3 id="状态机dp"><a href="#状态机dp" class="headerlink" title="状态机dp"></a>状态机dp</h3><p><code>f[i][j][0]</code>表示遍历完前<code>i</code>个股票，做了<code>j</code>次交易且当前无票的状态<br><code>f[i][j][1]</code>表示遍历完前<code>i</code>个股票，做了<code>j</code>次交易且当前有票的状态<br><code>f[i][j][k]</code>的值表示当前状态下所能获得的最大收益<br>初始状态：<code>f[i][0][0]</code> <code>(1≤i≤n)</code>初始化为<code>0</code>,其余初始化为<code>-INF</code><br>保证所有状态从<code>f[i][0][0]</code>转移过来<br>注：购票时算做了一次交易，售票时不再统计</p>
<p>状态方程：<br><code>f[i][j][0]=max(f[i-1][j][0],f[i-1][j][1]+w[i])</code><br><code>f[i][j][1]=max(f[i-1][j][1],f[i-1][j-1][0]-w[i])</code></p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>经观察我们发现，所有的<code>f[i][j][k]</code>均由<code>f[i-1][...][...]</code>转移过来，即本层<code>i</code>只会用到<code>i-1</code>的状态。运用类似01背包的思想，我们可以将<code>j</code>从大到小枚举，这样就可以优化掉一维，且保证当前状态只会由上一层转移过来<br>状态方程：<br><code>f[j][0] = max(f[j][0], f[j][1] + w[i])</code><br><code>f[j][1] = max(f[j][1], f[j - 1][0] - w[i])</code><br>初始状态：<code>f[0][0]=0</code></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">100010</span>][<span class="number">110</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">-0x3f3f3f3f</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">        f[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j][<span class="number">0</span>] = max(f[i - <span class="number">1</span>][j][<span class="number">0</span>], f[i - <span class="number">1</span>][j][<span class="number">1</span>] + a[i]);</span><br><span class="line">            f[i][j][<span class="number">1</span>] = max(f[i - <span class="number">1</span>][j][<span class="number">1</span>], f[i - <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">0</span>] - a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; i++)</span><br><span class="line">        res = max(res, f[n][i][<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优化代码"><a href="#优化代码" class="headerlink" title="优化代码"></a>优化代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">110</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">-0x3f3f3f3f</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    </span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = k; j &gt;= <span class="number">1</span>;j--)</span><br><span class="line">        &#123;</span><br><span class="line">            f[j][<span class="number">0</span>] = max(f[j][<span class="number">0</span>], f[j][<span class="number">1</span>] + a[i]);</span><br><span class="line">            f[j][<span class="number">1</span>] = max(f[j][<span class="number">1</span>], f[j - <span class="number">1</span>][<span class="number">0</span>] - a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; i++)</span><br><span class="line">        res = max(res, f[i][<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>骑士 acwing 1064</title>
    <url>/2020/04/13/ac1064/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/1066/" target="_blank" rel="noopener">Acwing1064</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>在 n×n 的棋盘上放 k 个国王，国王可攻击相邻的 8 个格子，求使它们无法互相攻击的方案总数。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>共一行，包含两个整数 n 和 k。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>共一行，表示方案总数，若不能够放置则输出0。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤n≤10,<br>0≤k≤n2</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 2</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">16</span><br></pre></td></tr></table></figure>

<h3 id="状态压缩dp"><a href="#状态压缩dp" class="headerlink" title="状态压缩dp"></a>状态压缩dp</h3><p><code>f[i][j][k]</code>表示遍历完了前<code>i</code>行，放了<code>j</code>个棋子，最后一行的状态为<code>k</code>的状态的集合，<code>f[i][j][k]</code>的值为方案总数<br>首先找出行内的合法状态(无相邻棋子),再找出相邻两行之间的合法状态（两状态相或后的状态无相邻的1），用二维向量存储<br>状态方程<br><code>f[i][j][a]+=f[i-1][j-cnt[state[a]][b]</code><br><code>a</code>,<code>b</code>分别为状态向量<code>state</code>中元素下标，<code>cnt[state[a]]</code>为<code>state[a]</code>状态中<code>1</code>的个数，<code>a</code>，<code>b</code>互为相邻合法状态</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">12</span>, M = <span class="number">1</span> &lt;&lt; <span class="number">11</span>, K = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[N][K][M];</span><br><span class="line"><span class="keyword">int</span> cnt[M];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; state;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; head[M];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i++)</span><br><span class="line">        <span class="keyword">if</span>((s&gt;&gt;i&amp;<span class="number">1</span>)&amp;&amp;(s&gt;&gt;(i+<span class="number">1</span>)&amp;<span class="number">1</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i++)</span><br><span class="line">        res += s &gt;&gt; i &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n;i++)</span><br><span class="line">        <span class="keyword">if</span>(check(i))</span><br><span class="line">        &#123;</span><br><span class="line">            state.push_back(i);</span><br><span class="line">            cnt[i] = count(i);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; state.size();i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; state.size();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a = state[i];</span><br><span class="line">            <span class="keyword">int</span> b = state[j];</span><br><span class="line">            <span class="keyword">if</span>((a&amp;b)==<span class="number">0</span>&amp;&amp;check(a|b))</span><br><span class="line">                head[i].push_back(j);</span><br><span class="line">        &#125;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= k;j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; state.size();a++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> b:head[a])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> c = cnt[state[b]];</span><br><span class="line">                    <span class="keyword">if</span>(j&gt;=c)</span><br><span class="line">                        f[i][j][b] += f[i - <span class="number">1</span>][j - c][a];</span><br><span class="line">                &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[n + <span class="number">1</span>][k][<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>玉米田 acwing 327</title>
    <url>/2020/04/13/ac327/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/329/" target="_blank" rel="noopener">Acwing327</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>农夫约翰的土地由M*N个小方格组成，现在他要在土地里种植玉米。<br>非常遗憾，部分土地是不育的，无法种植。<br>而且，相邻的土地不能同时种植玉米，也就是说种植玉米的所有方格之间都不会有公共边缘。<br>现在给定土地的大小，请你求出共有多少种种植方法。<br>土地上什么都不种也算一种方法。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第1行包含两个整数M和N。</p>
<p>第2..M+1行：每行包含N个整数0或1，用来描述整个土地的状况，1表示该块土地肥沃，0表示该块土地不育。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出总种植方法对100000000取模后的值。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤M,N≤12</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 3</span><br><span class="line">1 1 1</span><br><span class="line">0 1 0</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure>

<h3 id="状态压缩dp"><a href="#状态压缩dp" class="headerlink" title="状态压缩dp"></a>状态压缩dp</h3><p><code>f[i][j]</code>表示遍历完前<code>i</code>行，且当前行的状态为<code>j</code>的集合，<code>f[i][j]</code>的值表示方案数。<br>本题与<a href="https://www.acwing.com/problem/content/1066/" target="_blank" rel="noopener">Acwing1064</a>不同，本题对放置的个数无要求，故可直接删去数量这一维。<br>状态方程<br><code>f[i][j]+=f[i-1][k]</code> <code>(j,k互为合法状态且j与w[i]互为合法状态)</code></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">14</span>, M = <span class="number">1</span> &lt;&lt; <span class="number">12</span>, mod = <span class="number">1e8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> w[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; state;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; head[M];</span><br><span class="line"><span class="keyword">int</span> f[N][M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + <span class="number">1</span> &lt; m; i ++ )</span><br><span class="line">        <span class="keyword">if</span> ((state &gt;&gt; i &amp; <span class="number">1</span>) &amp;&amp; (state &gt;&gt; i + <span class="number">1</span> &amp; <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">            w[i] += !t * (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; m; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (check(i))</span><br><span class="line">            state.push_back(i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; state.size(); i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; state.size(); j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a = state[i], b = state[j];</span><br><span class="line">            <span class="keyword">if</span> (!(a &amp; b))</span><br><span class="line">                head[i].push_back(j);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; state.size(); j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!(state[j] &amp; w[i]))</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k : head[j])</span><br><span class="line">                    f[i][j] = (f[i][j] + f[i - <span class="number">1</span>][k]) % mod;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[n + <span class="number">1</span>][<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>陪审团 acwing 280</title>
    <url>/2020/04/12/ac280/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/282/" target="_blank" rel="noopener">Acwing280</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>在一个遥远的国家，一名嫌疑犯是否有罪需要由陪审团来决定。</p>
<p>陪审团是由法官从公民中挑选的。</p>
<p>法官先随机挑选N个人（编号1,2…,N）作为陪审团的候选人，然后再从这N个人中按照下列方法选出M人组成陪审团。</p>
<p>首先，参与诉讼的控方和辩方会给所有候选人打分，分值在0到20之间。</p>
<p>第 i 个人的得分分别记为p[i]和d[i]。</p>
<p>为了公平起见，法官选出的M个人必须满足：辩方总分D和控方总分P的差的绝对值|D-P|最小。</p>
<p>如果选择方法不唯一，那么再从中选择辨控双方总分之和D+P最大的方案。</p>
<p>求最终的陪审团获得的辩方总分D、控方总分P，以及陪审团人选的编号。</p>
<p>注意：若陪审团的人选方案不唯一，则任意输出一组合法方案即可。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入包含多组测试数据。</p>
<p>每组测试数据第一行包含两个整数N和M。</p>
<p>接下来N行，每行包含两个整数p[i]和d[i]。</p>
<p>每组测试数据之间隔一个空行。</p>
<p>当输入数据N=0，M=0时，表示结束输入，该数据无需处理。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>对于每组数据，第一行输出’Jury #C’，C为数据编号，从1开始。</p>
<p>第二行输出“Best jury has value P for prosecution and value D for defence:”，P为控方总分，D为辩方总分。</p>
<p>第三行输出按升序排列的陪审人选编号，每个编号前输出一个空格。</p>
<p>每组数据输出完后，输出一个空行。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤N≤200,<br>1≤M≤20<br>0≤p[i],d[i]≤20</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 2</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">4 1</span><br><span class="line">6 2</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Jury #1</span><br><span class="line">Best jury has value 6 for prosecution and value 4 for defence:</span><br><span class="line"> 2 3</span><br></pre></td></tr></table></figure>

<h3 id="状态表示"><a href="#状态表示" class="headerlink" title="状态表示"></a>状态表示</h3><p><code>f[i][j][k]</code>表示遍历完前<code>i</code>个候选人后，选了<code>j</code>个候选人并且两方的总分的差值为<code>k</code>的所有情况的集合<br><code>f[i][j][k]</code>的值表示该种情况下所能取得的两方的总分的和的最大值</p>
<p>初始化<br>保证所有的结果都是从0状态转移过来的<br>所以<code>f[0][0][base]</code>初始化为<code>0</code>，其余为<code>-INF</code><br>状态转移<br>1 不选第<code>i</code>个人<br><code>f[i][j][k]=f[i-1][j][k]</code><br>2.选第<code>i</code>个人<br><code>f[i][j][k]=max(f[i][j][k],f[i-1][j-1][k-(p[i]-d[i])]+p[i]+d[i])</code><br><code>(0&lt;=k-(p[i]-d[i])&lt;=800&amp;&amp;j&gt;=1)</code></p>
<p>还原结果<br>首先在<code>base</code>左右寻找第一个非负值，偏离量为<code>v</code><br>之后枚举<code>f[n][m][v]</code><br>若<code>f[i][j][k]==f[i-1][j][k]</code>,表示没有选第i个人是符合条件的一个解，<br><code>i--</code>即可<br>否则，第<code>i</code>个人的加入使得结果发生了变化，则一定选了第<code>i</code>个人，此时将第<code>i</code>个人加入结果，并更新<code>i--,j--,k-=(p[i]-d[i])</code></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">210</span>, M = <span class="number">801</span>, base = <span class="number">400</span>;</span><br><span class="line"><span class="keyword">int</span> f[N][<span class="number">21</span>][M];</span><br><span class="line"><span class="keyword">int</span> p[N], d[N], ans[N];</span><br><span class="line"><span class="keyword">int</span> n, m, c;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m),n||m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;p[i], &amp;d[i]);</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">-0x3f</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>][base] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m;j++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; M;k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    f[i][j][k] = f[i - <span class="number">1</span>][j][k];</span><br><span class="line">                    <span class="keyword">if</span>(j&lt;<span class="number">1</span>)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">int</span> t = k - (p[i] - d[i]);</span><br><span class="line">                    <span class="keyword">if</span>(t&lt;<span class="number">0</span>||t&gt;=M)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    f[i][j][k] = max(f[i][j][k], f[i - <span class="number">1</span>][j - <span class="number">1</span>][t] + p[i] + d[i]);</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">int</span> v = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(f[n][m][base-v]&lt;<span class="number">0</span>&amp;&amp;f[n][m][base+v]&lt;<span class="number">0</span>)</span><br><span class="line">            v++;</span><br><span class="line">        <span class="keyword">if</span>(f[n][m][base-v]&gt;f[n][m][base+v])</span><br><span class="line">            v = base - v;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            v = base + v;</span><br><span class="line">        <span class="keyword">int</span> i = n, j = m, k = v;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(f[i][j][k]==f[i<span class="number">-1</span>][j][k])</span><br><span class="line">                i--;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ans[cnt++] = i;</span><br><span class="line">                k-=(p[i]-d[i]);</span><br><span class="line">                i--;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> tp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> td = <span class="number">0</span>;</span><br><span class="line">        sort(ans, ans + cnt);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            tp += p[ans[i]];</span><br><span class="line">            td += d[ans[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Jury #%d\n"</span>, ++c);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Best jury has value %d for prosecution and value %d for defence:\n"</span>, tp, td);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt;i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" %d"</span>, ans[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>环路运输 acwing 289</title>
    <url>/2020/04/12/ac289/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/291/" target="_blank" rel="noopener">Acwing289</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>在一条环形公路旁均匀地分布着N座仓库，编号为1~N，编号为 i 的仓库与编号为 j 的仓库之间的距离定义为 dist(i,j)=min⁡(|i-j|,N-|i-j|)，也就是逆时针或顺时针从 i 到 j 中较近的一种。</p>
<p>每座仓库都存有货物，其中编号为 i 的仓库库存量为 Ai。</p>
<p>在 i 和 j 两座仓库之间运送货物需要的代价为 Ai+Aj+dist(i,j)。</p>
<p>求在哪两座仓库之间运送货物需要的代价最大。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含一个整数N。</p>
<p>第二行包含N个整数A1~AN。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个整数，表示最大代价。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤N≤106,<br>1≤Ai≤107</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1 8 6 2 5</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">15</span><br></pre></td></tr></table></figure>

<h3 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3><p>由于dist(i,j)=dist(j,i)，对于任意i，我们只需求[i-n/2,i]区间内的A[i]+A[j]+i-j即可，而对于任意i，i+A[i]为定值。所以原题转化为求任意[i-n/2,i]区间内的-j+A[j]的最大值，即滑动窗口问题<br>题中所给的是环形结构，这里用最经典的破环成链方法，将原数组的复制接到原数组的后面即可。</p>
<h3 id="代码-数组"><a href="#代码-数组" class="headerlink" title="代码(数组)"></a>代码(数组)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> w[N];</span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;w[i]);</span><br><span class="line">        w[i + n] = w[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> len = n / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * <span class="number">2</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (hh &lt;= tt &amp;&amp; q[hh] &lt; i - len) hh ++ ;</span><br><span class="line">        res = max(res, i - q[hh] + w[q[hh]] + w[i]);</span><br><span class="line">        <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; w[q[tt]] - q[tt] &lt;= w[i] - i) tt -- ;</span><br><span class="line">        q[ ++ tt] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码（deque）"><a href="#代码（deque）" class="headerlink" title="代码（deque）"></a>代码（deque）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">int</span> a[N*<span class="number">2</span>];</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        a[i + n] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = n / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (q.size() &amp;&amp; q.front() + len &lt; i)</span><br><span class="line">            q.pop_front();</span><br><span class="line">        res = max(res, i - q.front() + a[q.front()] + a[i]);</span><br><span class="line">        <span class="keyword">while</span> (q.size() &amp;&amp; -q.back() + a[q.back()] &lt;= -i + a[i])</span><br><span class="line">            q.pop_back();</span><br><span class="line">        q.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title>休息时间 acwing 288</title>
    <url>/2020/04/12/ac288/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/290/" target="_blank" rel="noopener">Acwing288</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>在某个星球上，一天由 N 个小时构成，我们称0点到1点为第1个小时、1点到2点为第2个小时，以此类推。</p>
<p>在第 i 个小时睡觉能够恢复Ui点体力。</p>
<p>在这个星球上住着一头牛，它每天要休息B个小时。</p>
<p>它休息的这B个小时不一定连续，可以分成若干段，但是在每段的第一个小时，它需要从清醒逐渐入睡，不能恢复体力，从下一个小时开始才能睡着。</p>
<p>为了身体健康，这头牛希望遵循生物钟，每天采用相同的睡觉计划。</p>
<p>另外，因为时间是连续的，即每一天的第N个小时和下一天的第1个小时是相连的（N点等于0点），这头牛只需要在每N个小时内休息够B个小时就可以了。</p>
<p>请你帮忙给这头牛安排一个睡觉计划，使它每天恢复的体力最多。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第1行输入两个空格隔开的整数N和B。</p>
<p>第2..N+1行，第 i+1 行包含一个整数Ui。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个整数，表示恢复的体力值。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>3≤N≤3830<br>2≤B&lt;N<br>0≤Ui≤200000</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 3</span><br><span class="line">2</span><br><span class="line">0</span><br><span class="line">3</span><br><span class="line">1</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure>

<h3 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h3><p>这头牛每天3点入睡，睡到次日1点，即[1,4,2]时间段休息，每天恢复体力值最大，为0+4+2=6。</p>
<h3 id="状态表示"><a href="#状态表示" class="headerlink" title="状态表示"></a>状态表示</h3><p><code>f[i][j][0]</code>表示第i小时一共睡了j小时且第i小时没有在睡觉的集合<br><code>f[i][j][1]</code>表示第i小时一共睡了j小时且第i小时在睡觉的集合<br>易得状态转移方程<br><code>f[i][j][0]=max(f[i-1][j][0],f[i-1][j][1])</code><br><code>f[i][j][1]=max(f[i-1][j-1][0],f[i-1][j-1][1]+w[i])</code></p>
<p>为了区分是否跨越了一天，这里对第N小时的情况进行了划分：<br>若第N小时在睡觉，同时第1小时在睡觉，那么第一小时可以恢复体力<br>其余情况下第一小时均不可恢复体力<br>故有初始状态为<br><code>f[1][0][0]=0,f[1][1][1]=0</code> (第N小时没有睡觉)<br><code>f[1][0][0]=0,f[1][1][1]=w[i]</code> (第N小时在睡觉)</p>
<p>最终结果为对第一个初始状态求出的<code>f[n][m][0]</code><br>和对第二个初始状态求出的<code>f[n][m][1]</code>取最大值</p>
<p>因空间限制，本题采用了滚动数组</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4000</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">2</span>][N][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> w[N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; w[i];</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-0x3f</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i &amp; <span class="number">1</span>][j][<span class="number">0</span>] = max(f[i - <span class="number">1</span> &amp; <span class="number">1</span>][j][<span class="number">0</span>], f[i - <span class="number">1</span> &amp; <span class="number">1</span>][j][<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(j)</span><br><span class="line">                f[i &amp; <span class="number">1</span>][j][<span class="number">1</span>] = max(f[i - <span class="number">1</span> &amp; <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">0</span>], f[i - <span class="number">1</span> &amp; <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">1</span>] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">int</span> res = f[n &amp; <span class="number">1</span>][m][<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-0x3f</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] = w[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i &amp; <span class="number">1</span>][j][<span class="number">0</span>] = max(f[i - <span class="number">1</span> &amp; <span class="number">1</span>][j][<span class="number">0</span>], f[i - <span class="number">1</span> &amp; <span class="number">1</span>][j][<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(j)</span><br><span class="line">                f[i &amp; <span class="number">1</span>][j][<span class="number">1</span>] = max(f[i - <span class="number">1</span> &amp; <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">0</span>], f[i - <span class="number">1</span> &amp; <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">1</span>] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    res = max(res, f[n &amp; <span class="number">1</span>][m][<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>背包问题</title>
    <url>/2020/04/11/beibao/</url>
    <content><![CDATA[<p>几类背包问题</p>
<a id="more"></a>

<h3 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h3><p>原题链接：<a href="https://www.acwing.com/problem/content/2/" target="_blank" rel="noopener">Acwing2</a></p>
<p>有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。</p>
<p>第 i 件物品的体积是 vi，价值是 wi。</p>
<p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出最大价值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = m; j &gt;= w[i]; j--) </span><br><span class="line">    	f[j] = max(f[j], f[j-w[i]] + v[i]);</span><br></pre></td></tr></table></figure>

<p>从大到小循环的原因是<code>f[i,j]</code>要用<code>f[i-1,j-v[i]]+w[i]</code>来更新，从大到小可以保证算<code>f[j]</code>时用到的<code>f[j-v[i]]</code>存储的是<code>f[i-1,j-v[i]]</code>，而不是<code>f[i,j-v[i]]</code>；如果从小到大循环，那么<code>f[j-v[i]]</code>会在<code>f[j]</code>前被计算出来，那么它就表示<code>f[i,j-v[i]]</code>了。</p>
<p>若f数组全被初始化为0，则直接输出f[V]<br>若f数组除了f[0],其余被初始化为-INF，则要循环枚举所有体积</p>
<p>因为初始化为-INF，所有状态都由0转移过来<br>而初始化为0，所有状态都由任意状态转移过来，此时f[V]包含了所有可能体积的最大可能值</p>
<h3 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h3><p>原题链接：<a href="https://www.acwing.com/problem/content/3/" target="_blank" rel="noopener">Acwing3</a><br>有 N 种物品和一个容量是 V 的背包，每种物品都有无限件可用。</p>
<p>第 i 种物品的体积是 vi，价值是 wi。</p>
<p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出最大价值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = w[i]; j &lt;= m; j++) </span><br><span class="line">    	f[j] = max(f[j], f[j-w[i]] + v[i]);</span><br></pre></td></tr></table></figure>

<p>从小到大循环保证了<code>f[i,j]</code>是用<code>f[i,j-v[i]]+w[i]</code>来更新，那么每一层<code>i</code>循环中<code>f[j-v[i]]</code>会在<code>f[j]</code>前被计算出来，体现了物品可以重复利用</p>
<h3 id="多重背包问题I"><a href="#多重背包问题I" class="headerlink" title="多重背包问题I"></a>多重背包问题I</h3><p>原题链接：<a href="https://www.acwing.com/problem/content/4/" target="_blank" rel="noopener">Acwing4</a><br>有 N 种物品和一个容量是 V 的背包。</p>
<p>第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。</p>
<p>求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。<br>输出最大价值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = m; j &gt;= w[i];j--)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k * w[i] &lt;= j &amp;&amp; k &lt;= s[i]; k++)</span><br><span class="line">            f[j] = max(f[j], f[j - k * w[i]] + k * v[i]);</span><br></pre></td></tr></table></figure>

<p>类似于01背包问题，此方法是将所有物品的体积与价值乘以它们的可能数量加到了可选物品中，多了一层<code>O(n)</code>的循环</p>
<h3 id="多重背包问题II"><a href="#多重背包问题II" class="headerlink" title="多重背包问题II"></a>多重背包问题II</h3><p>原题链接：<a href="https://www.acwing.com/problem/content/5/" target="_blank" rel="noopener">Acwing5</a></p>
<p>有 N 种物品和一个容量是 V 的背包。</p>
<p>第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。</p>
<p>求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。<br>输出最大价值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; v &gt;&gt; w &gt;&gt; c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= c; k *= <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        c -= k;</span><br><span class="line">        t.push_back(&#123;k * v, k * w&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(c)</span><br><span class="line">        t.push_back(&#123;c * v, c * w&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> k:t)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &gt;= k.v; i--)</span><br><span class="line">        f[i] = max(f[i], f[i - k.v] + k.w);</span><br></pre></td></tr></table></figure>

<p>对多重背包问题I中的方法进行优化，此方法是将合法数量中是<code>2</code>的整数次幂的部分加入到可选物品中，再将剩余部分加入，此法将最后一层循环优化到了<code>O(logn)</code></p>
<h3 id="混合背包问题"><a href="#混合背包问题" class="headerlink" title="混合背包问题"></a>混合背包问题</h3><p>原题链接：<a href="https://www.acwing.com/problem/content/7/" target="_blank" rel="noopener">Acwing7</a><br>有 N 种物品和一个容量是 V 的背包。</p>
<p>物品一共有三类：</p>
<p>第一类物品只能用1次（01背包）；<br>第二类物品可以用无限次（完全背包）；<br>第三类物品最多只能用 si 次（多重背包）；<br>每种体积是 vi，价值是 wi。</p>
<p>求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。<br>输出最大价值。<br>si=−1 表示第 i 种物品只能用1次；<br>si=0 表示第 i 种物品可以用无限次；<br>si&gt;0 表示第 i 种物品可以使用 si 次；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; v &gt;&gt; w &gt;&gt; s;</span><br><span class="line">    <span class="keyword">if</span>(s&lt;=<span class="number">0</span>)</span><br><span class="line">        t.push_back(&#123;s, v, w&#125;);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">1</span>; c &lt;= s;c++)</span><br><span class="line">        &#123;</span><br><span class="line">            s -= c;</span><br><span class="line">            t.push_back(&#123;<span class="number">-1</span>, c * v, c * w&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s)</span><br><span class="line">            t.push_back(&#123;<span class="number">-1</span>, s * v, s * w&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> k:t)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (k.s == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = m; j &gt;= k.v;j--)</span><br><span class="line">            f[j] = max(f[j], f[j - k.v] + k.w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = k.v; j &lt;= m;j++)</span><br><span class="line">            f[j] = max(f[j], f[j - k.v] + k.w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先将多重背包的部分用II法中的二进制优化方法转化为01背包，此时便转化为01背包和完全背包相结合的问题，分情况讨论即可</p>
<h3 id="二维费用的背包问题"><a href="#二维费用的背包问题" class="headerlink" title="二维费用的背包问题"></a>二维费用的背包问题</h3><p>原题链接：<a href="https://www.acwing.com/problem/content/8/" target="_blank" rel="noopener">Acwing8</a></p>
<p>有 N 件物品和一个容量是 V 的背包，背包能承受的最大重量是 M。</p>
<p>每件物品只能用一次。体积是 vi，重量是 mi，价值是 wi。</p>
<p>求解将哪些物品装入背包，可使物品总体积不超过背包容量，总重量不超过背包可承受的最大重量，且价值总和最大。<br>输出最大价值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; v &gt;&gt; m &gt;&gt; w;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = V; j &gt;= v;j--)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = M; k &gt;= m;k--)</span><br><span class="line">        	f[j][k] = max(f[j][k], f[j - v][k - m] + w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二维的01背包问题</p>
<h3 id="分组背包问题"><a href="#分组背包问题" class="headerlink" title="分组背包问题"></a>分组背包问题</h3><p>原题链接：<a href="https://www.acwing.com/problem/content/9/" target="_blank" rel="noopener">Acwing9</a></p>
<p>有 N 组物品和一个容量是 V 的背包。</p>
<p>每组物品有若干个，同一组内的物品最多只能选一个。<br>每件物品的体积是 vij，价值是 wij，其中 i 是组号，j 是组内编号。</p>
<p>求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。</p>
<p>输出最大价值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= s;k++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v[k] &gt;&gt; w[k];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = V; j &gt;= <span class="number">0</span>;j--)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= s;k++)</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=v[k])</span><br><span class="line">                f[j] = max(f[j], f[j - v[k]] + w[k]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似01背包问题，多加一层循环枚举每一组内选取的物品即可</p>
]]></content>
      <categories>
        <category>代码模板</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>移动服务 acwing 274</title>
    <url>/2020/04/10/ac274/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/276/" target="_blank" rel="noopener">Acwing274</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>一个公司有三个移动服务员，最初分别在位置1，2，3处。</p>
<p>如果某个位置（用一个整数表示）有一个请求，那么公司必须指派某名员工赶到那个地方去。</p>
<p>某一时刻只有一个员工能移动，且不允许在同样的位置出现两个员工。</p>
<p>从 p 到 q 移动一个员工，需要花费 c(p,q)。</p>
<p>这个函数不一定对称，但保证 c(p,p)=0。</p>
<p>给出N个请求，请求发生的位置分别为 p1~pN。</p>
<p>公司必须按顺序依次满足所有请求，且过程中不能去其他额外的位置，目标是最小化公司花费，请你帮忙计算这个最小花费。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第1行有两个整数L,N，其中L是位置数量，N是请求数量，每个位置从1到L编号。</p>
<p>第2至L+1行每行包含L个非负整数，第i+1行的第j个数表示c(i,j) ，并且它小于2000。</p>
<p>最后一行包含N个整数，是请求列表。</p>
<p>一开始三个服务员分别在位置1，2，3。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个整数M，表示最小花费。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>3≤L≤200,<br>1≤N≤1000</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 9</span><br><span class="line">0 1 1 1 1</span><br><span class="line">1 0 2 3 2</span><br><span class="line">1 1 0 4 1</span><br><span class="line">2 1 5 0 1</span><br><span class="line">4 2 3 4 0</span><br><span class="line">4 2 4 1 5 4 3 2 1</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>

<h3 id="状态表示"><a href="#状态表示" class="headerlink" title="状态表示"></a>状态表示</h3><p><code>f[i][x][y]</code>表示处理完了第i个请求，三个服务员再<code>p[i]</code>,<code>x</code>,<code>y</code>三个位置的所有方案的集合<br><code>f[i][x][y]</code>的值为集合中所有方案的花费的最小值</p>
<p>这题的状态转移比较特殊，<code>f[i][x][y]</code>所依赖的状态难以枚举，但是<code>f[i][x][y]</code>的被依赖状态较容易枚举<br>1位于<code>p[i]</code>的服务员前往<code>p[i+1]</code><br>此时<code>f[i+1][x][y]=f[i][x][y]+w[p[i]][p[i+1]]</code><br>2位于<code>x</code>的服务员前往<code>p[i+1]</code><br>此时<code>f[i+1][p[i]][y]=f[i][x][y]+w[x][p[i+1]]</code><br>3位于<code>y</code>的服务员前往<code>p[i+1]</code><br>此时<code>f[i+1][x][p[i]]=f[i][x][y]+w[y][p[i+1]]</code></p>
<p>答案为<code>f[m][1...n][1...n]</code>中的最小值</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">210</span>, M = <span class="number">1010</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> w[N][N];</span><br><span class="line"><span class="keyword">int</span> f[M][N][N];</span><br><span class="line"><span class="keyword">int</span> p[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;w[i][j]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ ) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p[i]);</span><br><span class="line">	<span class="comment">//初始化p[0]=3,此时f[0][1][2]恰好为题中的初始状态</span></span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">1</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; x ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">1</span>; y &lt;= n; y ++ )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> z = p[i], v = f[i][x][y];</span><br><span class="line">                <span class="keyword">if</span> (x == y || x == z || y == z) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> u = p[i + <span class="number">1</span>];</span><br><span class="line">                f[i + <span class="number">1</span>][x][y] = min(f[i + <span class="number">1</span>][x][y], v + w[z][u]);</span><br><span class="line">                f[i + <span class="number">1</span>][z][y] = min(f[i + <span class="number">1</span>][z][y], v + w[x][u]);</span><br><span class="line">                f[i + <span class="number">1</span>][x][z] = min(f[i + <span class="number">1</span>][x][z], v + w[y][u]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; x ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">1</span>; y &lt;= n; y ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> z = p[m];</span><br><span class="line">            <span class="keyword">if</span> (x == y || x == z || y == z) <span class="keyword">continue</span>;</span><br><span class="line">            res = min(res, f[m][x][y]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>赤壁之战 acwing 297</title>
    <url>/2020/04/10/ac297/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/299/" target="_blank" rel="noopener">Acwing297</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定一个长度为N的序列A，求A有多少个长度为M的严格递增子序列。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含整数T，表示共有T组测试数据。</p>
<p>每组数据，第一行包含两个整数N和M。</p>
<p>第二行包含N个整数，表示完整的序列A。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>每组数据输出一个结果，每个结果占一行。</p>
<p>输出格式为“Case #x: y”，x为数据组别序号，从1开始，y为结果。</p>
<p>由于数据可能很大，请你输入对109+7取模后的结果。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤T≤100,<br>1≤M≤N≤1000,<br>∑Ti=1Ni×Mi≤107<br>序列中的整数的绝对值不超过109。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3 2</span><br><span class="line">1 2 3</span><br><span class="line">3 2</span><br><span class="line">3 2 1</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Case #1: 3</span><br><span class="line">Case #2: 0</span><br></pre></td></tr></table></figure>

<h3 id="状态表示"><a href="#状态表示" class="headerlink" title="状态表示"></a>状态表示</h3><p><code>f[i][j]</code>表示所有以<code>a[i]</code>结尾的，长度为<code>j</code>的递增序列的集合，<code>f[i][j]</code>的值表示集合中元素的数量<br>易得<br><code>f[i][1]=1</code><br><code>f[i][j] = ∑f[i-1][k]</code> <code>(a[k]&lt;a[i],1&lt;=k&lt;=i-1)</code></p>
<p>经观察我们发现，上述做法要加一层循环来寻找所有符合条件的<code>k</code>值，这实际上是求所有上一层循环（长度为<code>j-1</code>的序列）的符合条件的<code>k</code>值的前缀和，快速查找并动态更新前缀和，可以想到树状数组。最终的答案只与序列元素的相对大小有关，可以想到用离散化<br>此时<br><code>f[i][j]=sum(a[i]-1)</code><br>同时每次要更新长度为j-1的序列的前缀和<br><code>add(a[i],f[i][j-1])</code></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> f[N][N];</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">int</span> nums[N];</span><br><span class="line"><span class="keyword">int</span> tr[N];</span><br><span class="line"><span class="keyword">int</span> n, m, t, cnt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;x;x-=lowbit(x))</span><br><span class="line">        res = (res + tr[x]) % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= cnt; i+=lowbit(i))</span><br><span class="line">        tr[i] = (tr[i] + y) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">1</span>; c &lt;= t;c++)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">            nums[cnt++] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        sort(nums, nums + cnt);</span><br><span class="line">        cnt = unique(nums, nums + cnt) - nums;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">            a[i] = lower_bound(nums, nums + cnt, a[i]) - nums + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">            f[i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= m;len++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memset</span>(tr, <span class="number">0</span>, <span class="keyword">sizeof</span>(tr));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                f[i][len] = sum(a[i] - <span class="number">1</span>);</span><br><span class="line">                add(a[i], f[i][len - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">            res = (res + f[i][m]) % mod;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d: %d\n"</span>, c, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>炮兵阵地 acwing 292</title>
    <url>/2020/04/09/ac292/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/294/" target="_blank" rel="noopener">Acwing292</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>司令部的将军们打算在N<em>M的网格地图上部署他们的炮兵部队。一个N</em>M的地图由N行M列组成，地图的每一格可能是山地（用”H” 表示），也可能是平原（用”P”表示），如下图。</p>
<p>在每一格平原地形上最多可以布置一支炮兵部队（山地上不能够部署炮兵部队）；一支炮兵部队在地图上的攻击范围如图中黑色区域所示：</p>
<p><img src="/images/ac292.png" alt="alt"></p>
<p>如果在地图中的灰色所标识的平原上部署一支炮兵部队，则图中的黑色的网格表示它能够攻击到的区域：沿横向左右各两格，沿纵向上下各两格。</p>
<p>图上其它白色网格均攻击不到。</p>
<p>从图上可见炮兵的攻击范围不受地形的影响。</p>
<p>现在，将军们规划如何部署炮兵部队，在防止误伤的前提下（保证任何两支炮兵部队之间不能互相攻击，即任何一支炮兵部队都不在其他支炮兵部队的攻击范围内），在整个地图区域内最多能够摆放多少我军的炮兵部队。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含两个由空格分割开的正整数，分别表示N和M；</p>
<p>接下来的N行，每一行含有连续的M个字符(‘P’或者’H’)，中间没有空格。按顺序表示地图中每一行的数据。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>仅一行，包含一个整数K，表示最多能摆放的炮兵部队的数量。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>N≤100,M≤10</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 4</span><br><span class="line">PHPP</span><br><span class="line">PPHH</span><br><span class="line">PPPP</span><br><span class="line">PHPP</span><br><span class="line">PHHP</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure>

<p>如图，共5种情况</p>
<h3 id="状态表示"><a href="#状态表示" class="headerlink" title="状态表示"></a>状态表示</h3><p>由于每个状态可以影响到往下两层，所以要枚举当前行状态，上一行状态以及上上行的状态<br>同样，记录的时候也要再加一维，<code>f[i][j][k]</code>表示，放好前i行，第i行状态为<code>k</code>，第<code>i-1</code>行状态为<code>j</code>的时候，能放置的最大数量，这里的状态用二进制数来表示,用<code>u</code>表示第<code>i-2</code>行<br><code>f[i][j][k]</code>的值表示当前状态的最大值</p>
<p>合法条件</p>
<ol>
<li>当前行与前两行无交集</li>
<li>当前行已经摆放的位置不能为山地</li>
</ol>
<p>状态转移：<br><code>f[i][j][k]=max(f[i][j][k],f[i-1][u][j]+cnt[state[k]])</code></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>, M = <span class="number">10</span>, S = <span class="number">1</span> &lt;&lt; M;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> g[N];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">2</span>][S][S];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; state;</span><br><span class="line"><span class="keyword">int</span> cnt[S];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//对某一行检查是否存在某一列与前两列有交集的情况</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m;i++)</span><br><span class="line">        <span class="keyword">if</span>((s&gt;&gt;i&amp;<span class="number">1</span>)&amp;&amp;((s&gt;&gt;i+<span class="number">1</span>&amp;<span class="number">1</span>)||(s&gt;&gt;i+<span class="number">2</span>&amp;<span class="number">1</span>)))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//统计1的个数</span></span><br><span class="line">    <span class="keyword">int</span> res= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(s)</span><br><span class="line">    &#123;</span><br><span class="line">        res += s &amp; <span class="number">1</span>;</span><br><span class="line">        s &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> c;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="string">'H'</span>)</span><br><span class="line">                g[i] += <span class="number">1</span> &lt;&lt; j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//找出可以作为一行的合法状态</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; m;i++)</span><br><span class="line">        <span class="keyword">if</span>(check(i))</span><br><span class="line">        &#123;</span><br><span class="line">            state.push_back(i);</span><br><span class="line">            cnt[i] = count(i);</span><br><span class="line">        &#125;</span><br><span class="line">	<span class="comment">//为防止空间溢出，由于当前行状态仅由上一行转移，故可以用滚动数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">2</span>;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; state.size();j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; state.size();k++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; state.size();u++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> a = state[u];</span><br><span class="line">                    <span class="keyword">int</span> b = state[j];</span><br><span class="line">                    <span class="keyword">int</span> c = state[k];</span><br><span class="line">                    <span class="keyword">if</span>((a&amp;b)||(b&amp;c)||(a&amp;c))</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(g[i]&amp;c)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    f[i &amp; <span class="number">1</span>][j][k] = max(f[i&amp;<span class="number">1</span>][j][k], f[i - <span class="number">1</span> &amp; <span class="number">1</span>][u][j] + cnt[c]);</span><br><span class="line">                &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f[n+<span class="number">1</span>&amp;<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>金字塔 acwing 284</title>
    <url>/2020/04/09/ac284/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/286/" target="_blank" rel="noopener">Acwing284</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>虽然探索金字塔是极其老套的剧情，但是有一队探险家还是到了某金字塔脚下。</p>
<p>经过多年的研究，科学家对这座金字塔的内部结构已经有所了解。</p>
<p>首先，金字塔由若干房间组成，房间之间连有通道。</p>
<p>如果把房间看作节点，通道看作边的话，整个金字塔呈现一个有根树结构，节点的子树之间有序，金字塔有唯一的一个入口通向树根。</p>
<p>并且，每个房间的墙壁都涂有若干种颜色的一种。</p>
<p>探险队员打算进一步了解金字塔的结构，为此，他们使用了一种特殊设计的机器人。</p>
<p>这种机器人会从入口进入金字塔，之后对金字塔进行深度优先遍历。</p>
<p>机器人每进入一个房间（无论是第一次进入还是返回），都会记录这个房间的颜色。</p>
<p>最后，机器人会从入口退出金字塔。</p>
<p>显然，机器人会访问每个房间至少一次，并且穿越每条通道恰好两次（两个方向各一次）， 然后，机器人会得到一个颜色序列。</p>
<p>但是，探险队员发现这个颜色序列并不能唯一确定金字塔的结构。</p>
<p>现在他们想请你帮助他们计算，对于一个给定的颜色序列，有多少种可能的结构会得到这个序列。</p>
<p>因为结果可能会非常大，你只需要输出答案对109 取模之后的值。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入仅一行，包含一个字符串S，长度不超过300，表示机器人得到的颜色序列。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个整数表示答案。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ABABABA</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>
<h3 id="样例分析"><a href="#样例分析" class="headerlink" title="样例分析"></a>样例分析</h3><p><img src="/images/ac284.png" alt="alt"><br>如图，共5种情况</p>
<h3 id="状态表示"><a href="#状态表示" class="headerlink" title="状态表示"></a>状态表示</h3><p><code>f[l][r]</code>表示<code>[l,r]</code>区间内树的结构的所有可能集合<br><code>f[l][r]</code>的值表示可能值总数</p>
<p>划分方式：<br>以根节点的最后一颗子树为划分条件，将原区间划分为两个区间<br><code>[l,k]</code>用于表示前面的所有子树<br><code>[k+1,r-1]</code>用于表示最后一颗子树<br>边界:<code>f[l][r]=1  (l==r)</code></p>
<p>状态转移：当前区间的值为所有可能划分下，所有左子树可能区间与右子树可能区间的乘积之和<br><code>f[l][r]=f[l][r]+f[l][k]*f[k+1][r-1]</code></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">310</span>, mod = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line">ll f[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; str + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(str + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//如果有n个节点，那么总路径长度为2n-1，为奇数</span></span><br><span class="line">    <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">1</span>; len &lt;= n; len++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l + len - <span class="number">1</span> &lt;= n; l++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> r = l + len - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(len == <span class="number">1</span>)</span><br><span class="line">                    f[l][r] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//任意子树路径首尾必定相同</span></span><br><span class="line">                    <span class="keyword">if</span>(str[l]==str[r])</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> k = l; k &lt; r; k += <span class="number">2</span>)</span><br><span class="line">                            <span class="keyword">if</span>(str[k]==str[r])</span><br><span class="line">                                f[l][r] = (f[l][r] + f[l][k] * f[k + <span class="number">1</span>][r - <span class="number">1</span>]) % mod;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; f[<span class="number">1</span>][n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>传纸条 acwing 275</title>
    <url>/2020/04/08/ac275/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/277/" target="_blank" rel="noopener">Acwing275</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>小渊和小轩是好朋友也是同班同学，他们在一起总有谈不完的话题。</p>
<p>一次素质拓展活动中，班上同学安排坐成一个 m 行 n 列的矩阵，而小渊和小轩被安排在矩阵对角线的两端，因此，他们就无法直接交谈了。</p>
<p>幸运的是，他们可以通过传纸条来进行交流。</p>
<p>纸条要经由许多同学传到对方手里，小渊坐在矩阵的左上角，坐标(1,1)，小轩坐在矩阵的右下角，坐标(m,n)。</p>
<p>从小渊传到小轩的纸条只可以向下或者向右传递，从小轩传给小渊的纸条只可以向上或者向左传递。 </p>
<p>在活动进行中，小渊希望给小轩传递一张纸条，同时希望小轩给他回复。</p>
<p>班里每个同学都可以帮他们传递，但只会帮他们一次，也就是说如果此人在小渊递给小轩纸条的时候帮忙，那么在小轩递给小渊的时候就不会再帮忙，反之亦然。 </p>
<p>还有一件事情需要注意，全班每个同学愿意帮忙的好感度有高有低（注意：小渊和小轩的好心程度没有定义，输入时用0表示），可以用一个0-100的自然数来表示，数越大表示越好心。</p>
<p>小渊和小轩希望尽可能找好心程度高的同学来帮忙传纸条，即找到来回两条传递路径，使得这两条路径上同学的好心程度之和最大。</p>
<p>现在，请你帮助小渊和小轩找到这样的两条路径。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行有2个用空格隔开的整数 m 和 n，表示学生矩阵有 m 行 n 列。</p>
<p>接下来的 m 行是一个 m∗n 的矩阵，矩阵中第 i 行 j 列的整数表示坐在第 i 行 j 列的学生的好心程度，每行的 n 个整数之间用空格隔开。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个整数，表示来回两条路上参与传递纸条的学生的好心程度之和的最大值。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤n,m≤50</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">0 3 9</span><br><span class="line">2 8 5</span><br><span class="line">5 7 0</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">34</span><br></pre></td></tr></table></figure>

<h3 id="状态表示"><a href="#状态表示" class="headerlink" title="状态表示"></a>状态表示</h3><p><code>f[x1][y1][x2][y2]</code>表示第一个人走到了<code>(x1,y1)</code>且第二个人走到了<code>(x2,y2)</code>的状态。<br><code>f[x1][y1][x2][y2]</code>的值表示该状态下走过路径的最大和</p>
<p>1 当<code>x1==x2&amp;&amp;y1==y2</code>时，表明该状态下两人重合，故只能加一次该位置的权值</p>
<p>2 当<code>x1!=x2||y1!=y2</code>时，表明该状态下两人不重合，则分别加上两个点的权值</p>
<p>这种方法的时间复杂度将是<code>O(n^4)</code></p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>由于结尾处两人走的路径总长度是相同的，故我们只需要考虑所有两个人走的路径长度相同的状态。<br><code>f[p][x1][x2]</code>  ,其中<code>p</code>表示每个人走的路径长度，<code>x1</code>和<code>x2</code>分别表示两个人的横坐标，若<code>p==2||p==n+m||x1==x2</code>，此时两人重合，否则不重合，状态更新方式与未优化方法相同<br>优化后时间复杂度为<code>O(n^3)</code></p>
<h3 id="原始代码"><a href="#原始代码" class="headerlink" title="原始代码"></a>原始代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">51</span>;</span><br><span class="line"><span class="keyword">int</span> f[N][N][N][N];</span><br><span class="line"><span class="keyword">int</span> a[N][N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> x1=<span class="number">1</span>;x1&lt;=n;x1++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> y1=<span class="number">1</span>;y1&lt;=m;y1++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> x2=<span class="number">1</span>;x2&lt;=n;x2++)</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> y2 = <span class="number">1</span>; y2 &lt;= m; y2++)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span> (x1 == x2 &amp;&amp; y1 == y2)</span><br><span class="line">					&#123;</span><br><span class="line">						f[x1][y1][x2][y2] = max(f[x1][y1][x2][y2], f[x1][y1 - <span class="number">1</span>][x2 - <span class="number">1</span>][y2] + a[x1][y1]);</span><br><span class="line">						f[x1][y1][x2][y2] = max(f[x1][y1][x2][y2], f[x1 - <span class="number">1</span>][y1][x2 - <span class="number">1</span>][y2] + a[x1][y1]);</span><br><span class="line">						f[x1][y1][x2][y2] = max(f[x1][y1][x2][y2], f[x1 - <span class="number">1</span>][y1][x2][y2 - <span class="number">1</span>] + a[x1][y1]);</span><br><span class="line">						f[x1][y1][x2][y2] = max(f[x1][y1][x2][y2], f[x1][y1 - <span class="number">1</span>][x2][y2 - <span class="number">1</span>] + a[x1][y1]);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span></span><br><span class="line">					&#123;</span><br><span class="line">						f[x1][y1][x2][y2] = max(f[x1][y1][x2][y2], f[x1 - <span class="number">1</span>][y1][x2 - <span class="number">1</span>][y2] + a[x1][y1] + a[x2][y2]);</span><br><span class="line">						f[x1][y1][x2][y2] = max(f[x1][y1][x2][y2], f[x1][y1 - <span class="number">1</span>][x2 - <span class="number">1</span>][y2] + a[x1][y1] + a[x2][y2]);</span><br><span class="line">						f[x1][y1][x2][y2] = max(f[x1][y1][x2][y2], f[x1 - <span class="number">1</span>][y1][x2][y2 - <span class="number">1</span>] + a[x1][y1] + a[x2][y2]);</span><br><span class="line">						f[x1][y1][x2][y2] = max(f[x1][y1][x2][y2], f[x1][y1 - <span class="number">1</span>][x2][y2 - <span class="number">1</span>] + a[x1][y1] + a[x2][y2]);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; f[n][m][n][m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="优化代码"><a href="#优化代码" class="headerlink" title="优化代码"></a>优化代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">51</span>;</span><br><span class="line"><span class="keyword">int</span> f[N * <span class="number">2</span>][N][N];</span><br><span class="line"><span class="keyword">int</span> a[N][N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">2</span>; p &lt;= n + m; p++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> x1=max(p-m,<span class="number">1</span>);x1&lt;=min(p<span class="number">-1</span>,n);x1++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> x2 = max(p - m, <span class="number">1</span>); x2 &lt;= min(p - <span class="number">1</span>, n); x2++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> t = a[x1][p - x1];</span><br><span class="line">				<span class="keyword">if</span> (x1 != x2 &amp;&amp; p != <span class="number">2</span> &amp;&amp; p != n + m)</span><br><span class="line">					t += a[x2][p - x2];</span><br><span class="line">				f[p][x1][x2] = max(f[p][x1][x2], f[p<span class="number">-1</span>][x1][x2] + t);</span><br><span class="line">				f[p][x1][x2] = max(f[p][x1][x2], f[p<span class="number">-1</span>][x1 - <span class="number">1</span>][x2] + t);</span><br><span class="line">				f[p][x1][x2] = max(f[p][x1][x2], f[p<span class="number">-1</span>][x1][x2 - <span class="number">1</span>] + t);</span><br><span class="line">				f[p][x1][x2] = max(f[p][x1][x2], f[p<span class="number">-1</span>][x1 - <span class="number">1</span>][x2 - <span class="number">1</span>] + t);</span><br><span class="line">			&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; f[n + m][n][n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>饼干 acwing 277</title>
    <url>/2020/04/08/ac277/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/279/" target="_blank" rel="noopener">Acwing277</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>圣诞老人共有M个饼干，准备全部分给N个孩子。</p>
<p>每个孩子有一个贪婪度，第 i 个孩子的贪婪度为 g[i]。</p>
<p>如果有 a[i] 个孩子拿到的饼干数比第 i 个孩子多，那么第 i 个孩子会产生 g[i]*a[i]的怨气。</p>
<p>给定N、M和序列g，圣诞老人请你帮他安排一种分配方式，使得每个孩子至少分到一块饼干，并且所有孩子的怨气总和最小。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含两个整数N,M。</p>
<p>第二行包含N个整数表示g1~gN。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>第一行一个整数表示最小怨气总和。</p>
<p>第二行N个空格隔开的整数表示每个孩子分到的饼干数，若有多种方案，输出任意一种均可。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤N≤30,<br>N≤M≤5000,<br>1≤gi≤107</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 20</span><br><span class="line">1 2 3</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">2 9 9</span><br></pre></td></tr></table></figure>

<h3 id="状态表示"><a href="#状态表示" class="headerlink" title="状态表示"></a>状态表示</h3><p>先将小朋友按照<code>g[i]</code>的大小进行排序，由排序不等式知，排名靠前的小朋友要分配更多的饼干<br><code>f[i][j]</code>表示前i个小朋友分配了j块饼干的集合，<code>f[i][j]</code>的值表示集合里怒气值总和的最小值</p>
<p>集合的划分<br>1 我们发现由于每个小朋友的怒气值之于它的相对位置有关，故当每个小朋友的饼干数都减少一个时，不会对总怒气值产生影响，所以<br><code>f[i][j]=f[i][j-i](j&gt;=i)</code><br>2 我们将<code>f[i][j]</code>根据末尾有几个1来划分，有<code>k</code>个<code>1</code>时，怒气值的和为<br><code>f[i-k][j-k]+(s[i]-s[i-k])*(i-k)</code></p>
<p>即集合<code>f[i][j]</code>末尾有<code>0</code>个<code>1</code>时<br><code>f[i][j]=f[i][j-i](j&gt;=i)</code><br>有<code>k</code>个<code>1</code>时<br><code>f[i][j]=min(f[i-k][j-k]+(s[i]-s[i-k])*(i-k))</code></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">32</span>, M = <span class="number">5010</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line">PII g[N];</span><br><span class="line"><span class="keyword">int</span> f[N][M];</span><br><span class="line"><span class="keyword">int</span> ans[N];</span><br><span class="line"><span class="keyword">int</span> s[N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; g[i].first;</span><br><span class="line">		g[i].second = i;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(g + <span class="number">1</span>, g + <span class="number">1</span> + n);</span><br><span class="line">	reverse(g + <span class="number">1</span>, g + <span class="number">1</span> + n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		s[i] = s[i - <span class="number">1</span>] + g[i].first;</span><br><span class="line">	f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (j &gt;= i)</span><br><span class="line">				f[i][j] = f[i][j - i];</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= i &amp;&amp; k &lt;= j; k++)</span><br><span class="line">				f[i][j] = min(f[i][j], f[i - k][j - k] + (i - k)*(s[i] - s[i - k]));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; f[n][m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	h用来表示减去1的次数，结尾的饼干数为h + 1</span></span><br><span class="line"><span class="comment">	f[i][j] == f[i][j - i]时，结果是从f[i][j - i]状态转移过来</span></span><br><span class="line"><span class="comment">	直接转移回该状态</span></span><br><span class="line"><span class="comment">	f[i][j] == f[i - k][j - k] + (i - k)*(s[i] - s[i - k])时，</span></span><br><span class="line"><span class="comment">	结果也是从后者状态转移过来，直接转移回该状态，同时得知末尾有k个1，并</span></span><br><span class="line"><span class="comment">	将他们赋值为h + 1</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">int</span> i = n, j = m, h = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (i&amp;&amp;j)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (j &gt;= i &amp;&amp; f[i][j] == f[i][j - i])</span><br><span class="line">		&#123;</span><br><span class="line">			j -= i;</span><br><span class="line">			h++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= i &amp;&amp; k &lt;= j; k++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (f[i][j] == f[i - k][j - k] + (i - k)*(s[i] - s[i - k]))</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> p = k - i + <span class="number">1</span>; p &lt;= i; p++)</span><br><span class="line">						ans[g[p].second] = h + <span class="number">1</span>;</span><br><span class="line">					i -= k;</span><br><span class="line">					j -= k;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>蒙德里安的梦想 acwing 291</title>
    <url>/2020/04/08/ac291/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/293/" target="_blank" rel="noopener">Acwing291</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>求把N<em>M的棋盘分割成若干个1</em>2的的长方形，有多少种方案。</p>
<p>例如当N=2，M=4时，共有5种方案。当N=2，M=3时，共有3种方案。</p>
<p>如下图所示：</p>
<p><img src="/images/ac291.png" alt="alt"></p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入包含多组测试用例。</p>
<p>每组测试用例占一行，包含两个整数N和M。</p>
<p>当输入用例N=0，M=0时，表示输入终止，且该用例无需处理。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>每个测试用例输出一个结果，每个结果占一行。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤N,M≤11</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">2 2</span><br><span class="line">2 3</span><br><span class="line">2 4</span><br><span class="line">2 11</span><br><span class="line">4 11</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">144</span><br><span class="line">51205</span><br></pre></td></tr></table></figure>

<h3 id="状态表示"><a href="#状态表示" class="headerlink" title="状态表示"></a>状态表示</h3><p>本题等价于找到所有横着放的<code>1 X 2</code>小方格方案数，因为一旦横着放的小方格数量确定之后，竖着放的方案也一定是唯一的</p>
<p><code>f[i][j]</code>表示第<code>i</code>列的第<code>j</code>个状态。<code>j</code>状态用二进制数表示，如果<code>j</code>中的第<code>t</code>位是<code>1</code>，表示第<code>i-1</code>列的第<code>t</code>行有一个横着放的小方格。<br>状态转移方程为 <code>f[i][j]+=f[i-1][k]</code>, 本列的每一个状态都是由上一列的合法方案转移过来的</p>
<p>转移条件<br>1 第<code>i</code>列和第<code>i-1</code>列不能有矩形出现在同一行<br>2 本列的被捅出来的状态<code>j</code>和上一列被捅出来的状态<code>k</code>求或，可以得知上一列是否有连续的奇数个空格子，如果有，则不合法<br>3 初始化<code>f[0][0]=1</code> 第<code>0</code>列没有前一列，不会有矩形捅出来。<br>4 输出结果为<code>f[m][0]</code> 第<code>m</code>列(最后一列的后一列)不被前一列的任何矩形捅出来，表明前面以及填满</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">12</span>, M = <span class="number">1</span> &lt;&lt; N;</span><br><span class="line"><span class="keyword">int</span> st[M];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[N][M];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &amp;&amp; (n || m))&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n; i ++)&#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            st[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">                <span class="keyword">if</span> (i &gt;&gt; j &amp; <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (cnt &amp; <span class="number">1</span>) st[i] = <span class="literal">false</span>; <span class="comment">// cnt 为当前已经存在多少个连续的0</span></span><br><span class="line">                    cnt = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> cnt ++;</span><br><span class="line">            <span class="keyword">if</span> (cnt &amp; <span class="number">1</span>) st[i] = <span class="literal">false</span>; <span class="comment">// 扫完后要判断一下最后一段有多少个连续的0</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1</span> &lt;&lt; n; j ++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">1</span> &lt;&lt; n; k ++)</span><br><span class="line">                    <span class="keyword">if</span> ((j &amp; k) == <span class="number">0</span> &amp;&amp; (st[j | k])) </span><br><span class="line">                    <span class="comment">// j &amp; k == 0 表示 i 列和 i - 1列同一行不同时捅出来</span></span><br><span class="line">                    <span class="comment">// st[j | k] == 1 表示 在 i 列状态 j， i - 1 列状态 k 的情况下是合法的.</span></span><br><span class="line">                        f[i][j] += f[i - <span class="number">1</span>][k];      </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; f[m][<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>石子合并 acwing 282</title>
    <url>/2020/04/08/ac282/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/284/" target="_blank" rel="noopener">Acwing282</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>设有N堆石子排成一排，其编号为1，2，3，…，N。</p>
<p>每堆石子有一定的质量，可以用一个整数来描述，现在要将这N堆石子合并成为一堆。</p>
<p>每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同。</p>
<p>例如有4堆石子分别为 1 3 5 2， 我们可以先合并1、2堆，代价为4，得到4 5 2， 又合并 1，2堆，代价为9，得到9 2 ，再合并得到11，总代价为4+9+11=24；</p>
<p>如果第二步是先合并2，3堆，则代价为7，得到4 7，最后一次合并代价为11，总代价为4+7+11=22。</p>
<p>问题是：找出一种合理的方法，使总的代价最小，输出最小代价。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行一个数N表示石子的堆数N。</p>
<p>第二行N个数，表示每堆石子的质量(均不超过1000)。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个整数，表示最小代价。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤N≤300</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">1 3 5 2</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">22</span><br></pre></td></tr></table></figure>

<h3 id="状态表示"><a href="#状态表示" class="headerlink" title="状态表示"></a>状态表示</h3><p><code>f[l][r]</code> 表示区间<code>[l,r]</code>内合并所有石子的集合<br><code>f[l][r]</code> 的值表示集合中元素的最小值</p>
<p>集合的划分： 以两区间的合并位置为划分条件，枚举所有可能的合并点</p>
<p>状态方程 <code>f[l][r]=min(f[l][r],f[l][k]+f[k+1][r]+s[r]-s[l-1])</code></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">310</span>;</span><br><span class="line"><span class="keyword">int</span> f[N][N];</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">int</span> s[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		s[i] = s[i - <span class="number">1</span>] + a[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= n; len++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l + len - <span class="number">1</span> &lt;= n; l++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> r = l + len - <span class="number">1</span>;</span><br><span class="line">			f[l][r] = <span class="number">1e9</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = l; k &lt; r; k++)</span><br><span class="line">				f[l][r] = min(f[l][r], f[l][k] + f[k + <span class="number">1</span>][r] + s[r] - s[l - <span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; f[<span class="number">1</span>][n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>最长公共上升子序列 acwing 272</title>
    <url>/2020/04/07/ac272/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/274/" target="_blank" rel="noopener">Acwing272</a></p>
<a id="more"></a>
<p>最长公共子序列：<a href="https://www.acwing.com/problem/content/899/" target="_blank" rel="noopener">Acwing897</a></p>
<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>熊大妈的奶牛在小沐沐的熏陶下开始研究信息题目。</p>
<p>小沐沐先让奶牛研究了最长上升子序列，再让他们研究了最长公共子序列，现在又让他们研究最长公共上升子序列了。</p>
<p>小沐沐说，对于两个数列A和B，如果它们都包含一段位置不一定连续的数，且数值是严格递增的，那么称这一段数是两个数列的公共上升子序列，而所有的公共上升子序列中最长的就是最长公共上升子序列了。</p>
<p>奶牛半懂不懂，小沐沐要你来告诉奶牛什么是最长公共上升子序列。</p>
<p>不过，只要告诉奶牛它的长度就可以了。</p>
<p>数列A和B的长度均不超过3000。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含一个整数N，表示数列A，B的长度。</p>
<p>第二行包含N个整数，表示数列A。</p>
<p>第三行包含N个整数，表示数列B。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个整数，表示最长公共子序列的长度</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤N≤3000,序列中的数字均不超过231−1</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">2 2 1 3</span><br><span class="line">2 1 2 3</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>

<h3 id="状态表示"><a href="#状态表示" class="headerlink" title="状态表示"></a>状态表示</h3><p><code>f[i][j]</code>为所有 <code>a[1~i]</code>和<code>b[1~j]</code>且以<code>b[j]</code>结尾的公共上升序列<br><code>f[i][j]</code>表示集合中的最大值</p>
<p>对此，我们分两种情况讨论<br>1.. <code>f[i][j]</code>不包含 <code>a[i]</code> , 此时集合 <code>f[i][j]</code>等价于 集合<code>f[i-1][j]</code></p>
<p>2.. <code>f[i][j]</code>包含了<code>a[i]</code>, 此时集合<code>f[i][j]</code>的值将被更新,此时应当枚举所有<code>a[1~i-1]</code>且以<code>b[1~j-1]</code>结尾的集合，即枚举<code>f[i-1][1~j-1]</code><br>若倒数第二数是以<code>j-1</code>结尾的，那么<code>f[i][j]=f[i-1][j-1]+1</code><br>若倒数第二数是以<code>j-2</code>结尾的，那么<code>f[i][j]=f[i-1][j-2]+1</code><br>…</p>
<p>这种方法的时间复杂度将是<code>O(n^3)</code></p>
<h3 id="优化一"><a href="#优化一" class="headerlink" title="优化一"></a>优化一</h3><p>经过观察我们发现，每次的<code>maxv</code>是满足<code>a[i]&gt;b[k]</code>的<code>f[i-1][k]+1</code>的前缀最大值，因此我们可以将<code>maxv</code>直接提到第一层循环的外面，这样时间复杂度将会降为<code>O(n^2)</code></p>
<h3 id="优化二"><a href="#优化二" class="headerlink" title="优化二"></a>优化二</h3><p>分析状态转移方程可知<code>f[i][j]</code>都是由<code>f[i-1][j]</code>得来的，因此可以优化空间，设<code>f[i]</code>代表的是<code>a</code>序列前<code>i</code>个元素与b序列的<code>LCIS</code>长度，<code>t</code>为最长<code>LCIS</code>的结尾元素位置</p>
<h3 id="原始代码"><a href="#原始代码" class="headerlink" title="原始代码"></a>原始代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3010</span>;</span><br><span class="line"><span class="keyword">int</span> dp[N][N];</span><br><span class="line"><span class="keyword">int</span> a[N], b[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; b[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">			<span class="keyword">if</span> (a[i] == b[j])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> maxv = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= j - <span class="number">1</span>; k++)</span><br><span class="line">					<span class="keyword">if</span> (b[k] &lt; b[j])</span><br><span class="line">						res = max(dp[i - <span class="number">1</span>][k] + <span class="number">1</span>, maxv);</span><br><span class="line">				dp[i][j] = max(dp[i][j], maxv);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		res = max(res, dp[n][i]);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="优化一-1"><a href="#优化一-1" class="headerlink" title="优化一"></a>优化一</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3010</span>;</span><br><span class="line"><span class="keyword">int</span> dp[N][N];</span><br><span class="line"><span class="keyword">int</span> a[N], b[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; b[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> maxv = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">			<span class="keyword">if</span> (a[i] == b[j])</span><br><span class="line">				dp[i][j] = max(dp[i][j], maxv);</span><br><span class="line">			<span class="keyword">if</span> (b[j] &lt; a[i])</span><br><span class="line">				res = max(dp[i - <span class="number">1</span>][j] + <span class="number">1</span>, maxv);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		res = max(res, dp[n][i]);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优化二-1"><a href="#优化二-1" class="headerlink" title="优化二"></a>优化二</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3010</span>;</span><br><span class="line"><span class="keyword">int</span> dp[N];</span><br><span class="line"><span class="keyword">int</span> a[N], b[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; b[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (a[i] == b[j])</span><br><span class="line">				dp[j] = dp[t] + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (b[j] &lt; a[i] &amp;&amp; dp[j] &gt; dp[t])</span><br><span class="line">				t = j;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		res = max(res, dp[i]);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>LCS</code>(最长公共子序列)<br><code>f[i][j]=f[i-1][j-1]+1  (a[i]=a[j])</code><br><code>f[i][j]=max(f[i][j-1],f[i-1][j])  (a[i]!=a[j])</code><br>其中，<code>f[i][j]</code>为<code>a</code>序列的前<code>i</code>个元素和<code>b</code>序列的前<code>j</code>个元素的<code>LCS</code>长度</p>
<p><code>LIS</code>(最长上升子序列)<br><code>f[i] = max f[j]+1(a[j]&lt;a[i],j&lt;i)</code><br>f[i]为以第i个元素结尾的LISLIS长度。</p>
<p><code>LCIS</code>(最长公共上升子序列)<br><code>f[i][j]=f[i-1][j](a[i]!=b[j])</code><br><code>f[i][j]=max(f[i-1][j],f[i-1][t]+1) (a[i]=b[j])</code><br><code>f[i][j]</code>代表的是<code>a</code>序列前<code>i</code>个元素与<code>b</code>序列前<code>j</code>个元素的<code>LCIS</code>长度，<code>t</code>为最长<code>LCIS</code>的结尾元素位置</p>
<p>优化<br><code>f[i]=f[t]+1(a[i]=b[j])</code><br><code>f[i]</code>代表的是<code>a</code>序列前<code>i</code>个元素与<code>b</code>序列的<code>LCIS</code>长度，<code>t</code>为最长<code>LCIS</code>的结尾元素位置</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树的基本操作</title>
    <url>/2020/03/28/segmenttree/</url>
    <content><![CDATA[<p>线段树的创建、单点修改、查询</p>
<a id="more"></a>

<h3 id="线段树的创建"><a href="#线段树的创建" class="headerlink" title="线段树的创建"></a>线段树的创建</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> l, r;</span><br><span class="line">	<span class="keyword">int</span> dat;</span><br><span class="line">&#125;t[SIZE * <span class="number">4</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	t[p].l = l;</span><br><span class="line">	t[p].r = r;</span><br><span class="line">	<span class="keyword">if</span> (l == r)</span><br><span class="line">	&#123;</span><br><span class="line">		t[p].dat = a[l];</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	build(p * <span class="number">2</span>, l, mid);</span><br><span class="line">	build(p * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">	t[p].dat = max(t[p * <span class="number">2</span>].dat, t[p * <span class="number">2</span> + <span class="number">1</span>].dat);</span><br><span class="line">&#125;</span><br><span class="line">bulid(<span class="number">1</span>, <span class="number">1</span>, n);</span><br></pre></td></tr></table></figure>
<h3 id="线段树的单点修改"><a href="#线段树的单点修改" class="headerlink" title="线段树的单点修改"></a>线段树的单点修改</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (t[p].l == t[p].r)</span><br><span class="line">	&#123;</span><br><span class="line">		t[p].dat = v;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid = t[p].l + t[p].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (x &lt;= mid)</span><br><span class="line">		change(p * <span class="number">2</span>, x, v);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		change(p * <span class="number">2</span> + <span class="number">1</span>, x, v);</span><br><span class="line">	t[p].dat = max(t[p * <span class="number">2</span>].dat, t[p * <span class="number">2</span> + <span class="number">1</span>].dat);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">change(<span class="number">1</span>, x, v);</span><br></pre></td></tr></table></figure>

<h3 id="线段树的查询"><a href="#线段树的查询" class="headerlink" title="线段树的查询"></a>线段树的查询</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (t[p].l &gt;= l &amp;&amp; t[p].r &lt;= r)</span><br><span class="line">		<span class="keyword">return</span> t[p].dat;</span><br><span class="line">	<span class="keyword">int</span> mid = t[p].l + t[p].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> val = -(<span class="number">1</span> &lt;&lt; <span class="number">30</span>);</span><br><span class="line">	<span class="keyword">if</span> (l &lt;= mid)</span><br><span class="line">		val = max(val, ask(p * <span class="number">2</span>, l, r));</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		val = max(val, ask(p * <span class="number">2</span> + <span class="number">1</span>, l, r));</span><br><span class="line">	<span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ask(<span class="number">1</span>, l, r);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>代码模板</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>银河英雄传说 acwing 238</title>
    <url>/2020/03/25/ac238/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/240/" target="_blank" rel="noopener">Acwing238</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>有一个划分为N列的星际战场，各列依次编号为1,2,…,N。</p>
<p>有N艘战舰，也依次编号为1,2,…,N,其中第i号战舰处于第i列。</p>
<p>有T条指令，每条指令格式为以下两种之一：</p>
<p>1、M i j，表示让第i号战舰所在列的全部战舰保持原有顺序，接在第j号战舰所在列的尾部。</p>
<p>2、C i j，表示询问第i号战舰与第j号战舰当前是否处于同一列中，如果在同一列中，它们之间间隔了多少艘战舰。</p>
<p>现在需要你编写一个程序，处理一系列的指令。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含整数T，表示共有T条指令。</p>
<p>接下来T行，每行一个指令，指令有两种形式：M i j或C i j。</p>
<p>其中M和C为大写字母表示指令类型，i和j为整数，表示指令涉及的战舰编号。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>你的程序应当依次对输入的每一条指令进行分析和处理：</p>
<p>如果是M i j形式，则表示舰队排列发生了变化，你的程序要注意到这一点，但是不要输出任何信息；</p>
<p>如果是C i j形式，你的程序要输出一行，仅包含一个整数，表示在同一列上，第i号战舰与第j号战舰之间布置的战舰数目，如果第i号战舰与第j号战舰当前不在同一列上，则输出-1。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>N≤30000,T≤500000</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">M 2 3</span><br><span class="line">C 1 2</span><br><span class="line">M 2 4</span><br><span class="line">C 4 2</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-1</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>1.并查集的存储<br>使用一个数组fa保存父节点（根的父节点设为自己）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> fa[SIZE];</span><br></pre></td></tr></table></figure>

<p>2.并查集的初始化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) fa[i]=i;</span><br></pre></td></tr></table></figure>
<p>3.并查集的get操作<br>若x是树根，则x就是集合代表，否则递归访问fa[x]直至根节点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==fa[x]) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">return</span> fa[x]=get(fa[x]);<span class="comment">//路径压缩</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.并查集的Merge操作<br>合并元素x和元素y所在的集合，等价于让x的树根作为y的树根的子节点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	fa[get(x)]=get(y)l</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">30010</span>;</span><br><span class="line"><span class="comment">//fa数组用于存储根节点</span></span><br><span class="line"><span class="comment">//d数组用于存储当前元素在当前列中前面元素的个数</span></span><br><span class="line"><span class="comment">//siz数组用于存储当前列元素的个数</span></span><br><span class="line"><span class="keyword">int</span> fa[N], d[N], siz[N];</span><br><span class="line"><span class="keyword">int</span> i, j, t;</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x == fa[x])</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">int</span> root = get(fa[x]);</span><br><span class="line">	d[x] += d[fa[x]];</span><br><span class="line">	fa[x] = root;</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x = get(x);</span><br><span class="line">	y = get(y);</span><br><span class="line">	fa[x] = y;</span><br><span class="line">	d[x] = siz[y];</span><br><span class="line">	siz[y] += siz[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		fa[i] = i;</span><br><span class="line">		siz[i] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%c%d%d"</span>, &amp;c, &amp;i, &amp;j);</span><br><span class="line">		getchar();</span><br><span class="line">		<span class="keyword">if</span> (c == <span class="string">'M'</span>)</span><br><span class="line">			merge(i, j);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (get(i) == get(j))</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="built_in">fabs</span>(d[i] - d[j]) - <span class="number">1</span>;<span class="comment">//之间的元素不包含本身</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">"-1"</span>;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>楼兰图腾 acwing 241</title>
    <url>/2020/03/25/ac241/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/243/" target="_blank" rel="noopener">Acwing241</a></p>
<a id="more"></a>
<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>在完成了分配任务之后，西部314来到了楼兰古城的西部。</p>
<p>相传很久以前这片土地上(比楼兰古城还早)生活着两个部落，一个部落崇拜尖刀(‘V’)，一个部落崇拜铁锹(‘∧’)，他们分别用V和∧的形状来代表各自部落的图腾。</p>
<p>西部314在楼兰古城的下面发现了一幅巨大的壁画，壁画上被标记出了N个点，经测量发现这N个点的水平位置和竖直位置是两两不同的。</p>
<p>西部314认为这幅壁画所包含的信息与这N个点的相对位置有关，因此不妨设坐标分别为(1,y1),(2,y2),…,(n,yn),其中y1~yn是1到n的一个排列。<br>西部314打算研究这幅壁画中包含着多少个图腾。<br>如果三个点(i,yi),(j,yj),(k,yk)满足1 ≤ i &lt; j &lt; k ≤ n且yi &gt; yj,yj &lt; yk，则称这三个点构成V图腾;<br>如果三个点(i,yi),(j,yj),(k,yk)满足1 ≤ i &lt; j &lt; k ≤ n且yi &lt; yj,yj &gt; yk，则称这三个点构成∧图腾;<br>西部314想知道，这n个点中两个部落图腾的数目。</p>
<p>因此，你需要编写一个程序来求出V的个数和∧的个数。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行一个数n。</p>
<p>第二行是n个数，分别代表y1，y2,…,yn。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>两个数，中间用空格隔开，依次为V的个数和∧的个数。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于所有数据，n≤200000,且输出答案不会超过int64。<br>y1∼yn 是 1 到 n 的一个排列。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1 5 3 2 4</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 4</span><br></pre></td></tr></table></figure>

<h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h3><p>树状数组是一种基于二进制分解思想的数据结构，其基本用途是维护序列的前缀和。<br>对于给定的序列a，我们建立一个数组c，其中c[x]保存序列a的区间<br>[x-lowbit(x)+1,x]中所有数的和</p>
<p>该数据结构满足一下性质：<br>1.每个内部检点c[x]保以它位根的子树中所有叶节点的和。<br>2.每个内部节点c[x]的子节点个数等于lowbit(x)的位数。<br>3.除树根外，每个内部节点c[x]的父节点是c[x+lowbit(x)]。<br>4.树的深度为O(log N)。</p>
<p>树状数组支持的两个基本操作</p>
<p>1.查询前缀和<br>若要计算[l,r]中的和，只需计算<code>ask(r)-ask(l-1)</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (; x; x -= lowbit(x))</span><br><span class="line">		ans += c[x];</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.单点增加：给序列中的一个数 <code>a[x]</code> 加上一个<code>y</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (; x &lt;= n; x += lowbit(x))</span><br><span class="line">		c[x] += y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>左右各遍历一次数组，并计算出每个元素左右比它大的元素的个数即可</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) x&amp;(-x)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line">ll a[N], c[N], l[N], r[N];</span><br><span class="line">ll n, resl, resr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(ll x, ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (; x &lt;= n; x += lowbit(x))</span><br><span class="line">		c[x] += y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">ask</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (; x; x -= lowbit(x))</span><br><span class="line">		ans += c[x];</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">counts</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//每个元素的权值为1</span></span><br><span class="line">		<span class="comment">//ask(a[i])表示在它左边的元素（也就是比它小的元素）的个数</span></span><br><span class="line">		<span class="comment">//ask(n)表示已经插入的总元素个数</span></span><br><span class="line">		l[i] = ask(n) - ask(a[i]);</span><br><span class="line">		add(a[i], <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span>(c));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		r[i] = ask(n) - ask(a[i]);</span><br><span class="line">		add(a[i], <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>); </span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">	counts();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		resl += l[i] * r[i];</span><br><span class="line">		resr += (i - <span class="number">1</span> - l[i])*(n - i - r[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; resl &lt;&lt; <span class="string">" "</span> &lt;&lt; resr &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>免费馅饼 HDU1176</title>
    <url>/2020/03/22/HDU1176/</url>
    <content><![CDATA[<p>原题链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1176" target="_blank" rel="noopener">HDU1176</a></p>
<a id="more"></a>
<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>都说天上不会掉馅饼，但有一天gameboy正走在回家的小径上，忽然天上掉下大把大把的馅饼。说来gameboy的人品实在是太好了，这馅饼别处都不掉，就掉落在他身旁的10米范围内。馅饼如果掉在了地上当然就不能吃了，所以gameboy马上卸下身上的背包去接。但由于小径两侧都不能站人，所以他只能在小径上接。由于gameboy平时老呆在房间里玩游戏，虽然在游戏中是个身手敏捷的高手，但在现实中运动神经特别迟钝，每秒种只有在移动不超过一米的范围内接住坠落的馅饼。<br>为了使问题简化，假设在接下来的一段时间里，馅饼都掉落在0-10这11个位置。开始时gameboy站在5这个位置，因此在第一秒，他只能接到4,5,6这三个位置中其中一个位置上的馅饼。问gameboy最多可能接到多少个馅饼？（假设他的背包可以容纳无穷多个馅饼）</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入数据有多组。每组数据的第一行为以正整数n(0&lt; n &lt;100000)，表示有n个馅饼掉在这条小径上。在结下来的n行中，每行有两个整数x,T(0&lt;T&lt;100000),表示在第T秒有一个馅饼掉在x点上。同一秒钟在同一点上可能掉下多个馅饼。n=0时输入结束。</p>
<p>n=0表示数据结束。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>每一组输入数据对应一行输出。输出一个整数m，表示gameboy最多可能接到m个馅饼。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">5 1</span><br><span class="line">4 1</span><br><span class="line">6 1</span><br><span class="line">7 2</span><br><span class="line">7 2</span><br><span class="line">8 3</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>

<h3 id="dp"><a href="#dp" class="headerlink" title="dp"></a>dp</h3><p>首先记录每一秒的掉落情况<br>dp[t][x] 为第t秒在x出所能获得的最的馅饼数量<br>转移方程为:<br>dp[t][x]  += max3(dp[t+1][x],dp[t+1][x-1],dp[t+1][x+1]);</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">100010</span>][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> x, t, T;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n, n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; t;</span><br><span class="line">			f[t][x]++;</span><br><span class="line">			T = max(T, t);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = T; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">10</span>; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">"?"</span> &lt;&lt; f[<span class="number">3</span>][<span class="number">-1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">"!="</span> &lt;&lt; f[i + <span class="number">1</span>][j - <span class="number">1</span>]&lt;&lt;<span class="string">"  i="</span>&lt;&lt;i&lt;&lt;<span class="string">"  j-1="</span>&lt;&lt;j<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">				f[i][j] += max(max(f[i + <span class="number">1</span>][j], f[i + <span class="number">1</span>][j - <span class="number">1</span>]), f[i + <span class="number">1</span>][j + <span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; f[<span class="number">0</span>][<span class="number">5</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>P1496 火烧赤壁</title>
    <url>/2020/03/22/P1494/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.luogu.com.cn/problem/P1496" target="_blank" rel="noopener">P1496</a></p>
<a id="more"></a>
<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>曹操平定北方以后，公元 208 年，率领大军南下，进攻刘表。他的人马还没有到荆州，刘表已经病死。他的儿子刘琮听到曹军声势浩大，吓破了胆，先派人求降了。</p>
<p>孙权任命周瑜为都督，拨给他三万水军，叫他同刘备协力抵抗曹操。</p>
<p>隆冬的十一月，天气突然回暖，刮起了东南风。</p>
<p>没想到东吴船队离开北岸大约二里距离，前面十条大船突然同时起火。火借风势，风助火威。十条火船，好比十条火龙一样，闯进曹军水寨。那里的船舰，都挤在一起，又躲不开，很快地都烧起来。一眨眼工夫，已经烧成一片火海。</p>
<p>曹操气急败坏的把你找来，要你钻入火海把连环线上着火的船只的长度统计出来！</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行一个整数 NN。<br>以后 NN 行，每行两个数：Ai, Bi<br>表示连环线上着火船只的起始位置和终点。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出着火船只的总长度。保证答案在 32 位带符号整数的表示范围内。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">-1 1</span><br><span class="line">5 11</span><br><span class="line">2 9</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure>

<h3 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h3><p>先将所有的坐标全都加入一个新的数组中去，再对其进行离散化</p>
<p>因左端点一定先于右端点出现，任意区间左端点数&gt;=右端点数<br>遍历数组，若某一段内<br>左端点数&gt;右端点数      下一段有效<br>左端点数=右端点数      下一段无效</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, l[<span class="number">30000</span>], r[<span class="number">30000</span>], x[<span class="number">40010</span>], add[<span class="number">40010</span>];</span><br><span class="line"><span class="keyword">int</span> cnt, temp, res;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; l[i] &gt;&gt; r[i];</span><br><span class="line">		x[++cnt] = l[i];</span><br><span class="line">		x[++cnt] = r[i];</span><br><span class="line">	&#125;</span><br><span class="line">	sort(x + <span class="number">1</span>, x + <span class="number">1</span> + cnt);</span><br><span class="line">	<span class="comment">//unique函数用于将有序数组的非重复元素取出并放在前面</span></span><br><span class="line">	<span class="comment">//返回值为最后一个非重复元素的地址</span></span><br><span class="line">	cnt = unique(x + <span class="number">1</span>, x + <span class="number">1</span> + n) - (x + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//lower_bound(起始地址，结束地址，要查找的数值) 返回的是数值 第一个 出现的位置。</span></span><br><span class="line">		<span class="comment">//upper_bound(起始地址，结束地址，要查找的数值) 返回的是数值 最后一个 出现的位置。</span></span><br><span class="line">		<span class="comment">//binary_search(起始地址，结束地址，要查找的数值)  返回的是是否存在这么一个数，是一个bool值。</span></span><br><span class="line">		<span class="keyword">int</span> ll = lower_bound(x + <span class="number">1</span>, x + cnt + <span class="number">1</span>, l[i]) - x;</span><br><span class="line">		<span class="keyword">int</span> rr = lower_bound(x + <span class="number">1</span>, x + cnt + <span class="number">1</span>, r[i]) - x;</span><br><span class="line">		add[ll]++;</span><br><span class="line">		add[rr]--;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		temp += add[i];</span><br><span class="line">		<span class="keyword">if</span> (temp &gt; <span class="number">0</span>)</span><br><span class="line">			res += (x[i + <span class="number">1</span>] - x[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title>离散化</title>
    <url>/2020/03/22/lisanhua/</url>
    <content><![CDATA[<p>离散化的两种方法</p>
<a id="more"></a>



<h3 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h3><p>1.用辅助数组存下离散的数据<br>2.排序<br>3.去重<br>4.放回原数组</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> lsh[MAXN] , cnt , num[MAXN] , n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;num[i]);</span><br><span class="line">	lsh[i] = num[i];	</span><br><span class="line">&#125;</span><br><span class="line">sort(lsh+<span class="number">1</span> , lsh+n+<span class="number">1</span>);</span><br><span class="line"><span class="comment">//unique函数用于将数组中所有不重复的元素取出放在前面</span></span><br><span class="line"><span class="comment">//返回值为最后一个不重复元素的地址</span></span><br><span class="line">cnt = unique(lsh+<span class="number">1</span> , lsh+n+<span class="number">1</span>) - lsh - <span class="number">1</span>;</span><br><span class="line"><span class="comment">//lower_bound(起始地址，结束地址，要查找的数值) 返回的是数值 第一个 出现的位置。</span></span><br><span class="line"><span class="comment">//upper_bound(起始地址，结束地址，要查找的数值) 返回的是数值 最后一个 出现的位置。</span></span><br><span class="line"><span class="comment">//binary_search(起始地址，结束地址，要查找的数值)  返回的是是否存在这么一个数，是一个bool值。</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">	num[i] = lower_bound(lsh+<span class="number">1</span> , lsh+cnt+<span class="number">1</span> , num[i]) - lsh;</span><br></pre></td></tr></table></figure>
<p>注意事项：<br>1.去重并不是把数组中的元素删除，而是将重复的元素方法数组末尾<br>2.二分的范围是离散化后的区间</p>
<h3 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h3><p>1.排序<br>2.枚举放回原数组</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> data , id;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> data &lt; a.data;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Node num[MAXN];</span><br><span class="line"><span class="keyword">int</span> rank[MAXN] , n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;num[i].data);</span><br><span class="line">	num[i].id = i;</span><br><span class="line">&#125;</span><br><span class="line">sort(num+<span class="number">1</span> , num+n+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">	rank[num[i].id] = i;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title>饭卡 HDU2546</title>
    <url>/2020/03/22/HDU2546/</url>
    <content><![CDATA[<p>原题链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2546" target="_blank" rel="noopener">HDU2546</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>电子科大本部食堂的饭卡有一种很诡异的设计，即在购买之前判断余额。如果购买一个商品之前，卡上的剩余金额大于或等于5元，就一定可以购买成功（即使购买后卡上余额为负），否则无法购买（即使金额足够）。所以大家都希望尽量使卡上的余额最少。<br>某天，食堂中有n种菜出售，每种菜可购买一次。已知每种菜的价格以及卡上的余额，问最少可使卡上的余额为多少。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>多组数据。对于每组数据：<br>第一行为正整数n，表示菜的数量。n&lt;=1000。<br>第二行包括n个正整数，表示每种菜的价格。价格不超过50。<br>第三行包括一个正整数m，表示卡上的余额。m&lt;=1000。</p>
<p>n=0表示数据结束。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>对于每组输入,输出一行,包含一个整数，表示卡上可能的最小余额。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">50</span><br><span class="line">5</span><br><span class="line">10</span><br><span class="line">1 2 3 2 1 1 2 3 2 1</span><br><span class="line">50</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-45</span><br><span class="line">32</span><br></pre></td></tr></table></figure>

<h3 id="dp"><a href="#dp" class="headerlink" title="dp"></a>dp</h3><p>对数据从小到大排序，在不考虑最大元素的情况下求出m-5的余额能购买的最大值。 结果为 m - max(f[j]) - a[n] </p>
<p>特判m&lt;5的情况</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n, n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">		<span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">		<span class="keyword">if</span> (m &lt; <span class="number">5</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; m &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		sort(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = m - <span class="number">5</span>; j &gt;= a[i]; j--)</span><br><span class="line">				f[j] = max(f[j], f[j - a[i]] + a[i]);</span><br><span class="line">		<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m - <span class="number">5</span>; j++)</span><br><span class="line">			res = max(res, f[j]);</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; m-res-a[n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>滑雪 P1434</title>
    <url>/2020/03/21/P1434/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.luogu.com.cn/problem/P1434" target="_blank" rel="noopener">P1434</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>Michael 喜欢滑雪。这并不奇怪，因为滑雪的确很刺激。可是为了获得速度，滑的区域必须向下倾斜，而且当你滑到坡底，你不得不再次走上坡或者等待升降机来载你。Michael 想知道在一个区域中最长的滑坡。区域由一个二维数组给出。数组的每个数字代表点的高度。下面是一个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1   2   3   4   5</span><br><span class="line">16  17  18  19  6</span><br><span class="line">15  24  25  20  7</span><br><span class="line">14  23  22  21  8</span><br><span class="line">13  12  11  10  9</span><br></pre></td></tr></table></figure>

<p>一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度会减小。在上面的例子中，一条可行的滑坡为 24－17－16－1（从 2424 开始，在 11 结束）。当然 25－24－23－…－3－2－1 更长。事实上，这是最长的一条。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入的第一行为表示区域的二维数组的行数 RR 和列数 CC。下面是 RR 行，每行有 CC 个数，代表高度(两个数字之间用 11 个空格间隔)。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出区域中最长滑坡的长度。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤R,C≤100</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 5</span><br><span class="line">1  2  3  4  5</span><br><span class="line">16 17 18 19 6</span><br><span class="line">15 24 25 20 7</span><br><span class="line">14 23 22 21 8</span><br><span class="line">13 12 11 10 9</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">25</span><br></pre></td></tr></table></figure>

<h3 id="记忆化dfs"><a href="#记忆化dfs" class="headerlink" title="记忆化dfs"></a>记忆化dfs</h3><p>如果某一个点搜过了，那么下一次经过这个点时直接取之前搜索得到的结果即可</p>
<h3 id="直接搜索代码："><a href="#直接搜索代码：" class="headerlink" title="直接搜索代码："></a>直接搜索代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="keyword">int</span> moves[<span class="number">4</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125; &#125;;</span><br><span class="line"><span class="keyword">int</span> r, c;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> nx = x + moves[i][<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">int</span> ny = y + moves[i][<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span> (nx &gt;= <span class="number">1</span> &amp;&amp; nx &lt;= r &amp;&amp; ny &gt;= <span class="number">1</span> &amp;&amp; ny &lt;= c &amp;&amp; a[nx][ny] &gt; a[x][y])</span><br><span class="line">		&#123;</span><br><span class="line">			res = max(res, dfs(nx, ny));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	res++;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; r &gt;&gt; c;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= r; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= c; j++)</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= r; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= c; j++)</span><br><span class="line">			res=max(dfs(i, j),res);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<h3 id="记忆化搜索代码："><a href="#记忆化搜索代码：" class="headerlink" title="记忆化搜索代码："></a>记忆化搜索代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="keyword">int</span> moves[<span class="number">4</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125; &#125;;</span><br><span class="line"><span class="keyword">int</span> r, c;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (dp[x][y]) <span class="keyword">return</span> dp[x][y];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> nx = x + moves[i][<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">int</span> ny = y + moves[i][<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span> (nx &gt;= <span class="number">1</span> &amp;&amp; nx &lt;= r &amp;&amp; ny &gt;= <span class="number">1</span> &amp;&amp; ny &lt;= c &amp;&amp; a[nx][ny] &gt; a[x][y])</span><br><span class="line">		&#123;</span><br><span class="line">			dp[x][y] = max(dp[x][y], dfs(nx, ny));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	dp[x][y]++;</span><br><span class="line">	<span class="keyword">return</span> dp[x][y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; r &gt;&gt; c;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= r; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= c; j++)</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= r; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= c; j++)</span><br><span class="line">			res=max(dfs(i, j),res);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>记忆化</tag>
      </tags>
  </entry>
  <entry>
    <title>VS2017使用scanf()读取字符串</title>
    <url>/2020/03/21/scanf-s/</url>
    <content><![CDATA[<p>scanf_s()函数的第三个参数</p>
<a id="more"></a>


<p>vs2017上无法使用scanf()函数，但是提供了scanf_s()函数，在使用scanf_s()读取二维数组时遇到了以下问题</p>
<p>代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> dt[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">	scanf_s(<span class="string">"%s"</span>, dt[i]);</span><br></pre></td></tr></table></figure>
<p>在读取字符串时，读完第一行程序就崩溃了</p>
<p>解决方法</p>
<p>给scanf_s函数制定一个参数，告诉编译器预留多大的空间来存储字符串sizeof()或直接给定一个数字大小，够用就可以。<br>代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> dt[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">	scanf_s(<span class="string">"%s"</span>, dt[i], <span class="keyword">sizeof</span>(dt[<span class="number">0</span>]));</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>最大的和 acwing 126</title>
    <url>/2020/03/20/ac126/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/128/" target="_blank" rel="noopener">Acwing126</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定一个包含整数的二维矩阵，子矩形是位于整个阵列内的任何大小为1 * 1或更大的连续子阵列。</p>
<p>矩形的总和是该矩形中所有元素的总和。</p>
<p>在这个问题中，具有最大和的子矩形被称为最大子矩形。</p>
<p>例如，下列数组：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 -2 -7 0 </span><br><span class="line">9 2 -6 2 </span><br><span class="line">-4 1 -4 1 </span><br><span class="line">-1 8 0 -2</span><br></pre></td></tr></table></figure>
<p>其最大子矩形为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9 2 </span><br><span class="line">-4 1 </span><br><span class="line">-1 8</span><br></pre></td></tr></table></figure>
<p>它拥有最大和15</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入中将包含一个N<em>N的整数数组。<br>第一行只输入一个整数N，表示方形二维数组的大小。<br>从第二行开始，输入N</em>N个整数</p>
<p>数组中的数字会保持在[-127,127]的范围内。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个整数，代表最大子矩形的总和。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤N≤100</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">0 -2 -7 0</span><br><span class="line">9 2 -6 2</span><br><span class="line">-4 1 -4 1 </span><br><span class="line">-1 8 0 -2</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">15</span><br></pre></td></tr></table></figure>

<h3 id="贪心-前缀和"><a href="#贪心-前缀和" class="headerlink" title="贪心/前缀和"></a>贪心/前缀和</h3><p>思路一：二维前缀和，枚举起点和终点，因起点与终点各需要两个变量表示，故时间复杂度为o(N^4)</p>
<p>思路二：对每一列求出一维前缀和，再枚举矩形的上下界，得到每一列的和，再用贪心的方法求出对于每一个上下界，矩形面积的最大值，时间复杂度O(N^3)</p>
<h3 id="法一："><a href="#法一：" class="headerlink" title="法一："></a>法一：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> a[N][N], s[N][N], n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line">			s[i][j] = s[i - <span class="number">1</span>][j] + s[i][j - <span class="number">1</span>] - s[i - <span class="number">1</span>][j - <span class="number">1</span>] + a[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> p = i; p &lt;= n; p++)</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> q = j; q &lt;= n; q++)</span><br><span class="line">					res = max(res, s[p][q] - s[p][j - <span class="number">1</span>] - s[i - <span class="number">1</span>][q] + s[i - <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<h3 id="法二："><a href="#法二：" class="headerlink" title="法二："></a>法二：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> a[N][N], s[N][N], n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">int</span> maxv = <span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line">			<span class="comment">//求出每一列的前缀和</span></span><br><span class="line">			s[i][j] = s[i - <span class="number">1</span>][j] + a[i][j];</span><br><span class="line">			maxv = max(a[i][j], maxv);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (maxv &lt;= <span class="number">0</span>)<span class="comment">//若矩阵元素全部为非正，则直接输出最大值</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; maxv &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> tans = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> temp = s[j][k] - s[i - <span class="number">1</span>][k];<span class="comment">//得到每一列的和</span></span><br><span class="line">				tans += temp;</span><br><span class="line">				<span class="keyword">if</span> (tans &lt; <span class="number">0</span>) tans = <span class="number">0</span>;<span class="comment">//贪心</span></span><br><span class="line">				ans = max(ans, tans);</span><br><span class="line">			&#125;</span><br><span class="line">			res = max(res, ans);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵 acwing 156</title>
    <url>/2020/03/20/ac156/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/158/" target="_blank" rel="noopener">Acwing156</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定一个M行N列的01矩阵（只包含数字0或1的矩阵），再执行Q次询问，每次询问给出一个A行B列的01矩阵，求该矩阵是否在原矩阵中出现过。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行四个整数M,N,A,B。</p>
<p>接下来一个M行N列的01矩阵，数字之间没有空格。</p>
<p>接下来一个整数Q。</p>
<p>接下来Q个A行B列的01矩阵，数字之间没有空格。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>对于每个询问，输出1表示出现过，0表示没有出现过。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>A≤100，M,N,B≤1000，Q≤1000</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 3 2 2</span><br><span class="line">111</span><br><span class="line">000</span><br><span class="line">111</span><br><span class="line">3</span><br><span class="line">11</span><br><span class="line">00</span><br><span class="line">11</span><br><span class="line">11</span><br><span class="line">00</span><br><span class="line">11</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h3 id="二维字符串哈希"><a href="#二维字符串哈希" class="headerlink" title="二维字符串哈希"></a>二维字符串哈希</h3><p>原思路：<br>1.先将每一行字符串哈希<br>2.分别将原矩阵中每个A<em>B的矩阵哈希并插入set（自动删除相同元素）中<br>3.在set中查找询问的值<br>acwing运行时间4000ms<br>改进思路：<br>1.先将每一行字符串哈希<br>2.将询问的值插入到set中<br>3.分别将原矩阵每个A</em>B的矩阵哈希的哈希值从set中删除<br>4.set中查找询问的值<br>acwing运行时间1000ms</p>
<p>后者与前者相比，set中的元素少了很多。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>, P = <span class="number">131</span>;</span><br><span class="line">ull hashv[N][N], p[N*N];</span><br><span class="line"><span class="keyword">int</span> m, n, a, b, q;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="function">ull <span class="title">calc</span><span class="params">(ull h[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;m, &amp;n, &amp;a, &amp;b);</span><br><span class="line">	p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m * n; i++)</span><br><span class="line">		p[i] = p[i - <span class="number">1</span>] * P;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)<span class="comment">//计算每一行hash</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>, str + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">			hashv[i][j] = hashv[i][j - <span class="number">1</span>] * P + str[j] - <span class="string">'0'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">unordered_set</span> &lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line">	<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; V;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line">	<span class="keyword">while</span> (q--)<span class="comment">//读取查询元素并将其插入set</span></span><br><span class="line">	&#123;</span><br><span class="line">		ull s = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%s"</span>, str + <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= b; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				s = s * P + str[j] - <span class="string">'0'</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		S.insert(s);</span><br><span class="line">		V.push_back(s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = b; i &lt;= n; i++)<span class="comment">//计算每个子矩阵值并将其从set中删除</span></span><br><span class="line">	&#123;</span><br><span class="line">		ull s = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> l = i - b + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> r = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			s = s * p[b] + calc(hashv[j], l, r);</span><br><span class="line">			<span class="keyword">if</span> (j &gt; a) s -= calc(hashv[j - a], l, r)*p[a*b];</span><br><span class="line">			<span class="keyword">if</span> (j &gt;= a) S.erase(s);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V.size(); i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, S.count(V[i]) ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title>树形地铁系统 acwing 157</title>
    <url>/2020/03/20/ac157/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/159/" target="_blank" rel="noopener">Acwing157</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>一些主要城市拥有树形的地铁系统，即在任何一对车站之间，有且只有一种方式可以乘坐地铁。</p>
<p>此外，这些城市大多数都有一个中央车站。</p>
<p>想象一下，你是一名在拥有树形地铁系统的城市游玩的游客，你想探索该城市完整的地铁线路。</p>
<p>你从中央车站出发，随机选择一条地铁线，然后乘坐地铁行进。</p>
<p>每次到达一个车站，你都将选择一条尚未乘坐过的地铁线路进行乘坐。</p>
<p>如果不存在未乘坐过的线路，则退回到上一个车站，再做选择。</p>
<p>直到你将所有地铁线路都乘坐过两次（往返各一次），此时你将回到中央车站。</p>
<p>之后，你以一种特殊的方式回忆自己的坐车过程，你将你的完整地铁乘坐路线编码为一个二进制字符串。</p>
<p>其中0编码表示你乘坐地铁线路到达距离中央车站更远的一站，1编码表示你乘坐地铁线路到达距离中央车站更近的一站。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行输入一个正整数n，代表测试用例数量。</p>
<p>每个测试用例由两行组成，每行输入一个由字符“0”和“1”构成的字符串，长度最多为3000， 两个字符串都描述了一种树形地铁系统的正确探索路线。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>对于每个测试用例，如果两个字符串描述的探索路线可以视为同一个地铁系统的两种探索路线，则输出same。</p>
<p>否则，输出different。</p>
<p>每行输出一个结果</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">0010011101001011</span><br><span class="line">0100011011001011</span><br><span class="line">0100101100100111</span><br><span class="line">0011000111010101</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">same</span><br><span class="line">different</span><br></pre></td></tr></table></figure>

<h3 id="树的最小表示"><a href="#树的最小表示" class="headerlink" title="树的最小表示"></a>树的最小表示</h3><p>题意：给定n组数据，每个数据表示两个dfs序列，0表示向下走，1表示向上走，问这两棵树是不是同构的</p>
<p>判断方式：求出每个树的最小表示，即与这棵树同构的最小dfs序。如果这两棵树同构，那么它们的最小表示应该相同</p>
<p>求树的最小表示可以递归实现，求出所有子树的dfs序，然后从小到大排序拼接</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> &amp;seq, <span class="keyword">int</span> &amp;u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u++;<span class="comment">//去掉开头的字符0</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;seqs;</span><br><span class="line">	<span class="keyword">while</span> (seq[u] == <span class="string">'0'</span>) </span><br><span class="line">	    seqs.push_back(dfs(seq, u));</span><br><span class="line">	u++;<span class="comment">//去掉结尾的字符1</span></span><br><span class="line">	sort(seqs.begin(), seqs.end());</span><br><span class="line">	<span class="built_in">string</span> res;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;s : seqs) res += s;</span><br><span class="line">	res = <span class="string">'0'</span> + res + <span class="string">'1'</span>; </span><br><span class="line">	<span class="comment">//首尾分别加0和1避免了边界的考虑</span></span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">	<span class="keyword">while</span> (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">string</span> a, b;</span><br><span class="line">		<span class="keyword">int</span> ua = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> ub = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">		a = <span class="string">'0'</span> + a + <span class="string">'1'</span>;</span><br><span class="line">		b = <span class="string">'0'</span> + b + <span class="string">'1'</span>;</span><br><span class="line">		<span class="keyword">if</span> (dfs(a, ua) == dfs(b, ub))</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"same"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"different"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>树的最小表示</tag>
      </tags>
  </entry>
  <entry>
    <title>滑动窗口 acwing 154</title>
    <url>/2020/03/19/ac154/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/156/" target="_blank" rel="noopener">Acwing154</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定一个大小为n≤10^6的数组。</p>
<p>有一个大小为k的滑动窗口，它从数组的最左边移动到最右边。</p>
<p>您只能在窗口中看到k个数字。</p>
<p>每次滑动窗口向右移动一个位置。</p>
<p>以下是一个例子：</p>
<p>该数组为[1 3 -1 -3 5 3 6 7]，k为3。</p>
<table>
<thead>
<tr>
<th>窗口位置</th>
<th align="center">最小值</th>
<th align="center">最大值</th>
</tr>
</thead>
<tbody><tr>
<td>[1 3 -1] -3 5 3 6 7</td>
<td align="center">-1</td>
<td align="center">3</td>
</tr>
<tr>
<td>1 [3 -1 -3] 5 3 6 7</td>
<td align="center">-3</td>
<td align="center">3</td>
</tr>
<tr>
<td>1 3 [-1 -3 5] 3 6 7</td>
<td align="center">-3</td>
<td align="center">5</td>
</tr>
<tr>
<td>1 3 -1 [-3 5 3] 6 7</td>
<td align="center">-3</td>
<td align="center">5</td>
</tr>
<tr>
<td>1 3 -1 -3 [5 3 6] 7</td>
<td align="center">3</td>
<td align="center">6</td>
</tr>
<tr>
<td>1 3 -1 -3 5 [3 6 7]</td>
<td align="center">3</td>
<td align="center">7</td>
</tr>
</tbody></table>
<p>您的任务是确定滑动窗口位于每个位置时，窗口中的最大值和最小值。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入包含两行。</p>
<p>第一行包含两个整数n和k，分别代表数组长度和滑动窗口的长度。</p>
<p>第二行有n个整数，代表数组的具体数值。</p>
<p>同行数据之间用空格隔开。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出包含两个。</p>
<p>第一行输出，从左至右，每个位置滑动窗口中的最小值。</p>
<p>第二行输出，从左至右，每个位置滑动窗口中的最大值。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>n≤10^6</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8 3</span><br><span class="line">1 3 -1 -3 5 3 6 7</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-1 -3 -3 -3 3 3</span><br><span class="line">3 3 5 5 6 7</span><br></pre></td></tr></table></figure>

<h3 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3><p>观察后易发现，若a[i] &gt;= a[j] &amp;&amp;i &lt; j，那么此后必然不会再取a[i]作为最小值了，所以可以将a[i]从队列中删掉，这样队列中的元素是单调递增的，且每个元素只进队出队各一次，时间复杂度为O(n)</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1000010</span>];</span><br><span class="line"><span class="built_in">deque</span>&lt;intq, p;</span><br><span class="line"><span class="keyword">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> n, k;</span><br><span class="line">	<span class="built_in">cin</span> &gt;n &gt;k;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		<span class="built_in">cin</span> &gt;a[i];</span><br><span class="line">	<span class="keyword">int</span> head = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (q.size() &amp;&amp; q.front() + k - <span class="number">1</span> &lt; i)</span><br><span class="line">			q.pop_front();<span class="comment">//若超出范围，则将队头弹出</span></span><br><span class="line">		<span class="keyword">while</span> (q.size() &amp;&amp; a[i] &lt;= a[q.back()])</span><br><span class="line">			q.pop_back();<span class="comment">//保证队列内单调递增</span></span><br><span class="line">		q.push_back(i);</span><br><span class="line">		<span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>)</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; a[q.front()] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (p.size() &amp;&amp; p.front() + k - <span class="number">1</span> &lt; i)</span><br><span class="line">			p.pop_front();</span><br><span class="line">		<span class="keyword">while</span> (p.size() &amp;&amp; a[i] &gt;= a[p.back()])</span><br><span class="line">			p.pop_back();</span><br><span class="line">		p.push_back(i);</span><br><span class="line">		<span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>)</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; a[p.front()] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title>Sunday算法</title>
    <url>/2020/03/19/sunday/</url>
    <content><![CDATA[<p>sunday字符串匹配算法</p>
<a id="more"></a>


<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SundayMatch</span><span class="params">(<span class="built_in">string</span> str, <span class="built_in">string</span> patten)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len1 = str.length();</span><br><span class="line">	<span class="keyword">int</span> len2 = patten.length();</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">map</span>[<span class="number">100000</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">map</span>[i] = <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len2; i++) &#123;<span class="comment">//如果有相同的，保存最后出现的index</span></span><br><span class="line">		<span class="built_in">map</span>[patten[i]] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1 - len2 + <span class="number">1</span>;) &#123;</span><br><span class="line">		<span class="keyword">int</span> j = <span class="number">0</span>;<span class="comment">//每次跳完后j都是0</span></span><br><span class="line">		<span class="keyword">while</span> (j &lt; len2) &#123;</span><br><span class="line">			<span class="keyword">if</span> (str[i] == patten[j]) &#123;</span><br><span class="line">				i++;</span><br><span class="line">				j++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;  <span class="comment">//一遇到不匹配就往后跳</span></span><br><span class="line">				<span class="keyword">int</span> index = i + len2 - j;<span class="comment">//跳到不重合的第一个字符，index表示它的位置</span></span><br><span class="line">				<span class="keyword">char</span> p = str[index];</span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">map</span>[p] == <span class="number">-1</span>) &#123;   <span class="comment">//如果str中没有这个字符i直接跳</span></span><br><span class="line">					i = index + <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					i = index - <span class="built_in">map</span>[p];<span class="comment">//对齐，把i移动到对齐后的位置</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//cout &lt;&lt; "j=" &lt;&lt; j &lt;&lt; "  len2=" &lt;&lt; len2 &lt;&lt; endl;</span></span><br><span class="line">		<span class="keyword">if</span> (j == len2) &#123;</span><br><span class="line">			<span class="keyword">return</span> i - len2;<span class="comment">//匹配成功后j停留在尾端，和头相差len2的距离</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> a, b;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; SundayMatch(a, b) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>代码模板</category>
      </categories>
  </entry>
  <entry>
    <title>网站</title>
    <url>/2020/03/18/changyongwz/</url>
    <content><![CDATA[<p>有用网站</p>
<a id="more"></a>

<p>1 视频片头动画模板 <!--`https://panzoid.com/`--><a href="https://panzoid.com/" target="_blank" rel="noopener">https://panzoid.com/</a></p>
<p>2 在线抠图 <!--`https://www.remove.bg/`--><a href="https://www.remove.bg/" target="_blank" rel="noopener">https://www.remove.bg/</a></p>
<p>3 字体下载 <!--`https://www.zitijia.com/`--><a href="https://www.zitijia.com/" target="_blank" rel="noopener">https://www.zitijia.com/</a></p>
<p>4 p站 （二次元插画网站）<!--` https://www.pixiv.net/`--><a href="https://www.pixiv.net/" target="_blank" rel="noopener">https://www.pixiv.net/</a></p>
<p>5 论文下载 <!--`https://www.cn-ki.net/`--><a href="https://www.cn-ki.net/" target="_blank" rel="noopener">https://www.cn-ki.net/</a></p>
<p>6 文档格式在线转换 <!--`https://smallpdf.com/`--><a href="https://smallpdf.com/" target="_blank" rel="noopener">https://smallpdf.com/</a></p>
<p>7 录屏投屏 <!--`http://web.airdroid.com/`--><a href="http://web.airdroid.com/" target="_blank" rel="noopener">http://web.airdroid.com/</a></p>
<p>8 各大网站热榜 <!--`https://tophub.today/`--><a href="https://tophub.today/" target="_blank" rel="noopener">https://tophub.today/</a></p>
<p>9 超清图片壁纸 <!--`https://www.pexels.com/`--><a href="https://www.pexels.com/" target="_blank" rel="noopener">https://www.pexels.com/</a></p>
<p>10 找网站的网站 <!--`http://www.addog.vip/`--><a href="http://www.addog.vip/" target="_blank" rel="noopener">http://www.addog.vip/</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>最长异或值路径 acwing 144</title>
    <url>/2020/03/17/ac144/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/146/" target="_blank" rel="noopener">Acwing144</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定一个树，树上的边都具有权值。</p>
<p>树中一条路径的异或长度被定义为路径上所有边的权值的异或和</p>
<p>给定上述的具有n个节点的树，你能找到异或长度最大的路径吗？</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含整数n，表示树的节点数目。</p>
<p>接下来n-1行，每行包括三个整数u，v，w，表示节点u和节点v之间有一条边权重为w。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个整数，表示异或长度最大的路径的最大异或和。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤n≤100000,<br>0≤u,v,w&lt; n<br>0≤w&lt;2^31</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">0 1 3</span><br><span class="line">1 2 4</span><br><span class="line">1 3 6</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure>

<h3 id="trie-数组模拟邻接表"><a href="#trie-数组模拟邻接表" class="headerlink" title="trie + 数组模拟邻接表"></a>trie + 数组模拟邻接表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">首先，由异或的性质易知，树上任意两点路径上所有点的异或值等于这两个点分别到根节点的路径的异或值相异或</span><br><span class="line"></span><br><span class="line">之后，用数组模拟邻接表的方式模拟出题中的数据结构，并遍历一遍，统计出每个节点到根节点路径的异或值</span><br><span class="line"></span><br><span class="line">最后，问题转化为了上一题，用同样的方法求解即可</span><br></pre></td></tr></table></figure>


<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>, M=<span class="number">3000000</span>;</span><br><span class="line"><span class="keyword">int</span> a[N], f[M][<span class="number">2</span>], n, idx;</span><br><span class="line"><span class="keyword">int</span> h[N], e[N*<span class="number">2</span>], c[N*<span class="number">2</span>], ne[N*<span class="number">2</span>], cnt;</span><br><span class="line"><span class="comment">//无向图所以为N*2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	e[cnt] = v, c[cnt] = w, ne[cnt] = h[u], h[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> father, <span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	a[u] = sum;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> j = e[i];</span><br><span class="line">		<span class="keyword">if</span> (j != father) dfs(j, u, sum^c[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> &amp;s = f[p][x &gt;&gt; i &amp; <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span> (!s) s = ++idx;</span><br><span class="line">		p = s;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>, p = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> t = x &gt;&gt; i &amp; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (f[p][!t])</span><br><span class="line">		&#123;</span><br><span class="line">			res += (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">			p = f[p][!t];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			p = f[p][t];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> u, v, w;</span><br><span class="line">	<span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span>(h));</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">		add(u, v, w);</span><br><span class="line">		add(v, u, w);</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">		insert(a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		res = max(res, query(a[i]));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>trie</tag>
      </tags>
  </entry>
  <entry>
    <title>最大异或对 acwing 143</title>
    <url>/2020/03/17/ac143/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/145/" target="_blank" rel="noopener">Acwing143</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>在给定的N个整数A1，A2……AN中选出两个进行xor（异或）运算，得到的结果最大是多少？</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行输入一个整数N。</p>
<p>第二行输入N个整数A1～AN。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个整数表示答案。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤N≤105,<br>0≤Ai&lt;2^31</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 2 3</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<h3 id="trie"><a href="#trie" class="headerlink" title="trie"></a>trie</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">将所有整数插入到trie中，再自高位向低位查询，优先选择与当前位不同的路径</span><br></pre></td></tr></table></figure>


<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100100</span>, M=<span class="number">3000000</span>;</span><br><span class="line"><span class="keyword">int</span> a[N], f[M][<span class="number">2</span>], n, idx;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">30</span>; ~i ; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> &amp;s = f[p][x &gt;&gt; i &amp; <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span> (!s) s = ++idx;</span><br><span class="line">		p = s;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>, p = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">30</span>; ~i; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> t = x &gt;&gt; i &amp; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (f[p][!t])</span><br><span class="line">		&#123;</span><br><span class="line">			res += (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">			p = f[p][!t];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			p = f[p][t];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">		insert(a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		res = max(res, query(a[i]));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>trie</tag>
      </tags>
  </entry>
  <entry>
    <title>前缀统计 acwing 142</title>
    <url>/2020/03/17/ac142/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/144/" target="_blank" rel="noopener">Acwing142</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定N个字符串S1,S2…SN，接下来进行M次询问，每次询问给定一个字符串T，求S1～SN中有多少个字符串是T的前缀。</p>
<p>输入字符串的总长度不超过106，仅包含小写字母。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行输入两个整数N，M。</p>
<p>接下来N行每行输入一个字符串Si。</p>
<p>接下来M行每行一个字符串T用以询问。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>对于每个询问，输出一个整数表示答案。</p>
<p>每个答案占一行。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 2</span><br><span class="line">ab</span><br><span class="line">bc</span><br><span class="line">abc</span><br><span class="line">abc</span><br><span class="line">efg</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<h3 id="trie"><a href="#trie" class="headerlink" title="trie"></a>trie</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">先将前N个字符串插入到字典树trie中，再将后M个字符串逐一查询</span><br></pre></td></tr></table></figure>


<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500000</span>, M = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> son[N][<span class="number">26</span>], cnt[N], idx;</span><br><span class="line"><span class="keyword">char</span> str[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> s = str[i] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][s]) son[p][s] = ++ idx;</span><br><span class="line">        p = son[p][s];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p] ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> s = str[i] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][s]) <span class="keyword">break</span>;</span><br><span class="line">        p = son[p][s];</span><br><span class="line">        res += cnt[p];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, str);</span><br><span class="line">        insert();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, str);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, search());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>trie</tag>
      </tags>
  </entry>
  <entry>
    <title>分级 acwing 273</title>
    <url>/2020/03/16/ac273/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/275/" target="_blank" rel="noopener">Acwing273</a></p>
<a id="more"></a>
]]></content>
  </entry>
  <entry>
    <title>mysql</title>
    <url>/2020/03/11/mysql/</url>
    <content><![CDATA[<p>MySQL基础内容</p>
<a id="more"></a>
<h1 id="MySQL-学习笔记"><a href="#MySQL-学习笔记" class="headerlink" title="MySQL 学习笔记"></a>MySQL 学习笔记</h1><h3 id="登录和退出MySQL服务器"><a href="#登录和退出MySQL服务器" class="headerlink" title="登录和退出MySQL服务器"></a>登录和退出MySQL服务器</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 登录MySQL</span></span><br><span class="line">$ mysql -u root -p12345612</span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出MySQL数据库服务器</span></span><br><span class="line">exit;</span><br></pre></td></tr></table></figure>

<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 显示所有数据库</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">databases</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建数据库</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> <span class="keyword">test</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 切换数据库</span></span><br><span class="line"><span class="keyword">use</span> <span class="keyword">test</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 显示数据表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> pet (</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    owner <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    species <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    sex <span class="built_in">CHAR</span>(<span class="number">1</span>),</span><br><span class="line">    birth <span class="built_in">DATE</span>,</span><br><span class="line">    death <span class="built_in">DATE</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看数据表结构</span></span><br><span class="line"><span class="comment">-- describe pet;</span></span><br><span class="line">desc pet;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询表</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">from</span> pet;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> pet <span class="keyword">VALUES</span> (<span class="string">'puffball'</span>, <span class="string">'Diane'</span>, <span class="string">'hamster'</span>, <span class="string">'f'</span>, <span class="string">'1990-03-30'</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改数据</span></span><br><span class="line"><span class="keyword">UPDATE</span> pet <span class="keyword">SET</span> <span class="keyword">name</span> = <span class="string">'squirrel'</span> <span class="keyword">where</span> owner = <span class="string">'Diane'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除数据</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> pet <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'squirrel'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除表</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> myorder;</span><br></pre></td></tr></table></figure>

<h3 id="建表约束"><a href="#建表约束" class="headerlink" title="建表约束"></a>建表约束</h3><h3 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h3>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>html1</title>
    <url>/2020/02/19/html1/</url>
    <content><![CDATA[<p>HTML基础内容</p>
<a id="more"></a>
<h1 id="HTML笔记"><a href="#HTML笔记" class="headerlink" title="HTML笔记"></a>HTML笔记</h1><h3 id="HTML基础部分"><a href="#HTML基础部分" class="headerlink" title="HTML基础部分"></a>HTML基础部分</h3><h6 id="HTML-Hypertext-Markup-Language-超文本标记语言"><a href="#HTML-Hypertext-Markup-Language-超文本标记语言" class="headerlink" title="HTML(Hypertext Markup Language 超文本标记语言)"></a>HTML(Hypertext Markup Language 超文本标记语言)</h6><p> 网页大致可以分为结构（HTML）表现（CSS）行为 (JS)<br> 元素和标签是一样的，元素就是标签，标签就是元素。</p>
<p><strong>1.基础元素</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>[1]<br> doctype元素: h5文档声明，该网页是按照后<br>标准来写的</p>
</li>
<li><p>[2]<br>根元素<br>lang=en表示语言是英文的</p>
</li>
<li><p>[3]<br>头元素<br>meta元素：提供多字访问，源数据<br>charset元素：修改编码<br>title元素：标题，不会显示但会被搜索引擎检索</p>
</li>
<li><p>[4]<br>body元素 内容都在body元素中输入，面向对象的，网页中可以输出<br>标签可以嵌套，但是不可以交叉嵌套</p>
</li>
<li><p>[5]<br>单位：px，百分比，em<br>其中百分比是相对其父元素的百分比</p>
</li>
</ul>
<p><strong>2.body元素</strong></p>
<ul>
<li>h1元素:一级标题，重要性仅次于title标签，字体最大(有h2-h6)</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>世界如此美好<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/html1.png" alt="alt"></p>
<ul>
<li>p标签：表示一个段落，独占一行</li>
<li>i标签：斜体</li>
<li>b标签：粗体</li>
<li>small标签：用来表示细则，小字</li>
<li>em元素： 斜体（强调语气）</li>
<li>strong元素：粗体（强调内容）<br>H5中规定，对于不需要着重的内容而是单纯的加粗或者是斜体<br>就可以用b标签和i标签表示</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>a<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">b</span>&gt;</span>lalala<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">b</span>&gt;</span>lalala<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>cite标签（表示参考的内容）</li>
<li>q标签（表示一个短的引用 即行内引用，q标签引用的内容，浏览器默认会加上引号）</li>
<li>blockquote标签（表示一个长引用即块级引用 ）</li>
<li>sup标签（表示上标）</li>
<li>sup标签（表示下标）</li>
<li>del标签（表示一个删除的内容，del标签中的内容，会自己添加删除线）</li>
<li>ins标签（ins内容会自动添加下划线）</li>
<li>需要页面中直接编写一些代码，pre是一个预格式标签，会将代码的格式保存，不会忽略多个空格，code专门用来表示代码，我们一般结合使用pre和code来表示一段代码</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>赵薇<span class="tag">&lt;<span class="name">sup</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"500294514.jpg"</span>&gt;</span>[1]<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">sup</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>H<span class="tag">&lt;<span class="name">sub</span>&gt;</span>2<span class="tag">&lt;/<span class="name">sub</span>&gt;</span>O<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">del</span>&gt;</span>19.99<span class="tag">&lt;/<span class="name">del</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">            16.66</span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/html2.png" alt="alt"></p>
<ul>
<li>实体（一些特殊元素不能使用，例如大于号之类的，因为与标签冲突，所以一般用一些特殊符号表示，这些特殊符号称为实体，又叫转义字符串）<br>&lt; &amp;lt； &gt; &amp;gt； 空格 &amp;nbsp； 版权符号：&amp;copy；</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    a<span class="symbol">&amp;gt;</span>b</span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    a<span class="symbol">&amp;lt;</span>b</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/html3.png" alt="alt"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="symbol">&amp;copy;</span>爱冒险的梦</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/html4.png" alt="alt"></p>
<ul>
<li>a标签：构成超链接,后面href属性代表所链接的url；有target属性，又分为blank属性和self属性；blank属性:构成的url点击后以新的窗口打开。self属性即默认属性，就是在当前网页中进行打开url。（超链接可以用#做占位符，可以跳转到顶部 ）</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"500294514.jpg"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span>选这个<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>table 元素（表格元素）<br>tr元素 ：代表着表格中的一行；可以嵌套着td元素，代表着一个单元格<br>th元素：标题，字体加粗，且居中<br>border属性：边框属性，但是不推荐使用，后面可以跟1px，代表着1像素。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"1px"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>AAA<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>BBB<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>CCC<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/html5.png" alt="alt"></p>
<p>拆分单元格<br>colspan用来合并行;<br>rowspan用来合并列</p>
<p><strong>行合并</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"1px"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>AAA<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>BBB<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>CCC<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/html6.png" alt="alt"></p>
<p><strong>列合并</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"1px"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">"2"</span>&gt;</span>AAA<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>BBB<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>CCC<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>bbb<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>ccc<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/html7.png" alt="alt"></p>
<ul>
<li>列表元素（li：列表中的项）（有序列表和无序列表可以互相嵌套）<br>有序列表ol（默认升序，可以进行嵌套的，在一个有序列表中可以嵌套多个有序列表，从而实现标题的整齐）</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span>为什么喜欢我</span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span>&gt;</span>你长得太好看<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span>&gt;</span>你也太可爱了<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span>&gt;</span>无需理由<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/html8.png" alt="alt"></p>
<p>reversed元素：html最新元素，实现列表可以降序排列</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">reversed</span>&gt;</span>为什么喜欢我</span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>你长得太好看<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>你也太可爱了<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>无需理由<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/html9.png" alt="alt"></p>
<p>type元素：可以改变排序的前标，是123还是ABC都可以选择</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">type</span>=<span class="string">"A"</span>&gt;</span>为什么喜欢我</span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>你长得太好看<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>你也太可爱了<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>无需理由<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/html10.png" alt="alt"></p>
<ul>
<li>无序列表（ul）顺序用黑点排列（由于每个浏览器的符号大小不一样，所以我们一般都不用默认的符号，用css中ul的list-type的none去掉）ul和li都是块元素</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>bbb<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>ccc<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/html11.png" alt="alt"></p>
<ul>
<li>定义列表（dl dd dt来创建一个定义列表）<br>dl有两个子标签，dt为被定义的内容，dd是对定义内容的描述</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dt</span>&gt;</span>中国<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dd</span>&gt;</span>最强大的国家<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>表单元素 form元素（用户可以自己输入内容）<ul>
<li>method属性</li>
<li>input元素</li>
<li>action属性</li>
<li>textarea元素</li>
<li>select属性</li>
<li>datalist属性</li>
</ul>
</li>
</ul>
<p>input元素（单行文本框，有29种属性）<br>text属性（默认就是text属性）<br>value属性（占位符，自动填充上所写的字）<br>placeholder属性（提示，没点击是暗的，点击消失）<br>maxlength属性（最大字符数，超过就输不进去）<br>type中password属性 实现以黑点形式出现</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">"12123213"</span> <span class="attr">placeholder</span>=<span class="string">"密码"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/html12.png" alt="alt"></p>
<ul>
<li>type中button属性（按钮属性）<br>分为三种形式</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.button按钮（和js合作，用来绑定事件的）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3.提交按钮</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/html13.png" alt="alt"></p>
<p>type中range属性（数字滑动块 ）<br>max:滑块最大值<br>min:滑块最小值<br>step:每次滑动的距离<br>value：起始的位置，默认为0，在滑表的中间</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"range"</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/html14.png" alt="alt"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"range"</span> <span class="attr">step</span>=<span class="string">"12"</span> <span class="attr">max</span>=<span class="string">"200"</span> <span class="attr">min</span>=<span class="string">"-100"</span> <span class="attr">value</span>=<span class="string">"0"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>type中number属性(可以手动输入的，可以调节大小的值)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"number"</span> <span class="attr">min</span>=<span class="string">"0"</span> <span class="attr">max</span>=<span class="string">"100"</span> <span class="attr">value</span>=<span class="string">"90"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>type中checkbox属性（相当于打对勾的功能，只有选择才能传输到服务器中去，传送到服务器上是布尔型）</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span>  <span class="attr">type</span>=<span class="string">"checkbox"</span>选择 &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/html15.png" alt="alt"></p>
<ul>
<li>type中radio属性（和checkbox功能一样，但是这个选择后就不能取消了，生成一组固定选项）<br>name属性，当多个选项出现时，由name选项可以实现三选一的效果<br>checked属性，默认一个选项</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span>你最喜欢的水果</span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"a"</span>&gt;</span>苹果</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"a"</span>&gt;</span>葡萄</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"a"</span> <span class="attr">checked</span>&gt;</span>芒果</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/html16.png" alt="alt"></p>
<ul>
<li>select元素（可以进行选择，但是不可以自己输入）<br>option元素：可供选择的项</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span>你最喜欢的水果</span><br><span class="line">   <span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">option</span>&gt;</span>香蕉<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">option</span>&gt;</span>橙子<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">option</span>&gt;</span>西瓜<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/html17.png" alt="alt"></p>
<ul>
<li>datalist元素(实现选择，类似是select，但是这个可以自己输入，不过要用id引导)<br>用id引导后，用input元素中的list属性来进行引导</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span>你最喜欢的水果</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">list</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">datalist</span> <span class="attr">id</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span>&gt;</span>香蕉<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span>&gt;</span>西瓜<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span>&gt;</span>橙子<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">datalist</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/html18.png" alt="alt"></p>
<ul>
<li><p>img标签即图片标签，引入外部图片，src属性是图片的地址，也就是图片路径（相对路径，相对于当前资源所在目录的位置，如果图片在当前网页的上一个文件夹，可以用…/来返回上一级 例：…/2.gif）width属性是宽度，height属性是高度（一般开发不设置这两个图片，设置了图片可能会失真），alt是设置图片的备用内容，设置图片的描述<br>（当图片找不到时候，会出现alt备用的内容，搜索引擎会通过alt属性来识别不同的图片，如果没有alt属性，搜索引擎不会对img图片进行收录）</p>
</li>
<li><p>img属性和a标签相结合构成图片可以点击进入url</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"0722.1html.html"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"500294514.jpg"</span> <span class="attr">width</span>=<span class="string">"100px"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>video元素中基本属性<br>src：视频地址<br>height：视频高度<br>width：宽度大小<br>autoplay：自动播放<br>contros：播放控制键<br>preload：预先载入视频<br>none：不会载入视频。<br>metadata：只载入第一帧。<br>auto：请求下载整个视频，默认行为。<br>loop：循环播放。<br>poster：视频载入时显示图片，视频的封面。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">"001_如何学习JAVA300集（一定要看…………）.mp4"</span></span></span><br><span class="line"><span class="tag"> <span class="attr">controls</span> <span class="attr">height</span>=<span class="string">"440"</span> <span class="attr">width</span>=<span class="string">"600px"</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="内联元素-inline-："><a href="#内联元素-inline-：" class="headerlink" title="内联元素(inline)："></a>内联元素(inline)：</h3><ul>
<li>a – 锚点 </li>
<li>abbr – 缩写 </li>
<li>acronym – 首字 </li>
<li>b – 粗体(不推荐) </li>
<li>big – 大字体 </li>
<li>br – 换行 </li>
<li>cite – 引用 </li>
<li>code – 计算机代码(在引用源码的时候需要) </li>
<li>dfn – 定义字段 </li>
<li>em – 强调 </li>
<li>font – 字体设定(不推荐) </li>
<li>i – 斜体 </li>
<li>img – 图片 </li>
<li>input – 输入框 </li>
<li>kbd – 定义键盘文本 </li>
<li>label – 表格标签 </li>
<li>q – 短引用 </li>
<li>s – 中划线(不推荐) </li>
<li>samp – 定义范例计算机代码 </li>
<li>select – 项目选择 </li>
<li>small – 小字体文本 </li>
<li>span – 常用内联容器，定义文本内区块 </li>
<li>strike – 中划线 </li>
<li>strong – 粗体强调 </li>
<li>sub – 下标 </li>
<li>sup – 上标 </li>
<li>textarea – 多行文本输入框 </li>
<li>tt – 电传文本 </li>
<li>u – 下划线</li>
</ul>
<h3 id="块级元素-block-："><a href="#块级元素-block-：" class="headerlink" title="块级元素(block)："></a>块级元素(block)：</h3><ul>
<li>address – 地址 </li>
<li>blockquote – 块引用 </li>
<li>center – 举中对齐块 </li>
<li>dir – 目录列表 </li>
<li>div – 常用块级容易，也是CSS layout的主要标签 </li>
<li>dl – 定义列表 </li>
<li>fieldset – form控制组 </li>
<li>form – 交互表单 </li>
<li>h1 – 大标题 </li>
<li>h2 – 副标题 </li>
<li>h3 – 3级标题 </li>
<li>h4 – 4级标题 </li>
<li>h5 – 5级标题 </li>
<li>h6 – 6级标题 </li>
<li>hr – 水平分隔线 </li>
<li>menu – 菜单列表 </li>
<li>ol – 有序表单 </li>
<li>p – 段落 </li>
<li>pre – 格式化文本 </li>
<li>table – 表格 </li>
<li>ul – 无序列表 </li>
<li>li</li>
</ul>
<h2 id="内联元素与块级元素的区别"><a href="#内联元素与块级元素的区别" class="headerlink" title="内联元素与块级元素的区别:"></a>内联元素与块级元素的区别:</h2><h3 id="内联元素："><a href="#内联元素：" class="headerlink" title="内联元素："></a>内联元素：</h3><ol>
<li>内联元素不会独占一行，相邻的内联元素会排在同一行。其宽度随内容的变化而变化。 </li>
<li>内联元素不可以设置宽高 </li>
<li>内联元素可以设置margin，padding，但只在水平方向有效。</li>
</ol>
<h3 id="块状元素："><a href="#块状元素：" class="headerlink" title="块状元素："></a>块状元素：</h3><ol>
<li>块级元素会独占一行，默认情况下宽度自动填满其父元素宽度 </li>
<li>块级元素可以设置宽高 </li>
<li>块级元素可以设置margin，padding</li>
</ol>
<h3 id="关联："><a href="#关联：" class="headerlink" title="关联："></a>关联：</h3><p>可以通过修改display属性来切换块级元素和内联元素 </p>
<ol>
<li>块级：display:block; </li>
<li>内联：display:inline;</li>
<li>内联块状元素: display:inline-block;</li>
</ol>
<p>内联块状元素inline-block：<br>简单来说就是将对象呈现为inline对象，但是对象的内容作为block对象呈现（可以设置宽高和margin值）。之后的内联对象会被排列在同一内联。比如我们可以给一个link（a元素）inline-block属性值，使其既具有block的宽度高度特性又具有inline的同行特性。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>2n皇后</title>
    <url>/2020/02/17/8queen/</url>
    <content><![CDATA[<p>原题链接：<a href="http://lx.lanqiao.cn/problem.page?gpid=T68" target="_blank" rel="noopener">蓝桥杯T86</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定一个n*n的棋盘，棋盘中有一些位置不能放皇后。现在要向棋盘中放入n个黑皇后和 n个白皇后，使任意的两个黑皇后都不在同一行、同一列或同一条对角线上，任意的两个白皇后都不在同一行、同一列或同一条对角线上。问总共有多少种放法？n小于等于8</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入的第一行为一个整数n，表示棋盘的大小。<br>接下来n行，每行n个0或1的整数，如果一个整数为1，表示对应的位置可以放皇后，如果一个整数为0，表示对应的位置不可以放皇后。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个整数，表示总共有多少种放法。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">1 1 1 1</span><br><span class="line">1 1 1 1</span><br><span class="line">1 1 1 1</span><br><span class="line">1 1 1 1</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[<span class="number">8</span>][<span class="number">8</span>];</span><br><span class="line"><span class="keyword">int</span> n, ans;</span><br><span class="line"><span class="keyword">int</span> bqueenpos[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> wqueenpos[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WQueen</span><span class="params">(<span class="keyword">int</span> k)</span><span class="comment">//摆放白皇后</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (k == n)</span><br><span class="line">		ans++;</span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (bqueenpos[k] == i||<span class="built_in">map</span>[k][i]==<span class="number">0</span>)<span class="comment">//与黑色查重</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; k; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (wqueenpos[j] == i || <span class="built_in">abs</span>(wqueenpos[j] - i) == <span class="built_in">abs</span>(k - j))</span><br><span class="line">				<span class="keyword">break</span>;  <span class="comment">//与之前摆放的白色查重</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (j == k)</span><br><span class="line">		&#123;</span><br><span class="line">			wqueenpos[k] = i;</span><br><span class="line">			WQueen(k + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BQueen</span><span class="params">(<span class="keyword">int</span> k)</span><span class="comment">//摆放黑皇后，k表示行</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (k == n)<span class="comment">//黑色摆放好</span></span><br><span class="line">	&#123;</span><br><span class="line">		WQueen(<span class="number">0</span>);<span class="comment">//开始摆放白</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)<span class="comment">//i枚举所有列</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">map</span>[k][i] == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; k; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (bqueenpos[j] == i || <span class="built_in">abs</span>(bqueenpos[j] - i) == <span class="built_in">abs</span>(k - j))</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (j == k)<span class="comment">//不发生冲突</span></span><br><span class="line">		&#123;</span><br><span class="line">			bqueenpos[k] = i;<span class="comment">//记录位置</span></span><br><span class="line">			BQueen(k + <span class="number">1</span>);<span class="comment">//递归下一个位置</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; <span class="built_in">map</span>[i][j];</span><br><span class="line">	BQueen(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>防晒 acwing 110</title>
    <url>/2020/02/17/ac110/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/112/" target="_blank" rel="noopener">Acwing110</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>有C头奶牛进行日光浴，第i头奶牛需要minSPF[i]到maxSPF[i]单位强度之间的阳光。<br>每头奶牛在日光浴前必须涂防晒霜，防晒霜有L种，涂上第i种之后，身体接收到的阳光强度就会稳定为SPF[i]，第i种防晒霜有cover[i]瓶。<br>求最多可以满足多少头奶牛进行日光浴。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行输入整数C和L。</p>
<p>接下来的C行，按次序每行输入一头牛的minSPF和maxSPF值,即第i行输入minSPF[i]和maxSPF[i]。</p>
<p>再接下来的L行，按次序每行输入一种防晒霜的SPF和cover值,即第i行输入SPF[i]和cover[i]。</p>
<p>每行的数据之间用空格隔开。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个整数，代表最多可以满足奶牛日光浴的奶牛数目。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤C,L≤2500 ,<br>1≤minSPF≤maxSPF≤1000,<br>1≤SPF≤1000</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 2</span><br><span class="line">3 10</span><br><span class="line">2 5</span><br><span class="line">1 5</span><br><span class="line">6 2</span><br><span class="line">4 1</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>

<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>(贪心) O(nlogn)</p>
<p>算法流程：</p>
<ol>
<li>将所有奶牛按照 minSPF 从大到小的顺序排序，然后依次考虑每头奶牛；</li>
<li>对于每头奶牛，扫描当前所有能用的防晒霜，选择 SPF 值最大的防晒霜来用；</li>
</ol>
<p>根据匈牙利算法的原理，如果一个匹配不存在增广路径，则该匹配是二分图的一个最大匹配。下面我们来证明按照上述做法得到的匹配方案，不存在增广路径。<br>运用反证法证明，上述方法得到的匹配方案不存在增广路径。<br>假设有某瓶未被防晒霜可以与第k头牛匹配，那么它必然不能和小于k的牛<br>匹配，否则根据算法思路，它必然已经被小于k的牛使用了。故若存在<br>增广路径，那么它只能与k以上的牛匹配，如果存在增广路径，那么第一头<br>牛在一开始必然没有匹配，这与算法矛盾，因为最上面的牛应当最先匹配一个<br>点，所以原算法不存在增广路径</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;PII;</span><br><span class="line">priority_queue&lt;PII, <span class="built_in">vector</span>&lt;PII&gt;, less&lt;PII&gt;&gt; q;</span><br><span class="line">PII p[<span class="number">2510</span>];</span><br><span class="line"><span class="keyword">int</span> C, L, minSPF, maxSPF, SPF, cover, counts, tempi, j;</span><br><span class="line">PII tempp;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(PII a, PII b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.first &gt; b.first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; C &gt;&gt; L;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; C; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; minSPF &gt;&gt; maxSPF;</span><br><span class="line">		q.push(&#123; minSPF,maxSPF &#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; p[i].first &gt;&gt; p[i].second;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	sort(p, p + L, cmp);</span><br><span class="line">	<span class="keyword">while</span> (!q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		tempp = q.top();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; L; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (p[j].first &gt;= tempp.first&amp;&amp;p[j].first &lt;= tempp.second&amp;&amp;p[j].second != <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				counts++;</span><br><span class="line">				p[j].second--;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		q.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; counts &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>兔子与兔子 acwing 138</title>
    <url>/2020/02/17/ac138/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/140/" target="_blank" rel="noopener">Acwing138</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>很久很久以前，森林里住着一群兔子。</p>
<p>有一天，兔子们想要研究自己的 DNA 序列。</p>
<p>我们首先选取一个好长好长的 DNA 序列（小兔子是外星生物，DNA 序列可能包含 26 个小写英文字母）。</p>
<p>然后我们每次选择两个区间，询问如果用两个区间里的 DNA 序列分别生产出来两只兔子，这两个兔子是否一模一样。</p>
<p>注意两个兔子一模一样只可能是他们的 DNA 序列一模一样。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行输入一个 DNA 字符串 S。</p>
<p>第二行一个数字 m，表示 m 次询问。</p>
<p>接下来 m 行，每行四个数字 l1,r1,l2,r2，分别表示此次询问的两个区间，注意字符串的位置从1开始编号。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>对于每次询问，输出一行表示结果。</p>
<p>如果两只兔子完全相同输出 Yes，否则输出 No（注意大小写）。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤length(S),m≤1000000</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aabbaabb</span><br><span class="line">3</span><br><span class="line">1 3 5 7</span><br><span class="line">1 3 6 8</span><br><span class="line">1 2 1 2</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">Yes</span><br></pre></td></tr></table></figure>

<h3 id="字符串hash"><a href="#字符串hash" class="headerlink" title="字符串hash"></a>字符串hash</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">字符串哈希，就是将字符串变成数值，最终得到的数值是一个p进制数，并且</span><br><span class="line">p最好是素数，这里p一般取131和13331</span><br><span class="line">由于这种方式得到的数很大，我们一般要模上一个数字，这里的取模数字一般</span><br><span class="line">取2^64,即unsigned ll 的默认取模即可</span><br></pre></td></tr></table></figure>


<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ULL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000100</span>;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line">ULL hashh[N], p[N], n, len, b1, e1, b2, e2;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%s"</span>, str + <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	len = <span class="built_in">strlen</span>(str + <span class="number">1</span>);</span><br><span class="line">	p[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">	    hashh[i] = hashh[i - <span class="number">1</span>] * <span class="number">131</span> + str[i] - <span class="string">'a'</span> + <span class="number">1</span>;<span class="comment">//前缀和递推求出每一个哈希值</span></span><br><span class="line">	    p[i] = p[i<span class="number">-1</span>] * <span class="number">131</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; b1 &gt;&gt; e1 &gt;&gt; b2 &gt;&gt; e2;</span><br><span class="line">		ULL fir = hashh[e1] - hashh[b1] * p[e1-b1];</span><br><span class="line">		ULL sec=  hashh[e2] - hashh[b2] * p[e1-b1];</span><br><span class="line">		<span class="keyword">if</span> (fir == sec) <span class="built_in">cout</span> &lt;&lt; <span class="string">"Yes"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"No"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title>直方图中最大的矩形 acwing 131</title>
    <url>/2020/02/17/ac131/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/133/" target="_blank" rel="noopener">Acwing131</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>直方图是由在公共基线处对齐的一系列矩形组成的多边形。</p>
<p>矩形具有相等的宽度，但可以具有不同的高度。</p>
<p>例如，图例左侧显示了由高度为2,1,4,5,1,3,3的矩形组成的直方图，矩形的宽度都为1：</p>
<p><img src="/ac131.png" alt="alt"></p>
<p>通常，直方图用于表示离散分布，例如，文本中字符的频率。</p>
<p>现在，请你计算在公共基线处对齐的直方图中最大矩形的面积。</p>
<p>图例右图显示了所描绘直方图的最大对齐矩形。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入包含几个测试用例。</p>
<p>每个测试用例占据一行，用以描述一个直方图，并以整数n开始，表示组成直方图的矩形数目。</p>
<p>然后跟随n个整数h1，…，hn。</p>
<p>这些数字以从左到右的顺序表示直方图的各个矩形的高度。</p>
<p>每个矩形的宽度为1。</p>
<p>同行数字用空格隔开。</p>
<p>当输入用例为n=0时，结束输入，且该用例不用考虑。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>对于每一个测试用例，输出一个整数，代表指定直方图中最大矩形的区域面积。</p>
<p>每个数据占一行。</p>
<p>请注意，此矩形必须在公共基线处对齐。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤n≤100000,<br>0≤hi≤1000000000</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7 2 1 4 5 1 3 3</span><br><span class="line">4 1000 1000 1000 1000</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">4000</span><br></pre></td></tr></table></figure>

<h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">此问题用到单调栈的思想，即栈内元素单调增或单调减，经过观察，我们发现</span><br><span class="line">当某一个矩形左侧的矩形比它自身要高时，它自身的高度对于左侧便失去了</span><br><span class="line">意义，所以我们可以保持栈内的元素是单调递增的，每次遇到比栈顶元素小的</span><br><span class="line">元素时，就不断弹出栈内元素，直到栈顶元素小于当前元素，同时计算出弹出</span><br><span class="line">元素所形成的最大面积</span><br></pre></td></tr></table></figure>



<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">101010</span>;</span><br><span class="line">ll n, p, len, res, a[N], s[N], w[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n, n)</span><br><span class="line">	&#123;</span><br><span class="line">		res = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">		a[n + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">		p = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (s[p] &lt; a[i])<span class="comment">//保证栈中是递增序列</span></span><br><span class="line">			&#123;</span><br><span class="line">				s[++p] = a[i];</span><br><span class="line">				w[p] = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				len = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">while</span> (s[p] &gt; a[i])</span><br><span class="line">				&#123;</span><br><span class="line">					len += w[p];</span><br><span class="line">					res = max(res, s[p] * len);</span><br><span class="line">					p--;</span><br><span class="line">				&#125;</span><br><span class="line">				s[++p] = a[i];</span><br><span class="line">				w[p] = len + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>编辑器 acwing 128</title>
    <url>/2020/02/17/ac128/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/130/" target="_blank" rel="noopener">Acwing128</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>你将要实现一个功能强大的整数序列编辑器。</p>
<p>在开始时，序列是空的。</p>
<p>编辑器共有五种指令，如下：</p>
<p>1、“I x”，在光标处插入数值x。<br>2、“D”，将光标前面的第一个元素删除，如果前面没有元素，则忽略此操作。<br>3、“L”，将光标向左移动，跳过一个元素，如果左边没有元素，则忽略此操作。<br>4、“R”，将光标向右移动，跳过一个元素，如果右边没有元素，则忽略次操作。<br>5、“Q k”，假设此刻光标之前的序列为a1,a2,…,an,输出max1≤i≤kSi，其中Si=a1+a2+…+ai。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含一个整数Q，表示指令的总数。</p>
<p>接下来Q行，每行一个指令，具体指令格式如题目描述。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>每一个“Q k”指令，输出一个整数作为结果，每个结果占一行</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤Q≤106,<br>|x|≤103,<br>1≤k≤n</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">I 2</span><br><span class="line">I -1</span><br><span class="line">I 1</span><br><span class="line">Q 3</span><br><span class="line">L</span><br><span class="line">D</span><br><span class="line">R</span><br><span class="line">Q 2</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在光标左侧和右侧分别建立一个栈，L操作对应于将左侧栈顶元素弹出并加入</span><br><span class="line">到右侧栈，R操作反之，每次在左侧栈中加入元素(L 或 l x 操作)都要计算</span><br><span class="line">一下当前的和</span><br></pre></td></tr></table></figure>


<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1E6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; p, q;</span><br><span class="line"><span class="keyword">int</span> sum[N], f[N], n, v;</span><br><span class="line"><span class="keyword">char</span> a;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	f[<span class="number">0</span>] = <span class="number">-1e7</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">		<span class="keyword">if</span> (a == <span class="string">'L'</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!p.empty())</span><br><span class="line">			&#123;</span><br><span class="line">				q.push(p.top());</span><br><span class="line">				p.pop();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="string">'R'</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!q.empty())</span><br><span class="line">			&#123;</span><br><span class="line">				p.push(q.top());</span><br><span class="line">				q.pop();</span><br><span class="line">				sum[p.size()] = sum[p.size() - <span class="number">1</span>] + p.top();</span><br><span class="line">				f[p.size()] = max(f[p.size() - <span class="number">1</span>], sum[p.size()]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="string">'D'</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!p.empty())</span><br><span class="line">				p.pop();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="string">'I'</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; v;</span><br><span class="line">			p.push(v);</span><br><span class="line">			sum[p.size()] = sum[p.size() - <span class="number">1</span>] + p.top();</span><br><span class="line">			f[p.size()] = max(f[p.size() - <span class="number">1</span>], sum[p.size()]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="string">'Q'</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; v;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; f[v] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>回文子串的最大长度 acwing 139</title>
    <url>/2020/02/17/ac139/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/141/" target="_blank" rel="noopener">Acwing139</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>如果一个字符串正着读和倒着读是一样的，则称它是回文的。</p>
<p>给定一个长度为N的字符串S，求他的最长回文子串的长度是多少。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入将包含最多30个测试用例，每个测试用例占一行，以最多1000000个小写字符的形式给出。</p>
<p>输入以一个以字符串“END”（不包括引号）开头的行表示输入终止。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>对于输入中的每个测试用例，输出测试用例编号和最大回文子串的长度（参考样例格式）。</p>
<p>每个输出占一行。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abcbabcbabcba</span><br><span class="line">abacacbaaaab</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Case 1: 13</span><br><span class="line">Case 2: 6</span><br></pre></td></tr></table></figure>

<h3 id="字符串hash"><a href="#字符串hash" class="headerlink" title="字符串hash"></a>字符串hash</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">先正反各计算出字符串hash值，之后再遍历所有中心，并运用二分的方法</span><br><span class="line">求出最大长度</span><br><span class="line"></span><br><span class="line">由于奇数回文串和偶数回文串不一样，我们为了统一这两种情况，将原字符串</span><br><span class="line">扩展为两倍，即在原字符串每两个直接插入一个无关元素，这样便只需在最后</span><br><span class="line">处理结果时判断回文串的边界是否为无关元素即可</span><br></pre></td></tr></table></figure>


<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2000010</span>, base = <span class="number">131</span>;</span><br><span class="line">ull hl[N], hr[N], p[N];</span><br><span class="line"><span class="comment">//hl表示从左往右的字符串hash</span></span><br><span class="line"><span class="comment">//hr表示从右往左的字符串hash</span></span><br><span class="line">ull l, r, mid, res, t;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="function">ull <span class="title">gett</span><span class="params">(ull h[], ull l, ull r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];  <span class="comment">//计算出l~r的字符串的哈希值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%s"</span>, str + <span class="number">1</span>), <span class="built_in">strcmp</span>(str + <span class="number">1</span>, <span class="string">"END"</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> len = <span class="built_in">strlen</span>(str + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = len * <span class="number">2</span>; i; i -= <span class="number">2</span>)<span class="comment">//扩充字符串以合并奇偶串两种情况</span></span><br><span class="line">		&#123;</span><br><span class="line">			str[i] = str[i / <span class="number">2</span>];</span><br><span class="line">			str[i - <span class="number">1</span>] = <span class="string">'z'</span> + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		len *= <span class="number">2</span>;<span class="comment">//合并完长度要乘以2</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = len; i &lt;= len; i++, j--)<span class="comment">//初始化信息</span></span><br><span class="line">		&#123;</span><br><span class="line">			hl[i] = hl[i - <span class="number">1</span>] * base + str[i] - <span class="string">'a'</span> + <span class="number">1</span>;</span><br><span class="line">			hr[i] = hr[i - <span class="number">1</span>] * base + str[j] - <span class="string">'a'</span> + <span class="number">1</span>;</span><br><span class="line">			p[i] = p[i - <span class="number">1</span>] * base;</span><br><span class="line">		&#125;</span><br><span class="line">		res = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			l = <span class="number">0</span>;</span><br><span class="line">			r = min(i - <span class="number">1</span>, len - i);</span><br><span class="line">			<span class="keyword">while</span> (l &lt; r)<span class="comment">//二分法</span></span><br><span class="line">			&#123;</span><br><span class="line">				mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span> (gett(hl, i - mid, i - <span class="number">1</span>) != gett(hr, len - mid - i + <span class="number">1</span>, len - i))<span class="comment">//注意边界的取值</span></span><br><span class="line">					r = mid - <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					l = mid;</span><br><span class="line">			&#125; </span><br><span class="line">			<span class="comment">//mid可理解为回文串中心到两边的距离</span></span><br><span class="line">			mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (str[i - mid] &gt; <span class="string">'z'</span>)<span class="comment">//如果边界是无用字符</span></span><br><span class="line">				res = max(res, mid);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				res = max(res, mid + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Case %d: %d\n"</span>, ++t, res);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title>城市游戏 acwing 152</title>
    <url>/2020/02/17/ac152/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/154/" target="_blank" rel="noopener">Acwing152</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>有一天，小猫rainbow和freda来到了湘西张家界的天门山玉蟾宫，玉蟾宫宫主蓝兔盛情地款待了它们，并赐予它们一片土地。</p>
<p>这片土地被分成N*M个格子，每个格子里写着’R’或者’F’，R代表这块土地被赐予了rainbow，F代表这块土地被赐予了freda。</p>
<p>现在freda要在这里卖萌。。。它要找一块矩形土地，要求这片土地都标着’F’并且面积最大。</p>
<p>但是rainbow和freda的OI水平都弱爆了，找不出这块土地，而蓝兔也想看freda卖萌（她显然是不会编程的……），所以它们决定，如果你找到的土地面积为S，它们将给你3*S两银子。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包括两个整数N,M，表示矩形土地有N行M列。</p>
<p>接下来N行，每行M个用空格隔开的字符’F’或’R’，描述了矩形土地。</p>
<p>每行末尾没有多余空格。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个整数，表示你能得到多少银子，即(3*最大’F’矩形土地面积)的值。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤N,M≤1000</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 6</span><br><span class="line">R F F F F F</span><br><span class="line">F F F F F F</span><br><span class="line">R R R F F F</span><br><span class="line">F F F F F F</span><br><span class="line">F F F F F F</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">45</span><br></pre></td></tr></table></figure>

<h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">与直方图中的最大矩形问题类似，在此问题中，如果我们将每一行上方的F的</span><br><span class="line">个数看作是矩形的高度，那么该问题就等效为求出每一行的最大矩形面积，即</span><br><span class="line">对每一行分别运用单调栈的思想求解</span><br></pre></td></tr></table></figure>


<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">char</span> g[N][N];</span><br><span class="line"><span class="keyword">int</span> h[N][N];</span><br><span class="line"><span class="keyword">int</span> q[N], l[N], r[N];</span><br><span class="line"><span class="comment">// l[i]表示比第i个元素小且在i左边的第一个元素的右边一个元素(即左边可达的最大长度)</span></span><br><span class="line"><span class="comment">// r[i]表示比第i个元素小且在i右边的第一个元素的右边一个元素(即右边可达的最大长度)</span></span><br><span class="line"><span class="comment">// q是一个单调栈，栈内元素单调递增，存放的是元素的下标</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> l[])</span><span class="comment">//初始化l，r数组</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">	a[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (a[q[tt]] &gt;= a[i]) tt--;</span><br><span class="line">		l[i] = q[tt] + <span class="number">1</span>;</span><br><span class="line">		q[++tt] = i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> a[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cal(a, l);</span><br><span class="line">	reverse(a + <span class="number">1</span>, a + <span class="number">1</span> + m);</span><br><span class="line">	cal(a, r);</span><br><span class="line">	reverse(a + <span class="number">1</span>, a + <span class="number">1</span> + m);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> left = l[i];<span class="comment">//左边可达长度</span></span><br><span class="line">		<span class="keyword">int</span> right = m + <span class="number">1</span> - r[m + <span class="number">1</span> - i];<span class="comment">//右边可达长度</span></span><br><span class="line">		res = max(res, a[i] * (right - left + <span class="number">1</span>));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; g[i][j];</span><br><span class="line">			<span class="comment">//运用dp求出每个元素上方的F的个数</span></span><br><span class="line">			<span class="keyword">if</span> (g[i][j] == <span class="string">'F'</span>) h[i][j] = h[i - <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> h[i][j] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) res = max(res, work(h[i]));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; res * <span class="number">3</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>可达性统计 acwing 164</title>
    <url>/2020/02/17/ac164/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/166/" target="_blank" rel="noopener">Acwing164</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定一张N个点M条边的有向无环图，分别统计从每个点出发能够到达的点的数量。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行两个整数N,M，接下来M行每行两个整数x,y，表示从x到y的一条有向边。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出共N行，表示每个点能够到达的点的数量。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤N,M≤30000</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 10</span><br><span class="line">3 8</span><br><span class="line">2 3</span><br><span class="line">2 5</span><br><span class="line">5 9</span><br><span class="line">5 9</span><br><span class="line">2 3</span><br><span class="line">3 9</span><br><span class="line">4 8</span><br><span class="line">2 10</span><br><span class="line">4 9</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">6</span><br><span class="line">3</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h3 id="拓扑排序-bitset二进制数组"><a href="#拓扑排序-bitset二进制数组" class="headerlink" title="拓扑排序+bitset二进制数组"></a>拓扑排序+bitset二进制数组</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">有向无环图是拓扑排序的必要条件,而且这道题目明确告诉我们统计从每个点</span><br><span class="line">出发能够到达的点的数量,也就是说统计这个点可以抵达的个数,这样的话我</span><br><span class="line">们只需要再开一个数组f.f[i]表示i这个点的可以抵达点的数量.我们很快</span><br><span class="line">就可以发现性质.</span><br><span class="line">f[i]&#x3D;所有出边上点的交集.既然如此的话,我们不妨开一个二进制数组来</span><br><span class="line">进行并集|运算即可.</span><br></pre></td></tr></table></figure>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> net[N], head[N], ver[N], deg[N], tot, cnt, a[N], n, m;</span><br><span class="line"><span class="built_in">bitset</span> &lt;N&gt; f[N]; <span class="comment">//二进制数组 默认为N位的0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span><span class="comment">//添加有向边</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ver[++tot] = y;</span><br><span class="line">	net[tot] = head[x];<span class="comment">//保存上一条路径</span></span><br><span class="line">	head[x] = tot;<span class="comment">//更新当前头节点</span></span><br><span class="line">	deg[y]++;<span class="comment">//入度+1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topsort</span><span class="params">()</span><span class="comment">//拓扑排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!deg[i])<span class="comment">//找出入度为0的点</span></span><br><span class="line">			q.push(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (q.size())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> x = q.front();</span><br><span class="line">		a[++cnt] = x;</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = net[i])<span class="comment">//访问所有边</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> y = ver[i];</span><br><span class="line">			deg[y]--;</span><br><span class="line">			<span class="keyword">if</span> (!deg[y])</span><br><span class="line">				q.push(y);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">()</span><span class="comment">//统计路径个数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = cnt; j; j--) <span class="comment">//从后向前遍历</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> x = a[j];</span><br><span class="line">		f[x][x] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = net[i])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> y = ver[i];</span><br><span class="line">			f[x] |= f[y]; <span class="comment">//求并集</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x, y;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		add(x, y);</span><br><span class="line">	&#125;</span><br><span class="line">	topsort();</span><br><span class="line">	calc();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; f[i].count() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//统计1的个数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>小猫爬山 acwing 165</title>
    <url>/2020/02/17/ac165/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/167/" target="_blank" rel="noopener">Acwing165</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>翰翰和达达饲养了N只小猫，这天，小猫们要去爬山。</p>
<p>经历了千辛万苦，小猫们终于爬上了山顶，但是疲倦的它们再也不想徒步走下山了（呜咕&gt;_&lt;）。</p>
<p>翰翰和达达只好花钱让它们坐索道下山。</p>
<p>索道上的缆车最大承重量为W，而N只小猫的重量分别是C1、C2……CN。</p>
<p>当然，每辆缆车上的小猫的重量之和不能超过W。</p>
<p>每租用一辆缆车，翰翰和达达就要付1美元，所以他们想知道，最少需要付多少美元才能把这N只小猫都运送下山？</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第1行：包含两个用空格隔开的整数，N和W。</p>
<p>第2..N+1行：每行一个整数，其中第i+1行的整数表示第i只小猫的重量Ci。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个整数，表示最少需要多少美元，也就是最少需要多少辆缆车。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤N≤18,<br>1≤Ci≤W≤1E8</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 1996</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">1994</span><br><span class="line">12</span><br><span class="line">29</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>

<h3 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.将猫的体重从大到小排序</span><br><span class="line">2.如果当前答案大于已知最小答案则立即回溯</span><br></pre></td></tr></table></figure>
<p>代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, w, res = <span class="number">30</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">20</span>], a[<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (res &lt;= cnt) <span class="comment">//剪枝2</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (cur == n)</span><br><span class="line">	&#123;</span><br><span class="line">		res = min(res, cnt);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= cnt; i++)<span class="comment">//遍历所有的车</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (f[i] + a[cur] &lt;= w)</span><br><span class="line">		&#123;</span><br><span class="line">			f[i] += a[cur];</span><br><span class="line">			dfs(cur + <span class="number">1</span>, cnt);</span><br><span class="line">			f[i] -= a[cur];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//未返回说明当前车不够，需再加车</span></span><br><span class="line">	f[cnt + <span class="number">1</span>] = a[cur];</span><br><span class="line">	dfs(cur + <span class="number">1</span>, cnt + <span class="number">1</span>);</span><br><span class="line">	f[cnt + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; w;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	sort(a, a + n, cmp);<span class="comment">//剪枝1</span></span><br><span class="line">	dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; res + <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>数独 acwing 166</title>
    <url>/2020/02/17/ac166/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/168/" target="_blank" rel="noopener">Acwing166</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>数独是一种传统益智游戏，你需要把一个9 × 9的数独补充完整，使得图中每行、每列、每个3 × 3的九宫格内数字1~9均恰好出现一次。</p>
<p>请编写一个程序填写数独。</p>
<p><img src="/images/shudu.png" alt="alt"></p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入包含多组测试用例。</p>
<p>每个测试用例占一行，包含81个字符，代表数独的81个格内数据（顺序总体由上到下，同行由左到右）。</p>
<p>每个字符都是一个数字（1-9）或一个”.”（表示尚未填充）。</p>
<p>您可以假设输入中的每个谜题都只有一个解决方案。</p>
<p>文件结尾处为包含单词“end”的单行，表示输入结束。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>每个测试用例，输出一行数据，代表填充完全后的数独。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.2738..1..1...6735.......293.5692.8...........6.1745.364.......9518...7..8..6534.</span><br><span class="line">......52..8.4......3...9...5.1...6..2..7........3.....6...1..........7.4.......3.</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">527389416819426735436751829375692184194538267268174593643217958951843672782965341</span><br><span class="line">416837529982465371735129468571298643293746185864351297647913852359682714128574936</span><br></pre></td></tr></table></figure>

<h3 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.优化搜索顺序，每次找可选数字最少的位置填数</span><br></pre></td></tr></table></figure>

<p>###优化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.位运算，通过位运算&amp; 可以方便求出当前位置可填的数</span><br><span class="line">2.lowbit可取出当前位的可能填的数</span><br></pre></td></tr></table></figure>

<p>代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[<span class="number">1</span> &lt;&lt; N], ones[<span class="number">1</span> &lt;&lt; N];</span><br><span class="line"><span class="keyword">int</span> row[N], col[N], cell[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x &amp; (-x);  <span class="comment">//返回最低位的1 ，如1011100返回100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> row[x] &amp; col[y] &amp; cell[x / <span class="number">3</span>][y / <span class="number">3</span>];<span class="comment">//求出当前位置能填的数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span><span class="comment">//初始化，将每位都初始化为1</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		row[i] = (<span class="number">1</span> &lt;&lt; N) - <span class="number">1</span>;</span><br><span class="line">		col[i] = (<span class="number">1</span> &lt;&lt; N) - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">			cell[i][j] = (<span class="number">1</span> &lt;&lt; N) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (cnt == <span class="number">0</span>)<span class="comment">//填完所有的数</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">int</span> mins = <span class="number">10</span>, x, y;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)<span class="comment">//找出可填数最少的位置</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (str[i * <span class="number">9</span> + j] == <span class="string">'.'</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> t = get(i, j);</span><br><span class="line">				<span class="keyword">int</span> s = ones[t];</span><br><span class="line">				<span class="keyword">if</span> (s &lt; mins)</span><br><span class="line">				&#123;</span><br><span class="line">					mins = s;</span><br><span class="line">					x = i;</span><br><span class="line">					y = j;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = get(x, y); i; i -= lowbit(i))<span class="comment">//遍历所有可填的数</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> t = lowbit(i);</span><br><span class="line">		row[x] -= t;</span><br><span class="line">		col[y] -= t;</span><br><span class="line">		cell[x / <span class="number">3</span>][y / <span class="number">3</span>] -= t;</span><br><span class="line">		str[x * <span class="number">9</span> + y] = <span class="string">'1'</span> + <span class="built_in">map</span>[t];</span><br><span class="line">		<span class="keyword">if</span> (dfs(cnt - <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		row[x] += t;</span><br><span class="line">		col[y] += t;</span><br><span class="line">		cell[x / <span class="number">3</span>][y / <span class="number">3</span>] += t;</span><br><span class="line">		str[x * <span class="number">9</span> + y] = <span class="string">'.'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">		<span class="built_in">map</span>[<span class="number">1</span> &lt;&lt; i] = i;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; N; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j; j -= lowbit(j))</span><br><span class="line">		&#123;</span><br><span class="line">			s++;</span><br><span class="line">		&#125;</span><br><span class="line">		ones[i] = s;<span class="comment">//统计每个数中1的个数</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; str, str[<span class="number">0</span>] != <span class="string">'e'</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		init();</span><br><span class="line">		<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> t = i * <span class="number">9</span> + j;</span><br><span class="line">				<span class="keyword">if</span> (str[t] != <span class="string">'.'</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">int</span> b = str[t] - <span class="string">'1'</span>;<span class="comment">//将该为变为0</span></span><br><span class="line">					row[i] -= (<span class="number">1</span> &lt;&lt; b);</span><br><span class="line">					col[j] -= (<span class="number">1</span> &lt;&lt; b);</span><br><span class="line">					cell[i / <span class="number">3</span>][j / <span class="number">3</span>] -= (<span class="number">1</span> &lt;&lt; b);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					cnt++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		dfs(cnt);</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>生日蛋糕 acwing 168</title>
    <url>/2020/02/17/ac168/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/170/" target="_blank" rel="noopener">Acwing168</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>7月17日是Mr.W的生日，ACM-THU为此要制作一个体积为Nπ的M层生日蛋糕，每层都是一个圆柱体。</p>
<p>设从下往上数第i层蛋糕是半径为Ri, 高度为Hi的圆柱。</p>
<p>当i &lt; M时，要求Ri &gt; Ri+1且Hi &gt; Hi+1。</p>
<p>由于要在蛋糕上抹奶油，为尽可能节约经费，我们希望蛋糕外表面（最下一层的下底面除外）的面积Q最小。</p>
<p>令Q = Sπ ，请编程对给出的N和M，找出蛋糕的制作方案（适当的Ri和Hi的值），使S最小。</p>
<p>除Q外，以上所有数据皆为正整数 。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入包含两行，第一行为整数N（N &lt;= 10000），表示待制作的蛋糕的体积为Nπ。</p>
<p>第二行为整数M(M &lt;= 20)，表示蛋糕的层数为M。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出仅一行，是一个正整数S（若无解则S = 0）。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤N≤10000,<br>1≤M≤20</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">100</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">68</span><br></pre></td></tr></table></figure>

<h3 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.从体积大的盘子搜到体积小的盘子</span><br><span class="line">2.通过数学推导缩小上下界</span><br><span class="line">3.当前体积+剩余可能最小体积&gt;n,返回</span><br><span class="line">4.当前面积+剩余可能最优面积&gt;ans,返回</span><br><span class="line">5.数学剪枝,2(n-v)&#x2F;r[dep] +s &gt;ans,返回</span><br></pre></td></tr></table></figure>



<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxx = <span class="number">0x7ffff</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> minv[<span class="number">30</span>], mins[<span class="number">30</span>];</span><br><span class="line"><span class="keyword">int</span> h[<span class="number">30</span>], r[<span class="number">30</span>], ans = maxx;</span><br><span class="line"><span class="keyword">int</span> v, s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> dep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!dep)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (v == n)</span><br><span class="line">			ans = min(ans, s);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (r[dep] = min((<span class="keyword">int</span>)<span class="built_in">sqrt</span>(n - v), r[dep + <span class="number">1</span>] - <span class="number">1</span>); r[dep] &gt;= dep; r[dep]--)<span class="comment">//剪枝1，2</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (h[dep] = min((<span class="keyword">int</span>)((<span class="keyword">double</span>)(n - v) / (r[dep] * r[dep])), h[dep + <span class="number">1</span>] - <span class="number">1</span>); h[dep] &gt;= dep; h[dep]--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (v + minv[dep] &gt; n) <span class="keyword">continue</span>;<span class="comment">//剪枝3</span></span><br><span class="line">			<span class="keyword">if</span> (s + mins[dep] &gt; ans) <span class="keyword">continue</span>;<span class="comment">//剪枝4</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="number">2</span> * (n - v) / r[dep] + s &gt; ans) <span class="keyword">continue</span>;<span class="comment">//剪枝5</span></span><br><span class="line">			<span class="keyword">if</span> (dep == m) s += r[dep] * r[dep];</span><br><span class="line">			s += <span class="number">2</span> * r[dep] * h[dep];</span><br><span class="line">			v += r[dep] * r[dep] * h[dep];</span><br><span class="line">			dfs(dep - <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span> (dep == m) s -= r[dep] * r[dep];</span><br><span class="line">			s -= <span class="number">2</span> * r[dep] * h[dep];</span><br><span class="line">			v -= r[dep] * r[dep] * h[dep];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)<span class="comment">//求出剩下部分可能的最小值</span></span><br><span class="line">	&#123;</span><br><span class="line">		minv[i] = minv[i - <span class="number">1</span>] + i * i * i;</span><br><span class="line">		mins[i] = mins[i - <span class="number">1</span>] + i * i * <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	h[m + <span class="number">1</span>] = r[m + <span class="number">1</span>] = maxx;</span><br><span class="line">	dfs(m);</span><br><span class="line">	<span class="keyword">if</span> (ans == maxx)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"0"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>dfs</tag>
        <tag>剪枝</tag>
      </tags>
  </entry>
  <entry>
    <title>加成序列 acwing 170</title>
    <url>/2020/02/17/ac170/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/172/" target="_blank" rel="noopener">Acwing170</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>满足如下条件的序列X（序列中元素被标号为1、2、3…m）被称为“加成序列”：</p>
<p>1、X[1]=1</p>
<p>2、X[m]=n</p>
<p>3、X[1]&lt;X[2]&lt;…&lt;X[m-1]&lt;X[m]</p>
<p>4、对于每个 k（2≤k≤m）都存在两个整数 i 和 j （1≤i,j≤k−1，i 和 j 可相等），使得X[k]=X[i]+X[j]。</p>
<p>你的任务是：给定一个整数n，找出符合上述条件的长度m最小的“加成序列”。</p>
<p>如果有多个满足要求的答案，只需要找出任意一个可行解。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入包含多组测试用例。</p>
<p>每组测试用例占据一行，包含一个整数n。</p>
<p>当输入为单行的0时，表示输入结束。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>对于每个测试用例，输出一个满足需求的整数序列，数字之间用空格隔开。</p>
<p>每个输出占一行。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤n≤100</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">7</span><br><span class="line">12</span><br><span class="line">15</span><br><span class="line">77</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 2 4 5</span><br><span class="line">1 2 4 6 7</span><br><span class="line">1 2 4 8 12</span><br><span class="line">1 2 4 5 10 15</span><br><span class="line">1 2 4 8 9 17 34 68 77</span><br></pre></td></tr></table></figure>


<h3 id="迭代加深"><a href="#迭代加深" class="headerlink" title="迭代加深"></a>迭代加深</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">由题意，再经稍加推算已知100以内的数的迭代序列长度不会超过10，</span><br><span class="line">所以这里可以用迭代加深的思想，一层一层地向下搜索</span><br></pre></td></tr></table></figure>

<h3 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.从大到小枚举</span><br><span class="line">2.值相同的元素不用再次搜索</span><br></pre></td></tr></table></figure>



<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span>  a[N];</span><br><span class="line"><span class="keyword">int</span> jud[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (now == depth)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (a[now - <span class="number">1</span>] == n)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(jud, <span class="number">0</span>, <span class="keyword">sizeof</span>(jud));<span class="comment">//每次进入都要初始化一次</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = now - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)<span class="comment">//剪枝1</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span>  t = a[i] + a[j];</span><br><span class="line">			<span class="keyword">if</span> (!jud[t] &amp;&amp; t &lt;= n &amp;&amp; t &gt; a[now - <span class="number">1</span>])<span class="comment">//剪枝2</span></span><br><span class="line">			&#123;</span><br><span class="line">				jud[t] = <span class="number">1</span>;</span><br><span class="line">				a[now] = t;</span><br><span class="line">				<span class="keyword">if</span> (dfs(now + <span class="number">1</span>, depth))</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n, n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> depth = <span class="number">1</span>;</span><br><span class="line">		a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (!dfs(<span class="number">1</span>, depth))<span class="comment">//迭代加深</span></span><br><span class="line">		&#123;</span><br><span class="line">			depth++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; depth; i++)</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>dfs</tag>
        <tag>迭代加深</tag>
      </tags>
  </entry>
  <entry>
    <title>杨老师的照相排列 acwing 271</title>
    <url>/2020/02/17/ac271/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/273/" target="_blank" rel="noopener">Acwing271</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>有 N 个学生合影，站成左端对齐的 k 排，每排分别有 N1,N2,…,Nk 个人。 (N1≥N2≥…≥Nk)</p>
<p>第1排站在最后边，第 k 排站在最前边。</p>
<p>学生的身高互不相同，把他们从高到底依次标记为 1,2,…,N。</p>
<p>在合影时要求每一排从左到右身高递减，每一列从后到前身高也递减。</p>
<p>问一共有多少种安排合影位置的方案？</p>
<p>下面的一排三角矩阵给出了当 N=6,k=3,N1=3,N2=2,N3=1 时的全部16种合影方案。注意身高最高的是1，最低的是6。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">123 123 124 124 125 125 126 126 134 134 135 135 136 136 145 146</span><br><span class="line">45  46  35  36  34  36  34  35  25  26  24  26  24  25  26  25</span><br><span class="line">6   5   6   5   6   4   5   4   6   5   6   4   5   4   3   3</span><br></pre></td></tr></table></figure>


<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入包含多组测试数据。</p>
<p>每组数据两行，第一行包含一个整数k表示总排数。</p>
<p>第二行包含k个整数，表示从后向前每排的具体人数。</p>
<p>当输入k=0的数据时，表示输入终止，且该数据无需处理。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>每组测试数据输出一个答案，表示不同安排的数量。</p>
<p>每个答案占一行。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤k≤5,学生总人数不超过30人。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">30</span><br><span class="line">5</span><br><span class="line">1 1 1 1 1</span><br><span class="line">3</span><br><span class="line">3 2 1</span><br><span class="line">4</span><br><span class="line">5 3 3 1</span><br><span class="line">5</span><br><span class="line">6 5 4 3 2</span><br><span class="line">2</span><br><span class="line">15 15</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">1</span><br><span class="line">16</span><br><span class="line">4158</span><br><span class="line">141892608</span><br><span class="line">9694845</span><br></pre></td></tr></table></figure>

<h3 id="字符串hash"><a href="#字符串hash" class="headerlink" title="字符串hash"></a>字符串hash</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">先正反各计算出字符串hash值，之后再遍历所有中心，并运用二分的方法</span><br><span class="line">求出最大长度</span><br><span class="line"></span><br><span class="line">由于奇数回文串和偶数回文串不一样，我们为了统一这两种情况，将原字符串</span><br><span class="line">扩展为两倍，即在原字符串每两个直接插入一个无关元素，这样便只需在最后</span><br><span class="line">处理结果时判断回文串的边界是否为无关元素即可</span><br></pre></td></tr></table></figure>


<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2000010</span>, base = <span class="number">131</span>;</span><br><span class="line">ull hl[N], hr[N], p[N];</span><br><span class="line"><span class="comment">//hl表示从左往右的字符串hash</span></span><br><span class="line"><span class="comment">//hr表示从右往左的字符串hash</span></span><br><span class="line">ull l, r, mid, res, t;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="function">ull <span class="title">gett</span><span class="params">(ull h[], ull l, ull r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];  <span class="comment">//计算出l~r的字符串的哈希值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%s"</span>, str + <span class="number">1</span>), <span class="built_in">strcmp</span>(str + <span class="number">1</span>, <span class="string">"END"</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> len = <span class="built_in">strlen</span>(str + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = len * <span class="number">2</span>; i; i -= <span class="number">2</span>)<span class="comment">//扩充字符串以合并奇偶串两种情况</span></span><br><span class="line">		&#123;</span><br><span class="line">			str[i] = str[i / <span class="number">2</span>];</span><br><span class="line">			str[i - <span class="number">1</span>] = <span class="string">'z'</span> + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		len *= <span class="number">2</span>;<span class="comment">//合并完长度要乘以2</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = len; i &lt;= len; i++, j--)<span class="comment">//初始化信息</span></span><br><span class="line">		&#123;</span><br><span class="line">			hl[i] = hl[i - <span class="number">1</span>] * base + str[i] - <span class="string">'a'</span> + <span class="number">1</span>;</span><br><span class="line">			hr[i] = hr[i - <span class="number">1</span>] * base + str[j] - <span class="string">'a'</span> + <span class="number">1</span>;</span><br><span class="line">			p[i] = p[i - <span class="number">1</span>] * base;</span><br><span class="line">		&#125;</span><br><span class="line">		res = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			l = <span class="number">0</span>;</span><br><span class="line">			r = min(i - <span class="number">1</span>, len - i);</span><br><span class="line">			<span class="keyword">while</span> (l &lt; r)<span class="comment">//二分法</span></span><br><span class="line">			&#123;</span><br><span class="line">				mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span> (gett(hl, i - mid, i - <span class="number">1</span>) != gett(hr, len - mid - i + <span class="number">1</span>, len - i))<span class="comment">//注意边界的取值</span></span><br><span class="line">					r = mid - <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					l = mid;</span><br><span class="line">			&#125; </span><br><span class="line">			<span class="comment">//mid可理解为回文串中心到两边的距离</span></span><br><span class="line">			mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (str[i - mid] &gt; <span class="string">'z'</span>)<span class="comment">//如果边界是无用字符</span></span><br><span class="line">				res = max(res, mid);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				res = max(res, mid + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Case %d: %d\n"</span>, ++t, res);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>线性DP</tag>
      </tags>
  </entry>
  <entry>
    <title>递归实现指数型枚举 acwing 92</title>
    <url>/2020/02/17/digui1/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/94/" target="_blank" rel="noopener">Acwing92</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>从 1~n 这 n 个整数中随机选取任意多个，输出所有可能的选择方案。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入一个整数n。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>每行输出一种方案。<br>同一行内的数必须升序排列，相邻两个数用恰好1个空格隔开。<br>对于没有选任何数的方案，输出空行。<br>本题有自定义校验器（SPJ），各行（不同方案）之间的顺序任意。</p>
<!--more-->
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>用二进制数表示每个数的选择情况<br>通过移位运算来枚举所有情况</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (now &gt; n) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (now == n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (state &gt;&gt; i &amp; <span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(now + <span class="number">1</span>, (state &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>); <span class="comment">//选择第now个数</span></span><br><span class="line">	dfs(now + <span class="number">1</span>, state &lt;&lt; <span class="number">1</span>);       <span class="comment">//不选第now个数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>递归实现组合型枚举 acwing 93</title>
    <url>/2020/02/17/digui2/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/95/" target="_blank" rel="noopener">Acwing93</a></p>
<a id="more"></a>
<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>从 1~n 这 n 个整数中随机选出 m 个，输出所有可能的选择方案。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>两个整数 n,m ,在同一行用空格隔开。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>按照从小到大的顺序输出所有方案，每行1个。<br>首先，同一行内的数升序排列，相邻两个数用一个空格隔开。<br>其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面（例如1 3 5 7排在1 3 6 8前面）。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>用二进制数表示每个数的选择情况<br>通过移位运算来枚举所有情况</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> state, <span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (now &gt; n || count + (n-now+<span class="number">1</span>) &lt; m)<span class="comment">//若剩下不足m个则返回</span></span><br><span class="line">		 <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (count == m)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (state &gt;&gt; i &amp; <span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(now + <span class="number">1</span>, state+ (<span class="number">1</span> &lt;&lt; now), count + <span class="number">1</span>);<span class="comment">//选择第now位</span></span><br><span class="line">	dfs(now + <span class="number">1</span>, state , count);<span class="comment">//不选第now位</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>递归实现排列型枚举 acwing 94</title>
    <url>/2020/02/17/digui3/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/96/" target="_blank" rel="noopener">Acwing94</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>把 1~n 这 n 个整数排成一行后随机打乱顺序，输出所有可能的次序。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入一个整数n。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>按照从小到大的顺序输出所有方案，每行1个。<br>首先，同一行相邻两个数用一个空格隔开。<br>其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>直接dfs</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> n,j;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (j == n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; a[k] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!b[i])</span><br><span class="line">        &#123;</span><br><span class="line">            b[i] = <span class="number">1</span>;</span><br><span class="line">            a[j] = i;</span><br><span class="line">            j++;</span><br><span class="line">            dfs();</span><br><span class="line">            j--;</span><br><span class="line">            a[j] = <span class="number">0</span>;</span><br><span class="line">            b[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    dfs();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>最短Hamilton路径 acwing 91</title>
    <url>/2020/02/17/hamilton/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/93/" target="_blank" rel="noopener">Acwing91</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定一张n个点的带权无向图，点从 0~n-1 标号，求起点0 到终点n-1的最短Hamilton路径。 Hamilton路径的定义是从0到 n-1不重不漏地经过每个点恰好一次。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入的第一行为一个整数n，表示棋盘的大小。<br>接下来n行，每行n个0或1的整数，如果一个整数为1，表示对应的位置可以放皇后，如果一个整数为0，表示对应的位置不可以放皇后。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个整数，表示总共有多少种放法。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1≤n≤20</span><br><span class="line">0≤a[i,j]≤1e7</span><br></pre></td></tr></table></figure>

<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">0 2 4 5 1</span><br><span class="line">2 0 6 5 3</span><br><span class="line">4 6 0 8 3</span><br><span class="line">5 5 8 0 5</span><br><span class="line">1 3 3 5 0</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">18</span><br></pre></td></tr></table></figure>

<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e8</span>;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">1</span> &lt;&lt; <span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> w[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hamilton</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(f));     <span class="comment">//将f初始化为无穷(每个值并不等于0x3f)</span></span><br><span class="line">	f[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//经过了一个点，且处在一个点为起始位置</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">			<span class="keyword">if</span> (i &gt;&gt; j &amp; <span class="number">1</span>)<span class="comment">//如果该位为1，假设它为当前所处的点</span></span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++)<span class="comment">//用其他路径更新f[i][j]</span></span><br><span class="line">					<span class="keyword">if</span> ((i ^ (<span class="number">1</span> &lt;&lt; j)) &gt;&gt; k &amp; <span class="number">1</span>)</span><br><span class="line">						f[i][j] = min(f[i][j], f[i ^ (<span class="number">1</span> &lt;&lt; j)][k] + w[k][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; w[i][j];</span><br><span class="line">	hamilton();</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; f[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>][n - <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>位运算</tag>
        <tag>状态压缩dp</tag>
      </tags>
  </entry>
  <entry>
    <title>飞行员兄弟 acwing 116</title>
    <url>/2020/02/17/html-day01/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/118/" target="_blank" rel="noopener">Acwing116</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>飞行员兄弟”这个游戏，需要玩家顺利的打开一个拥有16个把手的冰箱。</p>
<p>已知每个把手可以处于以下两种状态之一：打开或关闭。</p>
<p>只有当所有把手都打开时，冰箱才会打开。</p>
<p>把手可以表示为一个4х4的矩阵，您可以改变任何一个位置[i,j]上把手的状态。</p>
<p>但是，这也会使得第i行和第j列上的所有把手的状态也随着改变。</p>
<p>请你求出打开冰箱所需的切换把手的次数最小值是多少。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入一共包含四行，每行包含四个把手的初始状态。</p>
<p>符号“+”表示把手处于闭合状态，而符号“-”表示把手处于打开状态。</p>
<p>至少一个手柄的初始状态是关闭的。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>第一行输出一个整数N，表示所需的最小切换把手次数。</p>
<p>接下来N行描述切换顺序，每行输入两个整数，代表被切换状态的把手的行号和列号，数字之间用空格隔开。</p>
<p>注意：如果存在多种打开冰箱的方式，则按照优先级整体从上到下，同行从左到右打开。</p>
<p>###思路<br>用二进制数表示每个位置的开关状态<br>并定义一个二维数组，每当状态异或这个数组，便改变其对应行与列的状态</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> change[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;PII;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getbit</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">4</span> * x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, k, state=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">string</span> a;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (a[j] == <span class="string">'+'</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				state += <span class="number">1</span> &lt;&lt; getbit(i, j);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++)</span><br><span class="line">			&#123;</span><br><span class="line">				change[i][j] += <span class="number">1</span> &lt;&lt; getbit(i, k);</span><br><span class="line">				change[i][j] += <span class="number">1</span> &lt;&lt; getbit(k, j);</span><br><span class="line">			&#125;</span><br><span class="line">			change[i][j] -= <span class="number">1</span> &lt;&lt; getbit(i, j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">vector</span>&lt;PII&gt; path;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; <span class="number">16</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">vector</span>&lt;PII&gt; temp;</span><br><span class="line">		<span class="keyword">int</span> now = state;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">16</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (i &gt;&gt; j &amp; <span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> x = j / <span class="number">4</span>;</span><br><span class="line">				<span class="keyword">int</span> y = j % <span class="number">4</span>;</span><br><span class="line">				now ^= change[x][y];</span><br><span class="line">				temp.push_back(&#123; x,y &#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!now &amp;&amp; (path.empty()||path.size()&gt;temp.size())) </span><br><span class="line">			path = temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; path.size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; path.size(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; path[i].first + <span class="number">1</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; path[i].second + <span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>位运算</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>木棒 acwing 167</title>
    <url>/2020/02/17/mubang/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/169/" target="_blank" rel="noopener">Acwing167</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>乔治拿来一组等长的木棒，将它们随机地砍断，使得每一节木棍的长度都不超过50个长度单位。然后他又想把这些木棍恢复到为裁截前的状态，但忘记了初始时有多少木棒以及木棒的初始长度。请你设计一个程序，帮助乔治计算木棒的可能最小长度。每一节木棍的长度都用大于零的整数表示</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入包含多组数据，每组数据包括两行。</p>
<p>第一行是一个不超过64的整数，表示砍断之后共有多少节木棍。</p>
<p>第二行是截断以后，所得到的各节木棍的长度。</p>
<p>在最后一组数据之后，是一个零。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>为每组数据，分别输出原始木棒的可能最小长度，每组数据占一行。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>数据保证每一节木棍的长度均不大于50。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9</span><br><span class="line">5 2 1 5 2 1 5 2 1</span><br><span class="line">4</span><br><span class="line">1 2 3 4</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">5</span><br></pre></td></tr></table></figure>

<h3 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.优化搜索顺序</span><br><span class="line">  把木棒的长度从大到小排序，优先尝试较长的木棍</span><br><span class="line">2.排除等效冗余</span><br><span class="line"> (1)可以限制先后加入一根原始木棒的木棍长度是递减的。这是因为先拼</span><br><span class="line">    上长度为x的木棍，再拼上一根长度为y的木棍与先拼y再拼x是等效的。</span><br><span class="line"> (2)对于当前原始木棒，记录最近一次尝试拼接的木棒长度。如果分支搜索</span><br><span class="line">    失败回溯，不再尝试向该木棒中拼接其他相同长度的木棍</span><br><span class="line"> (3)如果在当前拼接的木棒中，尝试拼接第一根木棍就失败，那么该分支</span><br><span class="line">    直接判定为失败，因为剩余的待拼接的木棒都是等价的。</span><br><span class="line"> (4)如果在当前木棒中拼入最后一根木棍后，当前木棒恰被拼接完整，但在</span><br><span class="line">    接下来的某分支中返回失败，则当前分支直接判定为失败，立即回溯。</span><br><span class="line">    因为即使接下来可以将当前木棒拼接完整，用的也是多个更小的木棒</span><br><span class="line">	显然不会优于当前情况</span><br></pre></td></tr></table></figure>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> vis[N], a[N], n, true_n, len, cnt, temp, sum, i, j;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//正在拼第stick根木棒(已经拼好了stick-1根)</span></span><br><span class="line"><span class="comment">//第stick根木棒的当前长度为cab</span></span><br><span class="line"><span class="comment">//拼接到第stick根木棒中的上一根小木棍为last</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> stick, <span class="keyword">int</span> cab, <span class="keyword">int</span> last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (stick &gt; cnt)<span class="comment">//</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span> (cab == len)</span><br><span class="line">		<span class="keyword">return</span> dfs(stick + <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> fail = <span class="number">0</span>;<span class="comment">//剪枝2</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = last; i &lt;= true_n; i++)<span class="comment">//剪枝1</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!vis[i]&amp;&amp;cab+a[i]&lt;=len&amp;&amp;a[i]!=fail)</span><br><span class="line">		&#123;</span><br><span class="line">			vis[i] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (dfs(stick, cab + a[i], i + <span class="number">1</span>))</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			vis[i] = <span class="number">0</span>;</span><br><span class="line">			fail = a[i];</span><br><span class="line">			<span class="keyword">if</span> (cab == <span class="number">0</span> || cab + a[i] == len)<span class="comment">//剪枝3，4</span></span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//所有分支均尝试过，搜索失败</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &amp;&amp; n)</span><br><span class="line">	&#123;</span><br><span class="line">		true_n = <span class="number">0</span>;</span><br><span class="line">		sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">			<span class="keyword">if</span> (temp &gt; <span class="number">50</span>)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			a[++true_n] = temp;</span><br><span class="line">			sum += temp;</span><br><span class="line">		&#125;</span><br><span class="line">		sort(a + <span class="number">1</span>, a + <span class="number">1</span> + true_n, cmp);</span><br><span class="line">		<span class="keyword">for</span> (j = a[true_n]; j &lt;= sum; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (sum%j != <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="comment">//原木棒长度为len，共cnt根</span></span><br><span class="line">			len = j;</span><br><span class="line">			cnt = sum / j;</span><br><span class="line">			<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">			<span class="keyword">if</span> (dfs(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; j &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>dfs</tag>
        <tag>剪枝</tag>
      </tags>
  </entry>
  <entry>
    <title>火车进栈 acwing 129</title>
    <url>/2020/02/17/huochejinzhan/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/131/" target="_blank" rel="noopener">Acwing129</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>题目描述<br>这里有nn列火车将要进站再出站，但是，每列火车只有1节，那就是车头。</p>
<p>这nn列火车按11到nn的顺序从东方左转进站，这个车站是南北方向的，它虽然无限长，只可惜是一个死胡同，而且站台只有一条股道，火车只能倒着从西方出去，而且每列火车必须进站，先进后出。</p>
<p>也就是说这个火车站其实就相当于一个栈，每次可以让右侧头火车进栈，或者让栈顶火车出站。</p>
<p>车站示意如图：</p>
<pre><code>出站&lt;——    &lt;——进站
         |车|
         |站|
         |__|</code></pre><p>现在请你按《字典序》输出前2020种可能的出栈方案。</p>
<p>输入格式<br>输入一个整数nn，代表火车数量。</p>
<p>输出格式<br>按照《字典序》输出前2020种答案，每行一种，不要空格。</p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">123</span><br><span class="line">132</span><br><span class="line">213</span><br><span class="line">231</span><br><span class="line">321</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>dfs 分为三块，出栈，栈内，未进栈，dfs搜索所有情况</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, cnt=<span class="number">20</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;p3;  <span class="comment">//表示出栈的火车</span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;p2;   <span class="comment">//表示栈中的火车</span></span><br><span class="line"><span class="keyword">int</span> p1=<span class="number">1</span>;       <span class="comment">//表示还未进栈的火车</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (cnt == <span class="number">0</span>)    <span class="comment">//当输出满20个时结束</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (p3.size() == n)</span><br><span class="line">	&#123;</span><br><span class="line">		cnt--;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> x : p3) <span class="built_in">cout</span> &lt;&lt; x;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//为了保证字典序，出栈应优先于入栈</span></span><br><span class="line">	<span class="keyword">if</span> (p2.size())<span class="comment">//搜索出栈情况</span></span><br><span class="line">	&#123;</span><br><span class="line">		p3.push_back(p2.top());</span><br><span class="line">		p2.pop();</span><br><span class="line">		dfs();</span><br><span class="line">		p2.push(p3.back());</span><br><span class="line">		p3.pop_back();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (p1 &lt;= n)<span class="comment">//搜索所有入栈的情况</span></span><br><span class="line">	&#123;</span><br><span class="line">		p2.push(p1);</span><br><span class="line">		p1++;</span><br><span class="line">		dfs();</span><br><span class="line">		p1--;</span><br><span class="line">		p2.pop();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	dfs();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>a^b acwing 89</title>
    <url>/2020/02/17/quickcloth/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.acwing.com/problem/content/91/" target="_blank" rel="noopener">Acwing89</a></p>
<a id="more"></a>

<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>求a的b次方对p取模的值。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>三个整数 a,b,p ,在同一行用空格隔开。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个整数，表示<code>a^b mod p</code>的值。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0≤a,b,p≤1e9</span><br></pre></td></tr></table></figure>

<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 2 7</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll res=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">power</span><span class="params">(ll a, ll b,ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">			res = res * a%p;</span><br><span class="line">		a = a * a%p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll a, b, p;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; p;</span><br><span class="line">	power(a, b, p);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>位运算</tag>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>数组模拟邻接表</title>
    <url>/2020/02/17/shuzuljb/</url>
    <content><![CDATA[<p>数组模拟邻接表模板</p>
<a id="more"></a>

<p>这两天做到了很多这样的问题，所以我就想写一下关于这个问题的一些总结</p>
<p>首先我们先看一下常见的代码模板</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to;  <span class="comment">//子节点</span></span><br><span class="line">	<span class="keyword">int</span> w;   <span class="comment">//权值</span></span><br><span class="line">	<span class="keyword">int</span> next;<span class="comment">//head链表的下一个节点</span></span><br><span class="line"></span><br><span class="line">&#125; edge[N * <span class="number">2</span>]; <span class="comment">//N表示的是边的个数，两倍是针对无向边</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], idx = <span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	edge[idx].to = to; <span class="comment">//标记子节点</span></span><br><span class="line">	edge[idx].w = w;   <span class="comment">//记录权值</span></span><br><span class="line">	edge[idx].next = head[from];  <span class="comment">//找出head[from]链表里的下一个元素</span></span><br><span class="line">	head[from] = idx++; </span><br><span class="line">	<span class="comment">//head[from]链表的表头为idx，下一条插入图中的边idx将为idx+1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这里面比较难理解的地方在与这个加边算法，也就是链式向前星。为了思考的方便，我们先不加上w，也就是权重去除。先从一个简单的情况开始思考，也就是存在这样几条边<font color="#bf0000" size="6px"><code>0,1</code></font>、<font color="#bf0000" size="6px"><code>0,2</code></font>、<font color="#bf0000" size="6px"><code>0,3</code></font>、<font color="#bf0000" size="6px"><code>1,3</code></font>、<font color="#bf0000" size="6px"><code>2,3</code></font>。</p>
<p><img src="/images/shuzuljb1.png" alt="alt"></p>
<p>首先考虑添加<font color="#bf0000" size="6px"><code>0-&gt;1</code></font>这条边，此时我们的<font color="#bf0000" size="6px"><code>edge[0] = {to:1, next:-1}</code></font></p>
<p><img src="/images/shuzuljb2.png" alt="alt"></p>
<p>此时我们就可以通过<font color="#bf0000" size="6px"><code>head[0]</code></font>找到<font color="#bf0000" size="6px"><code>edge[0]</code></font>，怎么做的呢？可以这样做</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = head[<span class="number">0</span>];</span><br><span class="line">i = edge[i].next;</span><br></pre></td></tr></table></figure>
<p>上面这两个代码非常重要，使我们遍历整个图的基础。接着添加边<font color="#bf0000" size="6px"><code>0-&gt;2</code></font>，此时我们的<font color="#bf0000" size="6px"><code>edge[1] = {to:2, next:0}</code></font></p>
<p><img src="/images/shuzuljb3.png" alt="alt"></p>
<p>此时我们就可以通过<font color="#bf0000" size="6px"><code>head[0]</code></font>找到<font color="#bf0000" size="6px"><code>edge[1]</code></font>。接下来的过程就是一些重复操作了，最后结果如下</p>
<p><img src="/images/shuzuljb4.png" alt="alt"></p>
<p>那么通过这个图，你就可以发现，每个<font color="#bf0000" size="6px"><code>head[x]</code></font>后面存储的实际上就是<font color="#bf0000" size="6px"><code>x</code></font>的所有子节点。</p>
<p>接着我们就需要思考一下如何遍历这个图，首先通过<font color="#bf0000" size="6px"><code>dfs</code></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    visited[u] = <span class="literal">true</span>;</span><br><span class="line">	<span class="comment">//  ~运算，遇到-1时停止，可替代 &gt;=0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = edge[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> son = edge[i].to;</span><br><span class="line">        <span class="keyword">if</span> (!visited[son]) dfs(son);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>其中<font color="#bf0000" size="6px"><code>u</code></font>表示我们当前遍历的节点。对于深度优先搜索的话，有了前面的图就很好理解了，就是每次遍历一个<font color="#bf0000" size="6px"><code>head</code></font>的所有节点，再从每个节点开始<font color="#bf0000" size="6px"><code>dfs</code></font>。对于访问过的节点，我们需要将其标记为<font color="#bf0000" size="6px"><code>visited</code></font>。</p>
<p>接着我们看如何<font color="#bf0000" size="6px"><code>bfs</code></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"><span class="keyword">bool</span> visited[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">    q[<span class="number">0</span>] = u;</span><br><span class="line">    visited[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = q[hh++];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[t]; ~i; i = edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> son = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span> (!visited[son])</span><br><span class="line">            &#123;</span><br><span class="line">                q[++tt] = son;</span><br><span class="line">                visited[son] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于广度优先搜索的话，有了前面的图就很好理解了，就是每次遍历一个<font color="#bf0000" size="6px"><code>head</code></font>的所有节点。我们每次将当前节点<font color="#bf0000" size="6px"><code>u</code></font>的所有子节点添加到队列<font color="#bf0000" size="6px"><code>q</code></font>中，然后将其标记为访问过了（添加到<font color="#bf0000" size="6px"><code>visited</code></font>中）。终止条件就是遍历到了<font color="#bf0000" size="6px"><code>-1</code></font>，也就是<font color="#bf0000" size="6px"><code>~i</code></font>继续遍历。</p>
]]></content>
      <categories>
        <category>代码模板</category>
      </categories>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
</search>
